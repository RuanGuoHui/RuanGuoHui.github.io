<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr Nguyen的博客</title>
  
  <subtitle>Code阮的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://RuanGuoHui.github.io/"/>
  <updated>2019-09-16T02:31:06.333Z</updated>
  <id>https://RuanGuoHui.github.io/</id>
  
  <author>
    <name>阮国辉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java Web面试题</title>
    <link href="https://RuanGuoHui.github.io/2019/09/16/Java-Web%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://RuanGuoHui.github.io/2019/09/16/Java-Web面试题/</id>
    <published>2019-09-16T02:20:52.000Z</published>
    <updated>2019-09-16T02:31:06.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-请说明一下JSP中的静态包含和动态包含的有哪些区别？"><a href="#1-请说明一下JSP中的静态包含和动态包含的有哪些区别？" class="headerlink" title="1. 请说明一下JSP中的静态包含和动态包含的有哪些区别？"></a>1. 请说明一下JSP中的静态包含和动态包含的有哪些区别？</h3><p>静态包含是通过JSP的include指令包含页面,动态包含是通过JSP标准动作<code>&lt;jsp:include&gt;</code>包含页面。<a id="more"></a></p><p>静态包含是编译时包含,如果包含的页面不存在则会产生编译错误,contentType属性应保持一致,因为两个页面会合二为一,只产生一个class文件,因此被包含页面发生的变动再包含它的页面更新前不会得到更新。</p><p>动态包含是运行时包含,可以向被包含的页面传递参数,包含页面和被包含页面是独立的,会编译出两个class文件,如果被包含的页面不存在,不会产生编译错误,也不影响页面其他部分的执行。</p><p>例如：静态包含<br><code>&lt;%@ include file=&quot;...&quot; %&gt;</code><br>动态包含</p><ul><li><code>&lt;jsp:include page=&quot;...&quot;&gt;</code></li><li><code>&lt;jsp:param name=&quot;...&quot; value=&quot;...&quot; /&gt;</code></li><li><code>&lt;/jsp:include&gt;</code></li></ul><h3 id="2-请说一下表达式语言（EL）的隐式对象以及该对象的作用"><a href="#2-请说一下表达式语言（EL）的隐式对象以及该对象的作用" class="headerlink" title="2. 请说一下表达式语言（EL）的隐式对象以及该对象的作用"></a>2. 请说一下表达式语言（EL）的隐式对象以及该对象的作用</h3><p>EL的隐式对象包括：<strong>pageContext</strong>、<strong>initParam</strong>（访问上下文参数）、<strong>param</strong>（访问请求参数）、<strong>paramValues</strong>、<strong>header</strong>（访问请求头）、<strong>headerValues</strong>、<strong>cookie</strong>（访问cookie）、<strong>applicationScope</strong>（访问application作用域）、<strong>sessionScope</strong>（访问session作用域）、<strong>requestScope</strong>（访问request作用域）、<strong>pageScope</strong>（访问page作用域）。</p><h3 id="3-请谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？"><a href="#3-请谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？" class="headerlink" title="3. 请谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？"></a>3. 请谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？</h3><ul><li>request:封装客户端的请求,其中包含来自GET或POST请求的参数;HttpServletRequest</li><li>response:封装服务器对客户端的响应;HttpServletResponse</li><li>pageContext:通过该对象可获取其他对象;javax.servlet.jsp.PageContext</li><li>session:封装用户回话的对象;javax.servlet.http.HttpSession</li><li>application:封装服务器运行环境的对象;javax.servle.ServletContext</li><li>out:输出服务器响应的输出流对象;javax.jsp.JspWriter</li><li>config:Web应用的配置对象;javax.servlet.ServletConfig</li><li>page:JSP页面本身(相当于Java程序中的this);</li><li>exception:封装页面抛出异常的对象;</li></ul><h3 id="4-请说明一下jsp有哪些动作-这些动作的作用又分别是什么"><a href="#4-请说明一下jsp有哪些动作-这些动作的作用又分别是什么" class="headerlink" title="4. 请说明一下jsp有哪些动作? 这些动作的作用又分别是什么?"></a>4. 请说明一下jsp有哪些动作? 这些动作的作用又分别是什么?</h3><p><strong>JSP共有以下6中基本动作：</strong></p><ul><li>jsp:include:在页面被请求时引入一个文件。</li><li>jsp:useBean:寻找或者实例化一个JavaBean.</li><li>jsp:setProperty:设置JavaBean的属性。</li><li>jsp:getProperty:输出某个JavaBean的属性。</li><li>jsp:forward:把请求转到一个新的页面。</li><li>jsp:plugin:根据浏览器类型为Java插件生成Object或Embed标记。</li></ul><h3 id="5-请详细说明一下Request对象的主要方法是什么？"><a href="#5-请详细说明一下Request对象的主要方法是什么？" class="headerlink" title="5. 请详细说明一下Request对象的主要方法是什么？"></a>5. 请详细说明一下Request对象的主要方法是什么？</h3><ul><li>setAttribute(String name,Object)：设置名字为name的request的参数值</li><li>getAttribute(String name)：返回由name指定的属性值</li><li>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例</li><li>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组</li><li>getCharacterEncoding()：返回请求中的字符编码方式</li><li>getContentLength()：返回请求的Body的长度</li><li>getHeader(String name)：获得HTTP协议定义的文件头信息</li><li>getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例</li><li>getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例</li><li>getInputStream()：返回请求的输入流，用于获得请求中的数据</li><li>getMethod()：获得客户端向服务器端传送数据的方法</li><li>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值</li><li>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li><li>getParameterValues(String name)：获得有name指定的参数的所有值</li><li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</li><li>getQueryString()：获得查询字符串</li><li>getRequestURI()：获取发出请求字符串的客户端地址</li><li>getRemoteAddr()：获取客户端的IP地址</li><li>getRemoteHost()：获取客户端的名字</li><li>getSession([Boolean create])：返回和请求相关Session</li><li>getServerName()：获取服务器的名字</li><li>getServletPath()：获取客户端所请求的脚本文件的路径</li><li>getServerPort()：获取服务器的端口号</li><li>removeAttribute(String name)：删除请求中的一个属性</li></ul><h3 id="6-请简要说明一下四种会话跟踪技术分别是什么？"><a href="#6-请简要说明一下四种会话跟踪技术分别是什么？" class="headerlink" title="6. 请简要说明一下四种会话跟踪技术分别是什么？"></a>6. 请简要说明一下四种会话跟踪技术分别是什么？</h3><ul><li><strong>page</strong>代表与一个页面相关的对象和属性。一个页面由编译好的Java Servlet类表示。这既包括servlet又包括被编译成servlet的JSP页面。</li><li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件(由于forward指令和include动作的关系)。</li><li><strong>session</strong>代表用于某个Web客户机的一个用户体验相关的对象和属性。一个Web回话可以也经常会跨越多个客户机请求。</li><li><strong>application</strong>代表与整个Web应用程序相关的对象和属性。这实质上时跨越整个Web应用程序，包括多个页面、请求和回话的一个全局作用域。</li></ul><h3 id="7-请说明一下web-xml文件中可以配置哪些内容？"><a href="#7-请说明一下web-xml文件中可以配置哪些内容？" class="headerlink" title="7. 请说明一下web.xml文件中可以配置哪些内容？"></a>7. 请说明一下web.xml文件中可以配置哪些内容？</h3><p>web.xml用于配置Web应用的相关信息，如：<strong>监听器</strong>（listener）、<strong>过滤器</strong>（filter）、 <strong>Servlet</strong>、<strong>相关参数</strong>、<strong>会话超时时间</strong>、<strong>安全验证方式</strong>、<strong>错误页面</strong>等，下面是一些开发中常见的配置：</p><ol><li>配置Spring上下文加载监听器加载Spring配置文件并创建IOC容器：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  org.springframework.web.context.ContextLoaderListener</span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置会话超时时间为10分钟：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>10<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置404和Exception的错误页面：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.Exception<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-请谈谈你对JavaWeb开发中的监听器的理解？"><a href="#8-请谈谈你对JavaWeb开发中的监听器的理解？" class="headerlink" title="8. 请谈谈你对JavaWeb开发中的监听器的理解？"></a>8. 请谈谈你对JavaWeb开发中的监听器的理解？</h3><p><a href="https://www.nowcoder.com/questionTerminal/ac5eb247f0f2425ea9471525ffde5cee" rel="external nofollow noopener noreferrer" target="_blank">链接</a><br>来源：牛客网</p><p>监听器是一个专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时，立即采取相应的行动。</p><p> 监听器其实就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法立即被执行。<br> java中的事件监听机制可用图来表示：</p><p><img src="002.png" alt></p><h4 id="8-1-JavaWeb开发中常见监听器"><a href="#8-1-JavaWeb开发中常见监听器" class="headerlink" title="8.1 JavaWeb开发中常见监听器"></a>8.1 JavaWeb开发中常见监听器</h4><p>Java Web开发中的监听器（listener）就是<strong>application</strong>、<strong>session</strong>、<strong>request</strong>三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：</p><p><strong>监听域对象的创建和销毁：</strong></p><ul><li>监听ServletContext创建与销毁   ServletContextListener</li><li>监听HttpSession创建与销毁   HttpSessionListener</li><li>监听HttpServletRequest创建与销毁  ServletRequestListener</li></ul><p><strong>监听域对象的属性变化：</strong></p><ul><li>监听ServletContext属性变化  ServletContextAttributeListener</li><li>监听HttpSession属性变化  HttpSessionAttributeListener</li><li>监听HttpServletRequest属性变化  ServletRequestAttributeListener</li></ul><p><strong>监听session绑定javaBean</strong></p><ul><li>它是用于监听javaBean对象是否绑定到了session域   HttpSessionBindingListener</li><li>它是用于监听javaBean对象的活化与钝化  HttpSessionActivationListener</li></ul><h3 id="9-请问过滤器有哪些作用？以及过滤器的用法又是什么呢"><a href="#9-请问过滤器有哪些作用？以及过滤器的用法又是什么呢" class="headerlink" title="9. 请问过滤器有哪些作用？以及过滤器的用法又是什么呢?"></a>9. 请问过滤器有哪些作用？以及过滤器的用法又是什么呢?</h3><p>对Web应用来说，过滤器是一个驻留在服务器端的<strong>Web组件</strong>，它可以<strong>截取</strong>客户端和服务器之间的<strong>请求与响应信息</strong>，并对这些信息<strong>进行过滤</strong>。当Web容器<strong>接受</strong>到一个对资源的<strong>请求时</strong>，它<strong>将判断</strong>是否有过滤器与这个资源相<strong>关联</strong>。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你<strong>可以改变</strong>请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对<strong>请求作出响应时候</strong>，容器同样会将响应先转发给过滤器，在过滤器中你可以对响应的内容进行转换，然后再将响应发送到客户端。</p><p>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。</p><p>和过滤器相关的接口主要有：Filter、FilterConfig和FilterChain。</p><h3 id="10-说说Servlet接口中有哪些方法？"><a href="#10-说说Servlet接口中有哪些方法？" class="headerlink" title="10. 说说Servlet接口中有哪些方法？"></a>10. 说说Servlet接口中有哪些方法？</h3><p>Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关：</p><ul><li>void init(ServletConfig config) throws ServletException</li><li>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</li><li>void destory()</li><li>java.lang.String getServletInfo()</li><li>ServletConfig getServletConfig()</li></ul><h4 id="10-1-Servlet的生命周期"><a href="#10-1-Servlet的生命周期" class="headerlink" title="10.1 Servlet的生命周期"></a>10.1 Servlet的生命周期</h4><p>Web容器<strong>加载Servlet并将其实例化</strong>后，Servlet生命周期开始，容器<strong>运行</strong>其init()方法进行Servlet的初始化；<strong>请求到达</strong>时调用Servlet的service()方法，service()方法会<strong>根据</strong>需要调用与请求对应的doGet或doPost等方法；当<strong>服务器关闭</strong>或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。</p><h3 id="11-Servlet和CGI的区别"><a href="#11-Servlet和CGI的区别" class="headerlink" title="11. Servlet和CGI的区别"></a>11. Servlet和CGI的区别</h3><p>与cgi的区别在于servlet<strong>处于</strong>服务器进程中，它<strong>通过多线程</strong>方式运行其service方法，<strong>一个实例可以服务于多个请求</strong>，并且其实例一般不会销毁，而CGI对<strong>每个请求</strong>都产生新的进程，服务完成后就销毁，所以效率上低于servlet</p><h3 id="12-说说你对get和post请求，并且说说它们之间的区别？"><a href="#12-说说你对get和post请求，并且说说它们之间的区别？" class="headerlink" title="12. 说说你对get和post请求，并且说说它们之间的区别？"></a>12. 说说你对get和post请求，并且说说它们之间的区别？</h3><ul><li>get请求用来从服务器上获得资源,而post是用来向服务器提交数据;</li><li>get将表单中的数据按照name=value的形式,添加到action所指向的URL后面,并且两者使用“?”连接,而各个变量之间用“&amp;”连接;post是将表单中的数据放在HTTP协议的请求头或消息体中,传递到action所指向URL;</li><li>get传输的数据要受URL长度限制(1024字节);而post可以传输大量的数据,上传文件通常要使用post方式;</li><li>使用get时参数会显示在地址栏上,如果这些数据不是敏感数据,那么可以使用get;对于敏感数据还是应使用post；</li><li>get使用MIME类型application/x-www-form-urlencoded的URL编码(也叫百分号编码)文本的格式传递参数,保证被传送的参数由遵循规范的文本组成,例如一个空格的编码”%20”</li></ul><h3 id="13-请你说说，cookie-和-session-的区别？"><a href="#13-请你说说，cookie-和-session-的区别？" class="headerlink" title="13. 请你说说，cookie 和 session 的区别？"></a>13. 请你说说，cookie 和 session 的区别？</h3><ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</li><li>单个cookie保存的数据不能超过4k,很多浏览器都限制一个站点最多保存20个cookie</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-请说明一下JSP中的静态包含和动态包含的有哪些区别？&quot;&gt;&lt;a href=&quot;#1-请说明一下JSP中的静态包含和动态包含的有哪些区别？&quot; class=&quot;headerlink&quot; title=&quot;1. 请说明一下JSP中的静态包含和动态包含的有哪些区别？&quot;&gt;&lt;/a&gt;1. 请说明一下JSP中的静态包含和动态包含的有哪些区别？&lt;/h3&gt;&lt;p&gt;静态包含是通过JSP的include指令包含页面,动态包含是通过JSP标准动作&lt;code&gt;&amp;lt;jsp:include&amp;gt;&lt;/code&gt;包含页面。
    
    </summary>
    
      <category term="面试" scheme="https://RuanGuoHui.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java" scheme="https://RuanGuoHui.github.io/categories/%E9%9D%A2%E8%AF%95/Java/"/>
    
    
      <category term="面试" scheme="https://RuanGuoHui.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java Web" scheme="https://RuanGuoHui.github.io/tags/Java-Web/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之程序员常用10种算法</title>
    <link href="https://RuanGuoHui.github.io/2019/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%94%A810%E7%A7%8D%E7%AE%97%E6%B3%95/"/>
    <id>https://RuanGuoHui.github.io/2019/07/28/数据结构与算法之程序员常用10种算法/</id>
    <published>2019-07-28T01:44:41.000Z</published>
    <updated>2019-07-28T03:07:15.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-二分查找算法（非递归）"><a href="#1-二分查找算法（非递归）" class="headerlink" title="1.二分查找算法（非递归）"></a>1.二分查找算法（非递归）</h2><h3 id="1-1-二分查找算法（非递归）介绍"><a href="#1-1-二分查找算法（非递归）介绍" class="headerlink" title="1.1 二分查找算法（非递归）介绍"></a>1.1 二分查找算法（非递归）介绍</h3><p>1）前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式  <a id="more"></a><br>2）二分查找法只适用于从有序的数列中进行查找（比如数字和字母等），将数列排序后再进行查找<br>3）二分查找法的运行时间为对数时间O（log2 n），即查找到需要的目标位置最多只需要log2n步，假设从[0，99]的队列（100个数，即n=100）中寻到目标数30，则需要查找步数为log2100，即最多需要查找7次（2^6&lt;100&lt;2^7）</p><h3 id="1-2-二分查找算法（非递归）代码实现"><a href="#1-2-二分查找算法（非递归）代码实现" class="headerlink" title="1.2 二分查找算法（非递归）代码实现"></a>1.2 二分查找算法（非递归）代码实现</h3><p>数组{1，3，8，10，11，67，100}，编程实现二分查找，要求使用非递归的方式完成.<br>1）思路分析：<br>2）代码实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.binarysearchnorecursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchNoRecur</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">100</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = binarySearch(arr, <span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"index="</span> + index);<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找的非递归实现</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待查找的数组, arr是升序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 需要查找的数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回对应下标，-1表示没有找到</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123; <span class="comment">//说明继续查找</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[mid] == target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;<span class="comment">//需要向左边查找</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left = mid + <span class="number">1</span>; <span class="comment">//需要向右边查找</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-分治算法"><a href="#2-分治算法" class="headerlink" title="2.分治算法"></a>2.分治算法</h2><h3 id="2-1-分治算法介绍"><a href="#2-1-分治算法介绍" class="headerlink" title="2.1 分治算法介绍"></a>2.1 分治算法介绍</h3><p>1）分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换（快速傅立叶变换）……<br>2）分治算法可以求解的一些经典问题<br>√二分搜索<br>√大整数乘法<br>√棋盘覆盖<br>√合并排序<br>√快速排序<br>√线性时间选择<br>√最接近点对问题<br>√循环赛日程表<br>√汉诺塔  </p><h3 id="2-2-分治算法的基本步骤"><a href="#2-2-分治算法的基本步骤" class="headerlink" title="2.2 分治算法的基本步骤"></a>2.2 分治算法的基本步骤</h3><p>分治法在每一层递归上都有三个步骤：<br>1）分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题<br>2）解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题<br>3）合并：将各个子问题的解合并为原问题的解。  </p><h3 id="2-3-分治（Divide-and-Conquer（P））算法设计模式如下："><a href="#2-3-分治（Divide-and-Conquer（P））算法设计模式如下：" class="headerlink" title="2.3 分治（Divide-and-Conquer（P））算法设计模式如下："></a>2.3 分治（Divide-and-Conquer（P））算法设计模式如下：</h3><p><img src="001.PNG" alt>  </p><h3 id="2-4-分治算法最佳实践-汉诺塔"><a href="#2-4-分治算法最佳实践-汉诺塔" class="headerlink" title="2.4 分治算法最佳实践-汉诺塔"></a>2.4 分治算法最佳实践-汉诺塔</h3><h4 id="2-4-1-汉诺塔的传说"><a href="#2-4-1-汉诺塔的传说" class="headerlink" title="2.4.1 汉诺塔的传说"></a>2.4.1 汉诺塔的传说</h4><p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。<br>假如每秒钟一次，共需多长时间呢？移完这些金片需要5845.54亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。  </p><h4 id="2-4-2-汉诺塔游戏的演示和思路分析："><a href="#2-4-2-汉诺塔游戏的演示和思路分析：" class="headerlink" title="2.4.2 汉诺塔游戏的演示和思路分析："></a>2.4.2 汉诺塔游戏的演示和思路分析：</h4><p>1）如果是有一个盘，A-&gt;C<br>如果我们有n&gt;=2情况，我们总是可以看做是两个盘1.最下边的盘2.上面的盘<br>2）先把最上面的盘A-&gt;B<br>3）把最下边的盘A-&gt;C<br>4）把B塔的所有盘从B-&gt;C  </p><h4 id="2-4-3-汉诺塔游戏的代码实现："><a href="#2-4-3-汉诺塔游戏的代码实现：" class="headerlink" title="2.4.3 汉诺塔游戏的代码实现："></a>2.4.3 汉诺塔游戏的代码实现：</h4><p>看代码演示：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.dac;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoitower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">hanoiTower(<span class="number">10</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汉诺塔的移动的方法</span></span><br><span class="line"><span class="comment">//使用分治算法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoiTower</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果只有一个盘</span></span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"第1个盘从 "</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘</span></span><br><span class="line"><span class="comment">//1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c</span></span><br><span class="line">hanoiTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line"><span class="comment">//2. 把最下边的盘 A-&gt;C</span></span><br><span class="line">System.out.println(<span class="string">"第"</span> + num + <span class="string">"个盘从 "</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line"><span class="comment">//3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔  </span></span><br><span class="line">hanoiTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-动态规划算法"><a href="#3-动态规划算法" class="headerlink" title="3.动态规划算法"></a>3.动态规划算法</h2><h3 id="3-1应用场景-背包问题"><a href="#3-1应用场景-背包问题" class="headerlink" title="3.1应用场景-背包问题"></a>3.1应用场景-背包问题</h3><p>背包问题：有一个背包，容量为4磅，现有如下物品<br><img src="002.PNG" alt><br>1）要求达到的目标为装入的背包的总价值最大，并且重量不超出<br>2）要求装入的物品不能重复  </p><h3 id="3-2-动态规划算法介绍"><a href="#3-2-动态规划算法介绍" class="headerlink" title="3.2 动态规划算法介绍"></a>3.2 动态规划算法介绍</h3><p>1）动态规划（Dynamic Programming）算法的核心思想是：<strong>将大问题划分为小问题</strong>进行解决，从而一步步获取最优解的处理算法<br>2）动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。<br>3）与分治法不同的是，适合于用动态规划求解的问题，经分解得到<strong>子问题往往不是互相独立的</strong>。（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）<br>4）动态规划可以通过填表的方式来逐步推进，得到最优解.  </p><h3 id="3-3-动态规划算法最佳实践-背包问题"><a href="#3-3-动态规划算法最佳实践-背包问题" class="headerlink" title="3.3 动态规划算法最佳实践-背包问题"></a>3.3 动态规划算法最佳实践-背包问题</h3><p>背包问题：有一个背包，容量为4磅，现有如下物品<br><img src="003.PNG" alt><br>1）要求达到的目标为装入的背包的总价值最大，并且重量不超出<br>2）要求装入的物品不能重复<br>思路分析和图解<br>3）背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分<strong>01背包</strong>和<strong>完全背包</strong>（完全背包指的是：每种物品都有无限件可用）<br>4）这里的问题属于<strong>01</strong>背包，即每个物品最多放一个。而无限背包可以转化为01背包。<br>5）算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和vi]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、wi]分别为第i个物品的价值和重量，C为背包的容量。再令v[ii]<br>表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：  </p><pre><code>（1）v[i][0]=v[0][j]=0；//表示填入表第一行和第一列是0（2）当w[i]&gt;j时：v[i][j]=v[i-1][i]//当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略（3）当j&gt;=w[i]时：v[i][j]-max{v[i-1][j]，v[i]+v[i-1][j-w[i]]}//当准备加入的新增的商品的容量小于等于当前背包的容量，//装入的方式：v[i-1][j]：就是上一个单元格的装入的最大值v[i]：表示当前商品的价值v[i-1][j-w[i]]：装入i-1商品，到剩余空间j-w[i]的最大值  当j&gt;=w[i]时：v[i][j]-max{v[i-1][j]，v[i]+v[i-1][i-w[i]]}：</code></pre><p>6）图解的分析<br><img src="004.PNG" alt>  </p><h3 id="3-4-动态规划-背包问题的代码实现"><a href="#3-4-动态规划-背包问题的代码实现" class="headerlink" title="3.4 动态规划-背包问题的代码实现"></a>3.4 动态规划-背包问题的代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;<span class="comment">//物品的重量</span></span><br><span class="line"><span class="keyword">int</span>[] val = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;; <span class="comment">//物品的价值 这里val[i] 就是前面讲的v[i]</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">4</span>; <span class="comment">//背包的容量</span></span><br><span class="line"><span class="keyword">int</span> n = val.length; <span class="comment">//物品的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二维数组，</span></span><br><span class="line"><span class="comment">//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值</span></span><br><span class="line"><span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//为了记录放入商品的情况，我们定一个二维数组</span></span><br><span class="line"><span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">v[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//将第一列设置为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; v[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">v[<span class="number">0</span>][i] = <span class="number">0</span>; <span class="comment">//将第一行设置0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据前面得到公式来动态规划处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123; <span class="comment">//不处理第一行 i是从1开始的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;<span class="comment">//不处理第一列, j是从1开始的</span></span><br><span class="line"><span class="comment">//公式</span></span><br><span class="line"><span class="keyword">if</span>(w[i-<span class="number">1</span>]&gt; j) &#123; <span class="comment">// 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]</span></span><br><span class="line">v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//说明:</span></span><br><span class="line"><span class="comment">//因为我们的i 从1开始的， 因此公式需要调整成</span></span><br><span class="line"><span class="comment">//v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);</span></span><br><span class="line"><span class="comment">//v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);</span></span><br><span class="line"><span class="comment">//为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式</span></span><br><span class="line"><span class="keyword">if</span>(v[i - <span class="number">1</span>][j] &lt; val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">v[i][j] = val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line"><span class="comment">//把当前的情况记录到path</span></span><br><span class="line">path[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出一下v 看看目前的情况</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; v.length;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].length;j++) &#123;</span><br><span class="line">System.out.print(v[i][j] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"============================"</span>);</span><br><span class="line"><span class="comment">//输出最后我们是放入的哪些商品</span></span><br><span class="line"><span class="comment">//遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入</span></span><br><span class="line"><span class="comment">//for(int i = 0; i &lt; path.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//for(int j=0; j &lt; path[i].length; j++) &#123;</span></span><br><span class="line"><span class="comment">//if(path[i][j] == 1) &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("第%d个商品放入到背包\n", i);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动脑筋</span></span><br><span class="line"><span class="keyword">int</span> i = path.length - <span class="number">1</span>; <span class="comment">//行的最大下标</span></span><br><span class="line"><span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>;  <span class="comment">//列的最大下标</span></span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span> ) &#123; <span class="comment">//从path的最后开始找</span></span><br><span class="line"><span class="keyword">if</span>(path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">"第%d个商品放入到背包\n"</span>, i); </span><br><span class="line">j -= w[i-<span class="number">1</span>]; <span class="comment">//w[i-1]</span></span><br><span class="line">&#125;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-KMP算法"><a href="#4-KMP算法" class="headerlink" title="4.KMP算法"></a>4.KMP算法</h2><h3 id="4-1-应用场景-字符串匹配问题"><a href="#4-1-应用场景-字符串匹配问题" class="headerlink" title="4.1 应用场景-字符串匹配问题"></a>4.1 应用场景-字符串匹配问题</h3><h4 id="4-1-1-字符串匹配问题：："><a href="#4-1-1-字符串匹配问题：：" class="headerlink" title="4.1.1 字符串匹配问题：："></a>4.1.1 字符串匹配问题：：</h4><p>1）有一个字符串str1=””硅硅谷尚硅谷你尚硅尚硅谷你尚硅谷你尚硅你好””，和一个子串str2=”尚硅谷你尚硅你”<br>2）现在要判断str1是否含有str2，如果存在，就返回第一次出现的位置，如果没有，则返回-1  </p><h3 id="4-2-暴力匹配算法"><a href="#4-2-暴力匹配算法" class="headerlink" title="4.2 暴力匹配算法"></a>4.2 暴力匹配算法</h3><p>如果用暴力匹配的思路，并假设现在strl匹配到i位置，子串str2匹配到j位置，则有：<br>1）如果当前字符匹配成功（即str1[i]==str2[j]），则i++，j++，继续匹配下一个字符<br>2）如果失配（即str1[i]！=str2[j]），令i=i-（j-1），j=0。相当于每次匹配失败时，i回溯，j被置为0。<br>3）用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。（不可行！）<br>4）暴力匹配算法实现.<br>5）代码  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.kmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViolenceMatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//测试暴力匹配算法</span></span><br><span class="line">String str1 = <span class="string">"硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好"</span>;</span><br><span class="line">String str2 = <span class="string">"尚硅谷你尚硅你~"</span>;</span><br><span class="line"><span class="keyword">int</span> index = violenceMatch(str1, str2);</span><br><span class="line">System.out.println(<span class="string">"index="</span> + index);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力匹配算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violenceMatch</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] s1 = str1.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s1Len = s1.length;</span><br><span class="line"><span class="keyword">int</span> s2Len = s2.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// i索引指向s1</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// j索引指向s2</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;<span class="comment">// 保证匹配时，不越界</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s1[i] == s2[j]) &#123;<span class="comment">//匹配ok</span></span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//没有匹配成功</span></span><br><span class="line"><span class="comment">//如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。</span></span><br><span class="line">i = i - (j - <span class="number">1</span>);</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否匹配成功</span></span><br><span class="line"><span class="keyword">if</span>(j == s2Len) &#123;</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-KMP算法介绍"><a href="#4-3-KMP算法介绍" class="headerlink" title="4.3 KMP算法介绍"></a>4.3 KMP算法介绍</h3><p>1）KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法<br>2）Knuth-Morris-Pratt 字符串查找算法，简称为“KMP算法”，常用于在一个文本串S内查找一个模式串P的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H.Morris 三人于1977年联合发表，故取这3人的姓氏命名此算法.<br>3）KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间<br>4）<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" rel="external nofollow noopener noreferrer" target="_blank">参考资料</a></p><h3 id="4-4-KMP算法最佳应用-字符串匹配问题"><a href="#4-4-KMP算法最佳应用-字符串匹配问题" class="headerlink" title="4.4 KMP算法最佳应用-字符串匹配问题"></a>4.4 KMP算法最佳应用-字符串匹配问题</h3><h4 id="4-4-1-字符串匹配问题：："><a href="#4-4-1-字符串匹配问题：：" class="headerlink" title="4.4.1 字符串匹配问题：："></a>4.4.1 字符串匹配问题：：</h4><p>1）有一个字符串str1=”BBCABCDABABCDABCDABDE”，和一个子串str2=”ABCDABD”<br>2）现在要判断str1是否含有str2，如果存在，就返回第一次出现的位置，如果没有，则返回-1<br>3）要求：使用<strong>KMP算法</strong>完成判断，不能使用简单的暴力匹配算法.</p><h4 id="4-4-2-思路分析图解"><a href="#4-4-2-思路分析图解" class="headerlink" title="4.4.2 思路分析图解"></a>4.4.2 思路分析图解</h4><p><img src="005.PNG" alt><br><img src="006.PNG" alt><br><img src="007.PNG" alt><br><img src="008.PNG" alt><br><img src="009.PNG" alt><br><img src="010.PNG" alt><br><img src="011.PNG" alt><br><img src="012.PNG" alt>  </p><h4 id="4-4-3-代码实现"><a href="#4-4-3-代码实现" class="headerlink" title="4.4.3 代码实现"></a>4.4.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.kmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line"><span class="comment">//String str2 = "BBC";</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] next = kmpNext(<span class="string">"ABCDABD"</span>); <span class="comment">//[0, 1, 2, 0]</span></span><br><span class="line">System.out.println(<span class="string">"next="</span> + Arrays.toString(next));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = kmpSearch(str1, str2, next);</span><br><span class="line">System.out.println(<span class="string">"index="</span> + index); <span class="comment">// 15了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写出我们的kmp搜索算法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str1 源字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 部分匹配表, 是子串对应的部分匹配表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果是-1就是没有匹配到，否则返回第一个匹配的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小</span></span><br><span class="line"><span class="comment">//KMP算法核心点, 可以验证...</span></span><br><span class="line"><span class="keyword">while</span>( j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">j = next[j-<span class="number">1</span>]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j == str2.length()) &#123;<span class="comment">//找到了 // j = 3 i </span></span><br><span class="line"><span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取到一个字符串(子串) 的部分匹配值表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span>[] kmpNext(String dest) &#123;</span><br><span class="line"><span class="comment">//创建一个next 数组保存部分匹配值</span></span><br><span class="line"><span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//如果字符串是长度为1 部分匹配值就是0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line"><span class="comment">//当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j</span></span><br><span class="line"><span class="comment">//直到我们发现 有  dest.charAt(i) == dest.charAt(j)成立才退出</span></span><br><span class="line"><span class="comment">//这时kmp算法的核心点</span></span><br><span class="line"><span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;</span><br><span class="line">j = next[j-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1</span></span><br><span class="line"><span class="keyword">if</span>(dest.charAt(i) == dest.charAt(j)) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-贪心算法"><a href="#5-贪心算法" class="headerlink" title="5.贪心算法"></a>5.贪心算法</h2><h3 id="5-1-应用场景-集合覆盖问题"><a href="#5-1-应用场景-集合覆盖问题" class="headerlink" title="5.1 应用场景-集合覆盖问题"></a>5.1 应用场景-集合覆盖问题</h3><p>假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号<br><img src="013.PNG" alt>  </p><h3 id="5-2-贪心算法介绍"><a href="#5-2-贪心算法介绍" class="headerlink" title="5.2 贪心算法介绍"></a>5.2 贪心算法介绍</h3><p>1）贪婪算法（贪心算法）是指在对问题进行求解时，<strong>在每一步选择中都采取最好或者最优（即最有利）的选择</strong>，从而希望能够导致结果是最好或者最优的算法<br>2）贪婪算法所得到的结果不一定是最优的结果（有时候会是最优解），但是都是相对近似（接近）最优解的结果  </p><h3 id="5-3-贪心算法最佳应用-集合覆盖"><a href="#5-3-贪心算法最佳应用-集合覆盖" class="headerlink" title="5.3 贪心算法最佳应用-集合覆盖"></a>5.3 贪心算法最佳应用-集合覆盖</h3><p>1）假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号<br><img src="014.PNG" alt><br>2）思路分析：  </p><pre><code>如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现，列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有2n-1个，假设每秒可以计算10个子集，如图：</code></pre><p><img src="015.PNG" alt>  </p><pre><code>使用贪婪算法，效率高：1）目前并没有算法可以快速计算得到准备的值，使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合：  2）遍历所有的广播电台，找到一个覆盖了最多未覆盖的地区的电台（此电台可能包含一些已覆盖的地区，但没有关系）  3）将这个电台加入到一个集合中（比如ArrayList），想办法把该电台覆盖的地区在下次比较时去掉。  4）重复第1步直到覆盖了全部的地区  </code></pre><p>分析的图解：<br><img src="016.PNG" alt><br>3）代码实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.greedy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建广播电台,放入到Map</span></span><br><span class="line">HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;String&gt;&gt;();</span><br><span class="line"><span class="comment">//将各个电台放入到broadcasts</span></span><br><span class="line">HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">hashSet1.add(<span class="string">"北京"</span>);</span><br><span class="line">hashSet1.add(<span class="string">"上海"</span>);</span><br><span class="line">hashSet1.add(<span class="string">"天津"</span>);</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">hashSet2.add(<span class="string">"广州"</span>);</span><br><span class="line">hashSet2.add(<span class="string">"北京"</span>);</span><br><span class="line">hashSet2.add(<span class="string">"深圳"</span>);</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">hashSet3.add(<span class="string">"成都"</span>);</span><br><span class="line">hashSet3.add(<span class="string">"上海"</span>);</span><br><span class="line">hashSet3.add(<span class="string">"杭州"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">hashSet4.add(<span class="string">"上海"</span>);</span><br><span class="line">hashSet4.add(<span class="string">"天津"</span>);</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">hashSet5.add(<span class="string">"杭州"</span>);</span><br><span class="line">hashSet5.add(<span class="string">"大连"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入到map</span></span><br><span class="line">broadcasts.put(<span class="string">"K1"</span>, hashSet1);</span><br><span class="line">broadcasts.put(<span class="string">"K2"</span>, hashSet2);</span><br><span class="line">broadcasts.put(<span class="string">"K3"</span>, hashSet3);</span><br><span class="line">broadcasts.put(<span class="string">"K4"</span>, hashSet4);</span><br><span class="line">broadcasts.put(<span class="string">"K5"</span>, hashSet5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//allAreas 存放所有的地区</span></span><br><span class="line">HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">allAreas.add(<span class="string">"北京"</span>);</span><br><span class="line">allAreas.add(<span class="string">"上海"</span>);</span><br><span class="line">allAreas.add(<span class="string">"天津"</span>);</span><br><span class="line">allAreas.add(<span class="string">"广州"</span>);</span><br><span class="line">allAreas.add(<span class="string">"深圳"</span>);</span><br><span class="line">allAreas.add(<span class="string">"成都"</span>);</span><br><span class="line">allAreas.add(<span class="string">"杭州"</span>);</span><br><span class="line">allAreas.add(<span class="string">"大连"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建ArrayList, 存放选择的电台集合</span></span><br><span class="line">ArrayList&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key</span></span><br><span class="line"><span class="comment">//如果maxKey 不为null , 则会加入到 selects</span></span><br><span class="line">String maxKey = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(allAreas.size() != <span class="number">0</span>) &#123; <span class="comment">// 如果allAreas 不为0, 则表示还没有覆盖到所有的地区</span></span><br><span class="line"><span class="comment">//每进行一次while,需要</span></span><br><span class="line">maxKey = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 broadcasts, 取出对应key</span></span><br><span class="line"><span class="keyword">for</span>(String key : broadcasts.keySet()) &#123;</span><br><span class="line"><span class="comment">//每进行一次for</span></span><br><span class="line">tempSet.clear();</span><br><span class="line"><span class="comment">//当前这个key能够覆盖的地区</span></span><br><span class="line">HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">tempSet.addAll(areas);</span><br><span class="line"><span class="comment">//求出tempSet 和   allAreas 集合的交集, 交集会赋给 tempSet</span></span><br><span class="line">tempSet.retainAll(allAreas);</span><br><span class="line"><span class="comment">//如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多</span></span><br><span class="line"><span class="comment">//就需要重置maxKey</span></span><br><span class="line"><span class="comment">// tempSet.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的</span></span><br><span class="line"><span class="keyword">if</span>(tempSet.size() &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">(maxKey == <span class="keyword">null</span> || tempSet.size() &gt;broadcasts.get(maxKey).size()))&#123;</span><br><span class="line">maxKey = key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//maxKey != null, 就应该将maxKey 加入selects</span></span><br><span class="line"><span class="keyword">if</span>(maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">selects.add(maxKey);</span><br><span class="line"><span class="comment">//将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉</span></span><br><span class="line">allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"得到的选择结果是"</span> + selects);<span class="comment">//[K1,K2,K3,K5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-贪心算法注意事项和细节"><a href="#5-4-贪心算法注意事项和细节" class="headerlink" title="5.4 贪心算法注意事项和细节"></a>5.4 贪心算法注意事项和细节</h3><p>1）贪婪算法所得到的结果不一定是最优的结果（有时候会是最优解），但是都是相对近似（接近）最优解的结果<br>2）比如上题的算法选出的是K1，K2，K3，K5，符合覆盖了全部的地区<br>3）但是我们发现K2，K3，K4，K5也可以覆盖全部地区，如果K2的使用成本低于K1，那么我们上题的K1，K2，K3，K5虽然是满足条件，但是并不是最优的.  </p><h2 id="6-普里姆算法"><a href="#6-普里姆算法" class="headerlink" title="6.普里姆算法"></a>6.普里姆算法</h2><h3 id="6-1-应用场景-修路问题"><a href="#6-1-应用场景-修路问题" class="headerlink" title="6.1 应用场景-修路问题"></a>6.1 应用场景-修路问题</h3><h4 id="6-1-1-看一个应用场景和问题"><a href="#6-1-1-看一个应用场景和问题" class="headerlink" title="6.1.1 看一个应用场景和问题"></a>6.1.1 看一个应用场景和问题</h4><p><img src="017.PNG" alt><br>1）有胜利乡有7个村庄（A，B，C，D，E，F，G），现在需要修路把7个村庄连通<br>2）各个村庄的距离用边线表示（权），比如A-B距离5公里<br>3）问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短？<br><strong>思路</strong>：将10条边，连接即可，但是总的里程数不是最小.<br>正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少。  </p><h3 id="6-2-最小生成树"><a href="#6-2-最小生成树" class="headerlink" title="6.2 最小生成树"></a>6.2 最小生成树</h3><p>修路问题本质就是就是<strong>最小生成树问题</strong>，先介绍一下最小生成树（Minimum Cost Spanning Tree），简称MST。<br>给定一个带权的无向连通图，如何选取一棵生成树，使树上所有边上权的总和为最小，这叫最小生成树<br>1）N个顶点，一定有N-1条边<br>2）包含全部顶点<br>3）N-1条边都在图中<br>4）举例说明（如图：）<br>5）求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法<br><img src="018.PNG" alt>  </p><h3 id="6-3-普里姆算法介绍"><a href="#6-3-普里姆算法介绍" class="headerlink" title="6.3 普里姆算法介绍"></a>6.3 普里姆算法介绍</h3><p>普利姆（Prim）算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有（n-1）条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图<br>普利姆的算法如下：<br>1）设G=（V,E）是连通网，T-（U，D）是最小生成树，V,U是顶点集合，E，D是边的集合<br>2）若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1<br>3）若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui，vj）加入集合D中，标记visited[vj]=1<br>4）重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边<br>5）提示：单独看步骤很难理解，我们通过代码来讲解，比较好理解.<br>6）图解普利姆算法<br><img src="019.PNG" alt>  </p><h2 id="6-4-普里姆算法最佳实践（修路问题）"><a href="#6-4-普里姆算法最佳实践（修路问题）" class="headerlink" title="6.4 普里姆算法最佳实践（修路问题）"></a>6.4 普里姆算法最佳实践（修路问题）</h2><p><img src="020.PNG" alt><br>1）有胜利乡有7个村庄（A，B，C，D，E，F，G），现在需要修路把7个村庄连通<br>2）各个村庄的距离用边线表示（权），比如A-B距离5公里<br>3）问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短？<br>4）看思路分析+代码演示：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.prim;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试看看图是否创建ok</span></span><br><span class="line"><span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> verxs = data.length;</span><br><span class="line"><span class="comment">//邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通</span></span><br><span class="line"><span class="keyword">int</span> [][]weight=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">10000</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10000</span>,<span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10000</span>&#125;,&#125;;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//创建MGraph对象</span></span><br><span class="line">        MGraph graph = <span class="keyword">new</span> MGraph(verxs);</span><br><span class="line">        <span class="comment">//创建一个MinTree对象</span></span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        minTree.createGraph(graph, verxs, data, weight);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line">        <span class="comment">//测试普利姆算法</span></span><br><span class="line">        minTree.prim(graph, <span class="number">1</span>);<span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建最小生成树-&gt;村庄的图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinTree</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建图的邻接矩阵</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> graph 图对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> verxs 图对应的顶点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 图的各个顶点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> weight 图的邻接矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(MGraph graph, <span class="keyword">int</span> verxs, <span class="keyword">char</span> data[], <span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; verxs; i++) &#123;<span class="comment">//顶点</span></span><br><span class="line">graph.data[i] = data[i];</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; verxs; j++) &#123;</span><br><span class="line">graph.weight[i][j] = weight[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示图的邻接矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(MGraph graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] link: graph.weight) &#123;</span><br><span class="line">System.out.println(Arrays.toString(link));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写prim算法，得到最小生成树</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v 表示从图的第几个顶点开始生成'A'-&gt;0 'B'-&gt;1...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(MGraph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//visited[] 标记结点(顶点)是否被访问过</span></span><br><span class="line"><span class="keyword">int</span> visited[] = <span class="keyword">new</span> <span class="keyword">int</span>[graph.verxs];</span><br><span class="line"><span class="comment">//visited[] 默认元素的值都是0, 表示没有访问过</span></span><br><span class="line"><span class="comment">//for(int i =0; i &lt;graph.verxs; i++) &#123;</span></span><br><span class="line"><span class="comment">//visited[i] = 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把当前这个结点标记为已访问</span></span><br><span class="line">visited[v] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//h1 和 h2 记录两个顶点的下标</span></span><br><span class="line"><span class="keyword">int</span> h1 = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> h2 = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> minWeight = <span class="number">10000</span>; <span class="comment">//将 minWeight 初始成一个大数，后面在遍历过程中，会被替换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; graph.verxs; k++) &#123;<span class="comment">//因为有 graph.verxs顶点，普利姆算法结束后，有 graph.verxs-1边</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是确定每一次生成的子图 ，和哪个结点的距离最近</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.verxs; i++) &#123;<span class="comment">// i结点表示被访问过的结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; graph.verxs;j++) &#123;<span class="comment">//j结点表示还没有访问过的结点</span></span><br><span class="line"><span class="keyword">if</span>(visited[i] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span> &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123;</span><br><span class="line"><span class="comment">//替换minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边)</span></span><br><span class="line">minWeight = graph.weight[i][j];</span><br><span class="line">h1 = i;</span><br><span class="line">h2 = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到一条边是最小</span></span><br><span class="line">System.out.println(<span class="string">"边&lt;"</span> + graph.data[h1] + <span class="string">","</span> + graph.data[h2] + <span class="string">"&gt; 权值:"</span> + minWeight);</span><br><span class="line"><span class="comment">//将当前这个结点标记为已经访问</span></span><br><span class="line">visited[h2] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//minWeight 重新设置为最大值 10000</span></span><br><span class="line">minWeight = <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> verxs; <span class="comment">//表示图的节点个数</span></span><br><span class="line"><span class="keyword">char</span>[] data;<span class="comment">//存放结点数据</span></span><br><span class="line"><span class="keyword">int</span>[][] weight; <span class="comment">//存放边，就是我们的邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MGraph</span><span class="params">(<span class="keyword">int</span> verxs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.verxs = verxs;</span><br><span class="line">data = <span class="keyword">new</span> <span class="keyword">char</span>[verxs];</span><br><span class="line">weight = <span class="keyword">new</span> <span class="keyword">int</span>[verxs][verxs];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-克鲁斯卡尔算法"><a href="#7-克鲁斯卡尔算法" class="headerlink" title="7.克鲁斯卡尔算法"></a>7.克鲁斯卡尔算法</h2><h3 id="7-1-应用场景-公交站问题"><a href="#7-1-应用场景-公交站问题" class="headerlink" title="7.1 应用场景-公交站问题"></a>7.1 应用场景-公交站问题</h3><p>看一个应用场景和问题：<br><img src="021.PNG" alt><br>1）某城市新增7个站点（A，B，C，D，E，F，G），现在需要修路把7个站点连通<br>2）各个站点的距离用边线表示（权），比如A-B距离12公里<br>3）问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短？  </p><h3 id="7-2-克鲁斯卡尔算法介绍"><a href="#7-2-克鲁斯卡尔算法介绍" class="headerlink" title="7.2 克鲁斯卡尔算法介绍"></a>7.2 克鲁斯卡尔算法介绍</h3><p>1）克鲁斯卡尔（Kruskal）算法，是用来求加权连通图的最小生成树的算法。<br>2）基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路<br>3）具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止  </p><h3 id="7-3-克鲁斯卡尔算法图解说明"><a href="#7-3-克鲁斯卡尔算法图解说明" class="headerlink" title="7.3 克鲁斯卡尔算法图解说明"></a>7.3 克鲁斯卡尔算法图解说明</h3><p>以城市公交站问题来图解说明克鲁斯卡尔算法的原理和步骤：<br><img src="022.PNG" alt><br><img src="023.PNG" alt><br><img src="024.PNG" alt><br><img src="025.PNG" alt><br><img src="026.PNG" alt><br><img src="027.PNG" alt><br><img src="028.PNG" alt><br><img src="029.PNG" alt>  </p><h3 id="7-4-克鲁斯卡尔最佳实践-公交站问题"><a href="#7-4-克鲁斯卡尔最佳实践-公交站问题" class="headerlink" title="7.4 克鲁斯卡尔最佳实践-公交站问题"></a>7.4 克鲁斯卡尔最佳实践-公交站问题</h3><p>看一个公交站问题：<br>1）有北京有新增7个站点（A，B，C，D，E，，F，G），现在需要修路把7个站点连通<br>2）各个站点的距离用边线表示（权），比如A-B距离12公里<br>3）问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短？<br>4）代码实现和注解  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.kruskal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> edgeNum; <span class="comment">//边的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] vertexs; <span class="comment">//顶点数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix; <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="comment">//使用 INF 表示两个顶点不能连通</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] vertexs = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line"><span class="comment">//克鲁斯卡尔算法的邻接矩阵  </span></span><br><span class="line">      <span class="keyword">int</span> matrix[][] = &#123;</span><br><span class="line">      <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line"><span class="comment">/*A*/</span> &#123;   <span class="number">0</span>,  <span class="number">12</span>, INF, INF, INF,  <span class="number">16</span>,  <span class="number">14</span>&#125;,</span><br><span class="line"><span class="comment">/*B*/</span> &#123;  <span class="number">12</span>,   <span class="number">0</span>,  <span class="number">10</span>, INF, INF,   <span class="number">7</span>, INF&#125;,</span><br><span class="line"><span class="comment">/*C*/</span> &#123; INF,  <span class="number">10</span>,   <span class="number">0</span>,   <span class="number">3</span>,   <span class="number">5</span>,   <span class="number">6</span>, INF&#125;,</span><br><span class="line"><span class="comment">/*D*/</span> &#123; INF, INF,   <span class="number">3</span>,   <span class="number">0</span>,   <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line"><span class="comment">/*E*/</span> &#123; INF, INF,   <span class="number">5</span>,   <span class="number">4</span>,   <span class="number">0</span>,   <span class="number">2</span>,   <span class="number">8</span>&#125;,</span><br><span class="line"><span class="comment">/*F*/</span> &#123;  <span class="number">16</span>,   <span class="number">7</span>,   <span class="number">6</span>, INF,   <span class="number">2</span>,   <span class="number">0</span>,   <span class="number">9</span>&#125;,</span><br><span class="line"><span class="comment">/*G*/</span> &#123;  <span class="number">14</span>, INF, INF, INF,   <span class="number">8</span>,   <span class="number">9</span>,   <span class="number">0</span>&#125;&#125;; </span><br><span class="line">      <span class="comment">//大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//创建KruskalCase 对象实例</span></span><br><span class="line">      KruskalCase kruskalCase = <span class="keyword">new</span> KruskalCase(vertexs, matrix);</span><br><span class="line">      <span class="comment">//输出构建的</span></span><br><span class="line">      kruskalCase.print();</span><br><span class="line">      kruskalCase.kruskal();</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KruskalCase</span><span class="params">(<span class="keyword">char</span>[] vertexs, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化顶点数和边的个数</span></span><br><span class="line"><span class="keyword">int</span> vlen = vertexs.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顶点, 复制拷贝的方式</span></span><br><span class="line"><span class="keyword">this</span>.vertexs = <span class="keyword">new</span> <span class="keyword">char</span>[vlen];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>.vertexs[i] = vertexs[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化边, 使用的是复制拷贝的方式</span></span><br><span class="line"><span class="keyword">this</span>.matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vlen][vlen];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j &lt; vlen; j++) &#123;</span><br><span class="line"><span class="keyword">this</span>.matrix[i][j] = matrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计边的条数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; vlen; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.matrix[i][j] != INF) &#123;</span><br><span class="line">edgeNum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">//表示最后结果数组的索引</span></span><br><span class="line"><span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[edgeNum]; <span class="comment">//用于保存"已有最小生成树" 中的每个顶点在最小生成树中的终点</span></span><br><span class="line"><span class="comment">//创建结果数组, 保存最后的最小生成树</span></span><br><span class="line">EData[] rets = <span class="keyword">new</span> EData[edgeNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取图中 所有的边的集合 ， 一共有12边</span></span><br><span class="line">EData[] edges = getEdges();</span><br><span class="line">System.out.println(<span class="string">"图的边的集合="</span> + Arrays.toString(edges) + <span class="string">" 共"</span>+ edges.length); <span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按照边的权值大小进行排序(从小到大)</span></span><br><span class="line">sortEdges(edges);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class="line"><span class="comment">//获取到第i条边的第一个顶点(起点)</span></span><br><span class="line"><span class="keyword">int</span> p1 = getPosition(edges[i].start); <span class="comment">//p1=4</span></span><br><span class="line"><span class="comment">//获取到第i条边的第2个顶点</span></span><br><span class="line"><span class="keyword">int</span> p2 = getPosition(edges[i].end); <span class="comment">//p2 = 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取p1这个顶点在已有最小生成树中的终点</span></span><br><span class="line"><span class="keyword">int</span> m = getEnd(ends, p1); <span class="comment">//m = 4</span></span><br><span class="line"><span class="comment">//获取p2这个顶点在已有最小生成树中的终点</span></span><br><span class="line"><span class="keyword">int</span> n = getEnd(ends, p2); <span class="comment">// n = 5</span></span><br><span class="line"><span class="comment">//是否构成回路</span></span><br><span class="line"><span class="keyword">if</span>(m != n) &#123; <span class="comment">//没有构成回路</span></span><br><span class="line">ends[m] = n; <span class="comment">// 设置m 在"已有最小生成树"中的终点 &lt;E,F&gt; [0,0,0,0,5,0,0,0,0,0,0,0]</span></span><br><span class="line">rets[index++] = edges[i]; <span class="comment">//有一条边加入到rets数组</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。</span></span><br><span class="line"><span class="comment">//统计并打印 "最小生成树", 输出  rets</span></span><br><span class="line">System.out.println(<span class="string">"最小生成树为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">System.out.println(rets[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印邻接矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"邻接矩阵为: \n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%12d"</span>, matrix[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();<span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：对边进行排序处理, 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> edges 边的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortEdges</span><span class="params">(EData[] edges)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(edges[j].weight &gt; edges[j+<span class="number">1</span>].weight) &#123;<span class="comment">//交换</span></span><br><span class="line">EData tmp = edges[j];</span><br><span class="line">edges[j] = edges[j+<span class="number">1</span>];</span><br><span class="line">edges[j+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ch 顶点的值，比如'A','B'</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回ch顶点对应的下标，如果找不到，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vertexs[i] == ch) &#123;<span class="comment">//找到</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找不到,返回-1</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组</span></span><br><span class="line"><span class="comment"> * 是通过matrix 邻接矩阵来获取</span></span><br><span class="line"><span class="comment"> * EData[] 形式 [['A','B', 12], ['B','F',7], .....]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> EData[] getEdges() &#123;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">EData[] edges = <span class="keyword">new</span> EData[edgeNum];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt;vertexs.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(matrix[i][j] != INF) &#123;</span><br><span class="line">edges[index++] = <span class="keyword">new</span> EData(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> edges;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i : 表示传入的顶点对应的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span>[] ends, <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]</span></span><br><span class="line"><span class="keyword">while</span>(ends[i] != <span class="number">0</span>) &#123;</span><br><span class="line">i = ends[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个类EData ，它的对象实例就表示一条边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EData</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> start; <span class="comment">//边的一个点</span></span><br><span class="line"><span class="keyword">char</span> end; <span class="comment">//边的另外一个点</span></span><br><span class="line"><span class="keyword">int</span> weight; <span class="comment">//边的权值</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EData</span><span class="params">(<span class="keyword">char</span> start, <span class="keyword">char</span> end, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line"><span class="keyword">this</span>.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写toString, 便于输出边信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"EData [&lt;"</span> + start + <span class="string">", "</span> + end + <span class="string">"&gt;= "</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-迪杰斯特拉算法"><a href="#8-迪杰斯特拉算法" class="headerlink" title="8.迪杰斯特拉算法"></a>8.迪杰斯特拉算法</h2><h3 id="8-1-应用场景-最短路径问题"><a href="#8-1-应用场景-最短路径问题" class="headerlink" title="8.1 应用场景-最短路径问题"></a>8.1 应用场景-最短路径问题</h3><p>看一个应用场景和问题：<br><img src="030.PNG" alt><br>1）战争时期，胜利乡有7个村庄（A，B，C，D，E，F，G），现在有六个邮差，从G点出发，需要分别把邮件分别送到A，B，C，D，E，F六个村庄<br>2）各个村庄的距离用边线表示（权），比如A-B距离5公里<br>3）问：如何计算出G村庄到其它各个村庄的最短距离？<br>4）如果从其它点出发到各个点的最短距离又是多少？  </p><h3 id="8-2-迪杰斯特拉（Dijkstra）算法介绍"><a href="#8-2-迪杰斯特拉（Dijkstra）算法介绍" class="headerlink" title="8.2 迪杰斯特拉（Dijkstra）算法介绍"></a>8.2 迪杰斯特拉（Dijkstra）算法介绍</h3><p>迪杰斯特拉（Dijkstra）算法是<strong>典型最短路径算法</strong>，用于计算一个结点到其他结点的最短路径。它的主要特点是以起始点为中心向外层层扩展（<strong>广度优先搜索思想</strong>），直到扩展到终点为止。</p><h3 id="8-3-迪杰斯特拉（Dijkstra）算法过程"><a href="#8-3-迪杰斯特拉（Dijkstra）算法过程" class="headerlink" title="8.3 迪杰斯特拉（Dijkstra）算法过程"></a>8.3 迪杰斯特拉（Dijkstra）算法过程</h3><p>1）设置出发顶点为v，顶点集合V{v1，v2，vi…}，v到V中各顶点的距离构成距离集合Dis，Dis{d1，d2，di.…}，Dis集合记录着v到图中各顶点的距离（到自身可以看作0，v到vi距离对应为di）<br>2）从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径<br>3）更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个（同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的）<br>4）重复执行两步骤，直到最短路径顶点为目标顶点即可结束  </p><h3 id="8-4-迪杰斯特拉（Dijkstra）算法最佳应用-最短路径"><a href="#8-4-迪杰斯特拉（Dijkstra）算法最佳应用-最短路径" class="headerlink" title="8.4 迪杰斯特拉（Dijkstra）算法最佳应用-最短路径"></a>8.4 迪杰斯特拉（Dijkstra）算法最佳应用-最短路径</h3><p><img src="031.PNG" alt><br>1）战争时期，胜利乡有7个村庄（A，B，C，D，E，F，G），现在有六个邮差，从G点出发，需要分别把邮件分别送到A，B，C，D，E，F六个村庄<br>2）各个村庄的距离用边线表示（权），比如A-B距离5公里<br>3）问：如何计算出G村庄到其它各个村庄的最短距离？<br>4）如果从其它点出发到各个点的最短距离又是多少？<br>5）使用图解的方式分析了迪杰斯特拉（Dijkstra）算法思路<br><img src="032.PNG" alt><br>6）代码实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.dijkstra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] vertex = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span> &#125;;</span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;<span class="comment">// 表示不可以连接</span></span><br><span class="line">matrix[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">5</span>,<span class="number">7</span>,N,N,N,<span class="number">2</span>&#125;;  </span><br><span class="line">        matrix[<span class="number">1</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,N,N,<span class="number">9</span>,N,N,<span class="number">3</span>&#125;;  </span><br><span class="line">        matrix[<span class="number">2</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,N,N,N,<span class="number">8</span>,N,N&#125;;  </span><br><span class="line">        matrix[<span class="number">3</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">9</span>,N,N,N,<span class="number">4</span>,N&#125;;  </span><br><span class="line">        matrix[<span class="number">4</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,<span class="number">8</span>,N,N,<span class="number">5</span>,<span class="number">4</span>&#125;;  </span><br><span class="line">        matrix[<span class="number">5</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,N,<span class="number">4</span>,<span class="number">5</span>,N,<span class="number">6</span>&#125;;  </span><br><span class="line">        matrix[<span class="number">6</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,N,N,<span class="number">4</span>,<span class="number">6</span>,N&#125;;</span><br><span class="line">        <span class="comment">//创建 Graph对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex, matrix);</span><br><span class="line">        <span class="comment">//测试, 看看图的邻接矩阵是否ok</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">        <span class="comment">//测试迪杰斯特拉算法</span></span><br><span class="line">        graph.dsj(<span class="number">2</span>);<span class="comment">//C</span></span><br><span class="line">        graph.showDijkstra();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] vertex; <span class="comment">// 顶点数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="keyword">private</span> VisitedVertex vv; <span class="comment">//已经访问的顶点的集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.vertex = vertex;</span><br><span class="line"><span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vv.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示图</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] link : matrix) &#123;</span><br><span class="line">System.out.println(Arrays.toString(link));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迪杰斯特拉算法实现</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 表示出发顶点对应的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dsj</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">vv = <span class="keyword">new</span> VisitedVertex(vertex.length, index);</span><br><span class="line">update(index);<span class="comment">//更新index顶点到周围顶点的距离和前驱顶点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;vertex.length; j++) &#123;</span><br><span class="line">index = vv.updateArr();<span class="comment">// 选择并返回新的访问顶点</span></span><br><span class="line">update(index); <span class="comment">// 更新index顶点到周围顶点的距离和前驱顶点</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点,</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//根据遍历我们的邻接矩阵的  matrix[index]行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[index].length; j++) &#123;</span><br><span class="line"><span class="comment">// len 含义是 : 出发顶点到index顶点的距离 + 从index顶点到j顶点的距离的和 </span></span><br><span class="line">len = vv.getDis(index) + matrix[index][j];</span><br><span class="line"><span class="comment">// 如果j顶点没有被访问过，并且 len 小于出发顶点到j顶点的距离，就需要更新</span></span><br><span class="line"><span class="keyword">if</span>(!vv.in(j) &amp;&amp; len &lt; vv.getDis(j)) &#123;</span><br><span class="line">vv.updatePre(j, index); <span class="comment">//更新j顶点的前驱为index顶点</span></span><br><span class="line">vv.updateDis(j, len); <span class="comment">//更新出发顶点到j顶点的距离</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已访问顶点集合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisitedVertex</span> </span>&#123;</span><br><span class="line"><span class="comment">// 记录各个顶点是否访问过 1表示访问过,0未访问,会动态更新</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] already_arr;</span><br><span class="line"><span class="comment">// 每个下标对应的值为前一个顶点下标, 会动态更新</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] pre_visited;</span><br><span class="line"><span class="comment">// 记录出发顶点到其他所有顶点的距离,比如G为出发顶点，就会记录G到其它顶点的距离，会动态更新，求的最短距离就会存放到dis</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dis;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length :表示顶点的个数 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index: 出发顶点对应的下标, 比如G顶点，下标就是6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VisitedVertex</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.already_arr = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"><span class="keyword">this</span>.pre_visited = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"><span class="keyword">this</span>.dis = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"><span class="comment">//初始化 dis数组</span></span><br><span class="line">Arrays.fill(dis, <span class="number">65535</span>);</span><br><span class="line"><span class="keyword">this</span>.already_arr[index] = <span class="number">1</span>; <span class="comment">//设置出发顶点被访问过</span></span><br><span class="line"><span class="keyword">this</span>.dis[index] = <span class="number">0</span>;<span class="comment">//设置出发顶点的访问距离为0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能: 判断index顶点是否被访问过</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果访问过，就返回true, 否则访问false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> already_arr[index] == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能: 更新出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDis</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">dis[index] = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能: 更新pre这个顶点的前驱顶点为index顶点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pre</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePre</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">pre_visited[pre] = index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能:返回出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dis[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继续选择并返回新的访问顶点， 比如这里的G 完后，就是 A点作为新的访问顶点(注意不是出发顶点)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> min = <span class="number">65535</span>, index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; already_arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(already_arr[i] == <span class="number">0</span> &amp;&amp; dis[i] &lt; min ) &#123;</span><br><span class="line">min = dis[i];</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新 index 顶点被访问过</span></span><br><span class="line">already_arr[index] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示最后的结果</span></span><br><span class="line"><span class="comment">//即将三个数组的情况输出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"=========================="</span>);</span><br><span class="line"><span class="comment">//输出already_arr</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : already_arr) &#123;</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//输出pre_visited</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : pre_visited) &#123;</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//输出dis</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : dis) &#123;</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//为了好看最后的最短距离，我们处理</span></span><br><span class="line"><span class="keyword">char</span>[] vertex = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : dis) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">65535</span>) &#123;</span><br><span class="line">System.out.print(vertex[count] + <span class="string">"("</span>+i+<span class="string">") "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"N "</span>);</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-弗洛伊德算法"><a href="#9-弗洛伊德算法" class="headerlink" title="9.弗洛伊德算法"></a>9.弗洛伊德算法</h2><h3 id="9-1-弗洛伊德（Floyd）算法介绍"><a href="#9-1-弗洛伊德（Floyd）算法介绍" class="headerlink" title="9.1 弗洛伊德（Floyd）算法介绍"></a>9.1 弗洛伊德（Floyd）算法介绍</h3><p>1）和Dijkstra 算法一样，弗洛伊德（Floyd）算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名<br>2）弗洛伊德算法（Floyd）计算图中各个顶点之间的最短路径<br>3）迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。<br>4）弗洛伊德算法VS迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。  </p><h3 id="9-2-弗洛伊德（Floyd）算法图解分析"><a href="#9-2-弗洛伊德（Floyd）算法图解分析" class="headerlink" title="9.2 弗洛伊德（Floyd）算法图解分析"></a>9.2 弗洛伊德（Floyd）算法图解分析</h3><p>1）设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min（(Lik+Lkj），Lij），vk的取值为图中所有顶点，则可获得vi到vj的最短路径<br>2）至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得<br>3）弗洛伊德（Floyd）算法图解分析-举例说明<br><img src="033.PNG" alt><br><img src="034.PNG" alt><br><img src="035.PNG" alt><br><img src="036.PNG" alt>  </p><h3 id="9-3-弗洛伊德（Floyd）算法最佳应用-最短路径"><a href="#9-3-弗洛伊德（Floyd）算法最佳应用-最短路径" class="headerlink" title="9.3 弗洛伊德（Floyd）算法最佳应用-最短路径"></a>9.3 弗洛伊德（Floyd）算法最佳应用-最短路径</h3><p><img src="037.PNG" alt><br>1）胜利乡有7个村庄（A，B，C，D，E，F，G）<br>2）各个村庄的距离用边线表示（权），比如A-B距离5公里<br>3）问：如何计算出各村庄到其它各村庄的最短距离？<br>4）代码实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.floyd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试看看图是否创建成功</span></span><br><span class="line"><span class="keyword">char</span>[] vertex = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span> &#125;;</span><br><span class="line"><span class="comment">//创建邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span> &#125;;</span><br><span class="line">matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span> &#125;;</span><br><span class="line">matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N &#125;;</span><br><span class="line">matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N &#125;;</span><br><span class="line">matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span> &#125;;</span><br><span class="line">matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 Graph 对象</span></span><br><span class="line">Graph graph = <span class="keyword">new</span> Graph(vertex.length, matrix, vertex);</span><br><span class="line"><span class="comment">//调用弗洛伊德算法</span></span><br><span class="line">graph.floyd();</span><br><span class="line">graph.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] vertex; <span class="comment">// 存放顶点的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dis; <span class="comment">// 保存，从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] pre;<span class="comment">// 保存到达目标顶点的前驱顶点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment"> *            大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment"> *            邻接矩阵</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vertex</span></span><br><span class="line"><span class="comment"> *            顶点数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span>[][] matrix, <span class="keyword">char</span>[] vertex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.vertex = vertex;</span><br><span class="line"><span class="keyword">this</span>.dis = matrix;</span><br><span class="line"><span class="keyword">this</span>.pre = <span class="keyword">new</span> <span class="keyword">int</span>[length][length];</span><br><span class="line"><span class="comment">// 对pre数组初始化, 注意存放的是前驱顶点的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">Arrays.fill(pre[i], i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示pre数组和dis数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了显示便于阅读，我们优化一下输出</span></span><br><span class="line"><span class="keyword">char</span>[] vertex = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dis.length; k++) &#123;</span><br><span class="line"><span class="comment">// 先将pre数组输出的一行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">System.out.print(vertex[pre[k][i]] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// 输出dis数组的一行数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">System.out.print(<span class="string">"("</span>+vertex[k]+<span class="string">"到"</span>+vertex[i]+<span class="string">"的最短路径是"</span> + dis[k][i] + <span class="string">") "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弗洛伊德算法, 比较容易理解，而且容易实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//变量保存距离</span></span><br><span class="line"><span class="comment">//对中间顶点遍历， k 就是中间顶点的下标 [A, B, C, D, E, F, G] </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dis.length; k++) &#123; <span class="comment">// </span></span><br><span class="line"><span class="comment">//从i顶点开始出发 [A, B, C, D, E, F, G]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line"><span class="comment">//到达j顶点 // [A, B, C, D, E, F, G]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dis.length; j++) &#123;</span><br><span class="line">len = dis[i][k] + dis[k][j];<span class="comment">// =&gt; 求出从i 顶点出发，经过 k中间顶点，到达 j 顶点距离</span></span><br><span class="line"><span class="keyword">if</span>(len &lt; dis[i][j]) &#123;<span class="comment">//如果len小于 dis[i][j]</span></span><br><span class="line">dis[i][j] = len;<span class="comment">//更新距离</span></span><br><span class="line">pre[i][j] = pre[k][j];<span class="comment">//更新前驱顶点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-马踏棋盘算法"><a href="#10-马踏棋盘算法" class="headerlink" title="10.马踏棋盘算法"></a>10.马踏棋盘算法</h2><h3 id="10-1-马踏棋盘算法介绍和游戏演示"><a href="#10-1-马踏棋盘算法介绍和游戏演示" class="headerlink" title="10.1 马踏棋盘算法介绍和游戏演示"></a>10.1 马踏棋盘算法介绍和游戏演示</h3><p>1）马踏棋盘算法也被称为骑士周游问题<br>2）将马随机放在国际象棋的8×8棋盘Board[0<del>7][0</del>7]的某个方格中，马按走棋规则（马走日字）进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格<br>3）<a href="http://www.4399.com/flash/146267_2.htm" rel="external nofollow noopener noreferrer" target="_blank">游戏演示</a><br><img src="038.PNG" alt>  </p><h3 id="10-2-马踏棋盘游戏代码实现"><a href="#10-2-马踏棋盘游戏代码实现" class="headerlink" title="10.2 马踏棋盘游戏代码实现"></a>10.2 马踏棋盘游戏代码实现</h3><p>1）马踏棋盘问题（骑士周游问题）实际上是图的深度优先搜索（DFS）的应用。<br>2）如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了53个点，如图：走到了第53个，坐标（1，0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯……，<strong>思路分析</strong>+代码实现  </p><h4 id="10-2-1-对第一种实现方式的思路图解"><a href="#10-2-1-对第一种实现方式的思路图解" class="headerlink" title="10.2.1 对第一种实现方式的思路图解"></a>10.2.1 对第一种实现方式的思路图解</h4><p><img src="039.PNG" alt><br>3）分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题.<br><img src="040.PNG" alt><br>4）使用前面的游戏来验证算法是否正确。<br>5）代码实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.horse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Point;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseChessboard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> X; <span class="comment">// 棋盘的列数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> Y; <span class="comment">// 棋盘的行数</span></span><br><span class="line"><span class="comment">//创建一个数组，标记棋盘的各个位置是否被访问过</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> visited[];</span><br><span class="line"><span class="comment">//使用一个属性，标记是否棋盘的所有位置都被访问</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> finished; <span class="comment">// 如果为true,表示成功</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"骑士周游算法，开始运行~~"</span>);</span><br><span class="line"><span class="comment">//测试骑士周游算法是否正确</span></span><br><span class="line">X = <span class="number">8</span>;</span><br><span class="line">Y = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> row = <span class="number">1</span>; <span class="comment">//马儿初始位置的行，从1开始编号</span></span><br><span class="line"><span class="keyword">int</span> column = <span class="number">1</span>; <span class="comment">//马儿初始位置的列，从1开始编号</span></span><br><span class="line"><span class="comment">//创建棋盘</span></span><br><span class="line"><span class="keyword">int</span>[][] chessboard = <span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[X * Y];<span class="comment">//初始值都是false</span></span><br><span class="line"><span class="comment">//测试一下耗时</span></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">traversalChessboard(chessboard, row - <span class="number">1</span>, column - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"共耗时: "</span> + (end - start) + <span class="string">" 毫秒"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出棋盘的最后情况</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] rows : chessboard) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> step: rows) &#123;</span><br><span class="line">System.out.print(step + <span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成骑士周游问题的算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chessboard 棋盘</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> row 马儿当前的位置的行 从0开始 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> column 马儿当前的位置的列  从0开始</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> step 是第几步 ,初始位置就是第1步 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traversalChessboard</span><span class="params">(<span class="keyword">int</span>[][] chessboard, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">chessboard[row][column] = step;</span><br><span class="line"><span class="comment">//row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36</span></span><br><span class="line">visited[row * X + column] = <span class="keyword">true</span>; <span class="comment">//标记该位置已经访问</span></span><br><span class="line"><span class="comment">//获取当前位置可以走的下一个位置的集合 </span></span><br><span class="line">ArrayList&lt;Point&gt; ps = next(<span class="keyword">new</span> Point(column, row));</span><br><span class="line"><span class="comment">//对ps进行排序,排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序</span></span><br><span class="line">sort(ps);</span><br><span class="line"><span class="comment">//遍历 ps</span></span><br><span class="line"><span class="keyword">while</span>(!ps.isEmpty()) &#123;</span><br><span class="line">Point p = ps.remove(<span class="number">0</span>);<span class="comment">//取出下一个可以走的位置</span></span><br><span class="line"><span class="comment">//判断该点是否已经访问过</span></span><br><span class="line"><span class="keyword">if</span>(!visited[p.y * X + p.x]) &#123;<span class="comment">//说明还没有访问过</span></span><br><span class="line">traversalChessboard(chessboard, p.y, p.x, step + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断马儿是否完成了任务，使用   step 和应该走的步数比较 ， </span></span><br><span class="line"><span class="comment">//如果没有达到数量，则表示没有完成任务，将整个棋盘置0</span></span><br><span class="line"><span class="comment">//说明: step &lt; X * Y  成立的情况有两种</span></span><br><span class="line"><span class="comment">//1. 棋盘到目前位置,仍然没有走完</span></span><br><span class="line"><span class="comment">//2. 棋盘处于一个回溯过程</span></span><br><span class="line"><span class="keyword">if</span>(step &lt; X * Y &amp;&amp; !finished ) &#123;</span><br><span class="line">chessboard[row][column] = <span class="number">0</span>;</span><br><span class="line">visited[row * X + column] = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">finished = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能： 根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)，并放入到一个集合中(ArrayList), 最多有8个位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> curPoint</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title">next</span><span class="params">(Point curPoint)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个ArrayList</span></span><br><span class="line">ArrayList&lt;Point&gt; ps = <span class="keyword">new</span> ArrayList&lt;Point&gt;();</span><br><span class="line"><span class="comment">//创建一个Point</span></span><br><span class="line">Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line"><span class="comment">//表示马儿可以走5这个位置</span></span><br><span class="line"><span class="keyword">if</span>((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y -<span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断马儿可以走6这个位置</span></span><br><span class="line"><span class="keyword">if</span>((p1.x = curPoint.x - <span class="number">1</span>) &gt;=<span class="number">0</span> &amp;&amp; (p1.y=curPoint.y-<span class="number">2</span>)&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断马儿可以走7这个位置</span></span><br><span class="line"><span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断马儿可以走0这个位置</span></span><br><span class="line"><span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断马儿可以走1这个位置</span></span><br><span class="line"><span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断马儿可以走2这个位置</span></span><br><span class="line"><span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断马儿可以走3这个位置</span></span><br><span class="line"><span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断马儿可以走4这个位置</span></span><br><span class="line"><span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(ArrayList&lt;Point&gt; ps)</span> </span>&#123;</span><br><span class="line">ps.sort(<span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//获取到o1的下一步的所有位置个数</span></span><br><span class="line"><span class="keyword">int</span> count1 = next(o1).size();</span><br><span class="line"><span class="comment">//获取到o2的下一步的所有位置个数</span></span><br><span class="line"><span class="keyword">int</span> count2 = next(o2).size();</span><br><span class="line"><span class="keyword">if</span>(count1 &lt; count2) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count1 == count2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-二分查找算法（非递归）&quot;&gt;&lt;a href=&quot;#1-二分查找算法（非递归）&quot; class=&quot;headerlink&quot; title=&quot;1.二分查找算法（非递归）&quot;&gt;&lt;/a&gt;1.二分查找算法（非递归）&lt;/h2&gt;&lt;h3 id=&quot;1-1-二分查找算法（非递归）介绍&quot;&gt;&lt;a href=&quot;#1-1-二分查找算法（非递归）介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 二分查找算法（非递归）介绍&quot;&gt;&lt;/a&gt;1.1 二分查找算法（非递归）介绍&lt;/h3&gt;&lt;p&gt;1）前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="程序员常用10种算法" scheme="https://RuanGuoHui.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%94%A810%E7%A7%8D%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之图</title>
    <link href="https://RuanGuoHui.github.io/2019/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%BE/"/>
    <id>https://RuanGuoHui.github.io/2019/07/27/数据结构与算法之图/</id>
    <published>2019-07-27T05:17:29.000Z</published>
    <updated>2019-07-27T05:57:26.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-图基本介绍"><a href="#1-图基本介绍" class="headerlink" title="1.图基本介绍"></a>1.图基本介绍</h2><h3 id="1-1-为什么要有图"><a href="#1-1-为什么要有图" class="headerlink" title="1.1 为什么要有图"></a>1.1 为什么要有图</h3><p>1）前面我们学了线性表和树<br>2）线性表局限于一个直接前驱和一个直接后继的关系  <a id="more"></a><br>3）树也只能有一个直接前驱也就是父节点<br>4）当我们需要<strong>表示多对多</strong>的关系时，这里我们就用到了<strong>图</strong>。</p><h3 id="1-2-图的举例说明"><a href="#1-2-图的举例说明" class="headerlink" title="1.2 图的举例说明"></a>1.2 图的举例说明</h3><p>图是一种<strong>数据结构</strong>，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。如图：<br><img src="001.PNG" alt>  </p><h3 id="1-3-图的常用概念"><a href="#1-3-图的常用概念" class="headerlink" title="1.3 图的常用概念"></a>1.3 图的常用概念</h3><p>1）顶点（vertex）<br>2）边（edge）<br>3）路径<br>4）无向图（右图<br><img src="002.PNG" alt><br>5）有向图<br>6）带权图<br><img src="003.PNG" alt>  </p><h2 id="2-图的表示方式"><a href="#2-图的表示方式" class="headerlink" title="2.图的表示方式"></a>2.图的表示方式</h2><p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。  </p><h3 id="2-1-邻接矩阵"><a href="#2-1-邻接矩阵" class="headerlink" title="2.1 邻接矩阵"></a>2.1 邻接矩阵</h3><p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于<strong>n</strong>个顶点的图而言，矩阵是的<strong>row</strong>和<strong>col</strong>表示的是<strong>1…n</strong>个点。<br><img src="004.PNG" alt>  </p><h3 id="2-2-邻接表"><a href="#2-2-邻接表" class="headerlink" title="2.2 邻接表"></a>2.2 邻接表</h3><p>1）邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在，会造成空间的一定损失.<br>2）邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成<br>3）举例说明<br><img src="005.PNG" alt>  </p><h2 id="3-图的快速入门案例"><a href="#3-图的快速入门案例" class="headerlink" title="3.图的快速入门案例"></a>3.图的快速入门案例</h2><p>1）要求：代码实现如下图结构.<br><img src="006.PNG" alt><br>2）思路分析（1）存储顶点String使用ArrayList（2）保存矩阵int[][]edges<br>3）代码实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">vertexList.add(vertex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加边</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v1 表示点的下标即使第几个顶点  "A"-"B" "A"-&gt;0 "B"-&gt;1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v2 第二个顶点对应的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> weight 表示 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">edges[v2][v1] = weight;</span><br><span class="line">numOfEdges++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-图的深度优先遍历介绍"><a href="#4-图的深度优先遍历介绍" class="headerlink" title="4.图的深度优先遍历介绍"></a>4.图的深度优先遍历介绍</h2><h3 id="4-1-图遍历介绍"><a href="#4-1-图遍历介绍" class="headerlink" title="4.1 图遍历介绍"></a>4.1 图遍历介绍</h3><p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略：（1）深度优先遍历（2）广度优先遍历</p><h3 id="4-2深度优先遍历基本思想"><a href="#4-2深度优先遍历基本思想" class="headerlink" title="4.2深度优先遍历基本思想"></a>4.2深度优先遍历基本思想</h3><p>图的深度优先搜索（<strong>Depth First Search</strong>）。<br>1）深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解：<br>每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。<br>2）我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。<br>3）显然，深度优先搜索是一个递归的过程  </p><h3 id="4-3-深度优先遍历算法步骤"><a href="#4-3-深度优先遍历算法步骤" class="headerlink" title="4.3 深度优先遍历算法步骤"></a>4.3 深度优先遍历算法步骤</h3><p>1）访问初始结点v，并标记结点v为已访问。<br>2）查找结点v的第一个邻接结点w。<br>3）若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。<br>4）若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。<br>5）查找结点v的w邻接结点的下一个邻接结点，转到步骤3。<br>6）分析图  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历算法</span></span><br><span class="line"><span class="comment">//i 第一次就是 0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//首先我们访问该结点,输出</span></span><br><span class="line">System.out.print(getValueByIndex(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line"><span class="comment">//将结点设置为已经访问</span></span><br><span class="line">isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//查找结点i的第一个邻接结点w</span></span><br><span class="line"><span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line"><span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//说明有</span></span><br><span class="line"><span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">dfs(isVisited, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果w结点已经被访问过</span></span><br><span class="line">w = getNextNeighbor(i, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line"><span class="comment">//遍历所有的结点，进行dfs[回溯]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">dfs(isVisited, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-图的广度优先遍历"><a href="#5-图的广度优先遍历" class="headerlink" title="5.图的广度优先遍历"></a>5.图的广度优先遍历</h2><h3 id="5-1-广度优先遍历基本思想"><a href="#5-1-广度优先遍历基本思想" class="headerlink" title="5.1 广度优先遍历基本思想"></a>5.1 广度优先遍历基本思想</h3><p>1）图的广度优先搜索（<strong>Broad First Search</strong>）。<br>2）类似于一个<strong>分层搜索</strong>的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点  </p><h3 id="5-2-广度优先遍历算法步骤"><a href="#5-2-广度优先遍历算法步骤" class="headerlink" title="5.2 广度优先遍历算法步骤"></a>5.2 广度优先遍历算法步骤</h3><p>1）访问初始结点v并标记结点v为已访问。<br>2）结点v入队列<br>3）当队列非空时，继续执行，否则算法结束。<br>4）出队列，取得队头结点u。<br>5）查找结点u的第一个邻接结点w。<br>6）若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：  </p><pre><code>6.1若结点w尚未被访问，则访问结点w并标记为已访问。  6.2结点w入队列  6.3查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。  </code></pre><h3 id="5-3-广度优先算法的图示"><a href="#5-3-广度优先算法的图示" class="headerlink" title="5.3 广度优先算法的图示"></a>5.3 广度优先算法的图示</h3><p><img src="008.PNG" alt>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对一个结点进行广度优先遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u ; <span class="comment">// 表示队列的头结点对应下标</span></span><br><span class="line"><span class="keyword">int</span> w ; <span class="comment">// 邻接结点w</span></span><br><span class="line"><span class="comment">//队列，记录结点访问的顺序</span></span><br><span class="line">LinkedList queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="comment">//访问结点，输出结点信息</span></span><br><span class="line">System.out.print(getValueByIndex(i) + <span class="string">"=&gt;"</span>);</span><br><span class="line"><span class="comment">//标记为已访问</span></span><br><span class="line">isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//将结点加入队列</span></span><br><span class="line">queue.addLast(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( !queue.isEmpty()) &#123;</span><br><span class="line"><span class="comment">//取出队列的头结点下标</span></span><br><span class="line">u = (Integer)queue.removeFirst();</span><br><span class="line"><span class="comment">//得到第一个邻接结点的下标 w </span></span><br><span class="line">w = getFirstNeighbor(u);</span><br><span class="line"><span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//找到</span></span><br><span class="line"><span class="comment">//是否访问过</span></span><br><span class="line"><span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">System.out.print(getValueByIndex(w) + <span class="string">"=&gt;"</span>);</span><br><span class="line"><span class="comment">//标记已经访问</span></span><br><span class="line">isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">queue.addLast(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以u为前驱点，找w后面的下一个邻结点</span></span><br><span class="line">w = getNextNeighbor(u, w); <span class="comment">//体现出我们的广度优先</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有的结点，都进行广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">bfs(isVisited, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-图的代码汇总"><a href="#7-图的代码汇总" class="headerlink" title="7.图的代码汇总"></a>7.图的代码汇总</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; vertexList; <span class="comment">//存储顶点集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">//存储图对应的邻结矩阵</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">//表示边的数目</span></span><br><span class="line"><span class="comment">//定义给数组boolean[], 记录某个结点是否被访问</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试一把图是否创建ok</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">8</span>;  <span class="comment">//结点的个数</span></span><br><span class="line"><span class="comment">//String Vertexs[] = &#123;"A", "B", "C", "D", "E"&#125;;</span></span><br><span class="line">String Vertexs[] = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图对象</span></span><br><span class="line">Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line"><span class="comment">//循环的添加顶点</span></span><br><span class="line"><span class="keyword">for</span>(String vertex: Vertexs) &#123;</span><br><span class="line">graph.insertVertex(vertex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加边</span></span><br><span class="line"><span class="comment">//A-B A-C B-C B-D B-E </span></span><br><span class="line"><span class="comment">//graph.insertEdge(0, 1, 1); // A-B</span></span><br><span class="line"><span class="comment">//graph.insertEdge(0, 2, 1); // </span></span><br><span class="line"><span class="comment">//graph.insertEdge(1, 2, 1); // </span></span><br><span class="line"><span class="comment">//graph.insertEdge(1, 3, 1); // </span></span><br><span class="line"><span class="comment">//graph.insertEdge(1, 4, 1); // </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新边的关系</span></span><br><span class="line">graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示一把邻结矩阵</span></span><br><span class="line">graph.showGraph();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一把，我们的dfs遍历是否ok</span></span><br><span class="line">System.out.println(<span class="string">"深度遍历"</span>);</span><br><span class="line">graph.dfs(); <span class="comment">// A-&gt;B-&gt;C-&gt;D-&gt;E [1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7]</span></span><br><span class="line"><span class="comment">//System.out.println();</span></span><br><span class="line">System.out.println(<span class="string">"广度优先!"</span>);</span><br><span class="line">graph.bfs(); <span class="comment">// A-&gt;B-&gt;C-&gt;D-E [1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">numOfEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到第一个邻接结点的下标 w </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(edges[index][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据前一个邻接结点的下标来获取下一个邻接结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(edges[v1][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历算法</span></span><br><span class="line"><span class="comment">//i 第一次就是 0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//首先我们访问该结点,输出</span></span><br><span class="line">System.out.print(getValueByIndex(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line"><span class="comment">//将结点设置为已经访问</span></span><br><span class="line">isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//查找结点i的第一个邻接结点w</span></span><br><span class="line"><span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line"><span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//说明有</span></span><br><span class="line"><span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">dfs(isVisited, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果w结点已经被访问过</span></span><br><span class="line">w = getNextNeighbor(i, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line"><span class="comment">//遍历所有的结点，进行dfs[回溯]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">dfs(isVisited, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对一个结点进行广度优先遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u ; <span class="comment">// 表示队列的头结点对应下标</span></span><br><span class="line"><span class="keyword">int</span> w ; <span class="comment">// 邻接结点w</span></span><br><span class="line"><span class="comment">//队列，记录结点访问的顺序</span></span><br><span class="line">LinkedList queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="comment">//访问结点，输出结点信息</span></span><br><span class="line">System.out.print(getValueByIndex(i) + <span class="string">"=&gt;"</span>);</span><br><span class="line"><span class="comment">//标记为已访问</span></span><br><span class="line">isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//将结点加入队列</span></span><br><span class="line">queue.addLast(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( !queue.isEmpty()) &#123;</span><br><span class="line"><span class="comment">//取出队列的头结点下标</span></span><br><span class="line">u = (Integer)queue.removeFirst();</span><br><span class="line"><span class="comment">//得到第一个邻接结点的下标 w </span></span><br><span class="line">w = getFirstNeighbor(u);</span><br><span class="line"><span class="keyword">while</span>(w != -<span class="number">1</span>) &#123;<span class="comment">//找到</span></span><br><span class="line"><span class="comment">//是否访问过</span></span><br><span class="line"><span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">System.out.print(getValueByIndex(w) + <span class="string">"=&gt;"</span>);</span><br><span class="line"><span class="comment">//标记已经访问</span></span><br><span class="line">isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">queue.addLast(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以u为前驱点，找w后面的下一个邻结点</span></span><br><span class="line">w = getNextNeighbor(u, w); <span class="comment">//体现出我们的广度优先</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有的结点，都进行广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">bfs(isVisited, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图中常用的方法</span></span><br><span class="line"><span class="comment">//返回结点的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> vertexList.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示图对应的矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] link : edges) &#123;</span><br><span class="line">System.err.println(Arrays.toString(link));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到边的数目</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> numOfEdges;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回结点i(下标)对应的数据 0-&gt;"A" 1-&gt;"B" 2-&gt;"C"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回v1和v2的权值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">vertexList.add(vertex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加边</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v1 表示点的下标即使第几个顶点  "A"-"B" "A"-&gt;0 "B"-&gt;1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v2 第二个顶点对应的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> weight 表示 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">edges[v1][v2] = weight;</span><br><span class="line">edges[v2][v1] = weight;</span><br><span class="line">numOfEdges++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-图的深度优先VS广度优先"><a href="#8-图的深度优先VS广度优先" class="headerlink" title="8.图的深度优先VS广度优先"></a>8.图的深度优先VS广度优先</h2><p><img src="009.PNG" alt><br>1）深度优先遍历顺序为1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7<br>2）广度优先算法的遍历顺序为：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-图基本介绍&quot;&gt;&lt;a href=&quot;#1-图基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.图基本介绍&quot;&gt;&lt;/a&gt;1.图基本介绍&lt;/h2&gt;&lt;h3 id=&quot;1-1-为什么要有图&quot;&gt;&lt;a href=&quot;#1-1-为什么要有图&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么要有图&quot;&gt;&lt;/a&gt;1.1 为什么要有图&lt;/h3&gt;&lt;p&gt;1）前面我们学了线性表和树&lt;br&gt;2）线性表局限于一个直接前驱和一个直接后继的关系
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="https://RuanGuoHui.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之多路查找树</title>
    <link href="https://RuanGuoHui.github.io/2019/07/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>https://RuanGuoHui.github.io/2019/07/26/数据结构与算法之多路查找树/</id>
    <published>2019-07-26T01:29:16.000Z</published>
    <updated>2019-07-26T05:24:17.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-多路查找树"><a href="#1-多路查找树" class="headerlink" title="1.多路查找树"></a>1.多路查找树</h2><h3 id="1-1-二又树与B树"><a href="#1-1-二又树与B树" class="headerlink" title="1.1 二又树与B树"></a>1.1 二又树与B树</h3><h4 id="1-1-1-二叉树的问题分析"><a href="#1-1-1-二叉树的问题分析" class="headerlink" title="1.1.1 二叉树的问题分析"></a>1.1.1 二叉树的问题分析</h4><p>二叉树的操作效率较高，但是也存在问题，请看下面的二又树  <a id="more"></a><br><img src="001.PNG" alt><br>1）二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二又树的节点很多（比如1亿），就存在如下问题：<br>2）问题1：在构建二叉树时，需要多次进行io操作（海量数据存在数据库或文件中），节点海量，构建二叉树时，速度有影响<br>3）问题2：节点海量，也会造成二叉树的高度很大，会降低操作速度.  </p><h3 id="1-2-多叉树"><a href="#1-2-多叉树" class="headerlink" title="1.2 多叉树"></a>1.2 多叉树</h3><p>1）在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）  </p><p>2）后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二又树进行优化。<br>3）举例说明（下面2-3树就是一颗多叉树）<br><img src="002.PNG" alt>  </p><h3 id="1-3-B树的基本介绍"><a href="#1-3-B树的基本介绍" class="headerlink" title="1.3 B树的基本介绍"></a>1.3 B树的基本介绍</h3><p>B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。<br>1）如图B树通过重新组织节点，降低了树的高度。<br>2）文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页（页得大小通常为4k），这样每个节点只需要一次IVO就可以完全载入<br>3）将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树（B+）广泛应用于文件存储系统以及数据库系统中  </p><h2 id="2-2-3树"><a href="#2-2-3树" class="headerlink" title="2.2-3树"></a>2.2-3树</h2><h3 id="2-1-2-3树是最简单的B树结构，具有如下特点："><a href="#2-1-2-3树是最简单的B树结构，具有如下特点：" class="headerlink" title="2.1 2-3树是最简单的B树结构，具有如下特点："></a>2.1 2-3树是最简单的B树结构，具有如下特点：</h3><p>1）2-3树的所有叶子节点都在同一层.（只要是B树都满足这个条件）<br>2）有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.<br>3）有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.<br>4）2-3树是由二节点和三节点构成的树。  </p><h3 id="2-2-2-3树应用案例"><a href="#2-2-2-3树应用案例" class="headerlink" title="2.2 2-3树应用案例"></a>2.2 2-3树应用案例</h3><p>将数列{16，24，12，32，14，26，34，10，8，28，38，20}构建成2-3树，并保证数据插入的大小顺序。（演示一下构建2-3树的过程.）<br><img src="003.PNG" alt><br>插入规则：<br>1）2-3树的所有叶子节点都在同一层.（只要是B树都满足这个条件）<br>2）有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.<br>3）有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点<br>4）当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件。<br>5）对于三节点的子树的值大小仍然遵守（BST二又排序树）的规则  </p><h3 id="2-3-其它说明"><a href="#2-3-其它说明" class="headerlink" title="2.3 其它说明"></a>2.3 其它说明</h3><p>除了23树，还有234树等，概念和23树类似，也是一种B树。如图：<br><img src="004.PNG" alt>  </p><h2 id="3-B树、B-树和B-树"><a href="#3-B树、B-树和B-树" class="headerlink" title="3.B树、B+树和B*树"></a>3.B树、B+树和B*树</h2><h3 id="3-1-B树的介绍"><a href="#3-1-B树的介绍" class="headerlink" title="3.1 B树的介绍"></a>3.1 B树的介绍</h3><p>B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。  </p><h3 id="3-2-B树的介绍"><a href="#3-2-B树的介绍" class="headerlink" title="3.2 B树的介绍"></a>3.2 B树的介绍</h3><p>前面已经介绍了2-3树和2-3-4树，他们就是B树（英语：B-tree也写成B-树），这里我们再做一个说明，我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图：<br><img src="005.PNG" alt><br>对上图的说明：<br>1）B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4<br>2）B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点<br>3）关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据.<br>4）搜索有可能在非叶子结点结束<br>5）其搜索性能等价于在关键字全集内做一次二分查找  </p><h3 id="3-3-B-树的介绍"><a href="#3-3-B-树的介绍" class="headerlink" title="3.3 B+树的介绍"></a>3.3 B+树的介绍</h3><p>B+树是B树的变体，也是一种多路搜索树。<br><img src="006.PNG" alt><br>对上图的说明：<br>1）B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找<br>2）所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字（数据）恰好是有序的。<br>3）不可能在非叶子结点命中<br>4）非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层<br>5）更适合文件索引系统<br>6）B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.  </p><h3 id="3-4-B-树的介绍"><a href="#3-4-B-树的介绍" class="headerlink" title="3.4 B*树的介绍"></a>3.4 B*树的介绍</h3><p>B<code>*</code>树是B+树的变体，在B+树的<strong>非根</strong>和<strong>非叶子结点再增加指向兄弟的指针</strong>。  </p><h4 id="3-4-1-B-树的说明："><a href="#3-4-1-B-树的说明：" class="headerlink" title="3.4.1 B*树的说明："></a>3.4.1 B*树的说明：</h4><p>1）B<code>*</code>树定义了非叶子结点关键字个数至少为（2/3）<code>*</code>M，即块的最低使用率为2/3，而B+树的块的最低使用率为的1/2。<br>2）从第1个特点我们可以看出，B<code>*</code>树分配新结点的概率比B+树要低，空间使用率更高</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-多路查找树&quot;&gt;&lt;a href=&quot;#1-多路查找树&quot; class=&quot;headerlink&quot; title=&quot;1.多路查找树&quot;&gt;&lt;/a&gt;1.多路查找树&lt;/h2&gt;&lt;h3 id=&quot;1-1-二又树与B树&quot;&gt;&lt;a href=&quot;#1-1-二又树与B树&quot; class=&quot;headerlink&quot; title=&quot;1.1 二又树与B树&quot;&gt;&lt;/a&gt;1.1 二又树与B树&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-二叉树的问题分析&quot;&gt;&lt;a href=&quot;#1-1-1-二叉树的问题分析&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 二叉树的问题分析&quot;&gt;&lt;/a&gt;1.1.1 二叉树的问题分析&lt;/h4&gt;&lt;p&gt;二叉树的操作效率较高，但是也存在问题，请看下面的二又树
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="多路查找树" scheme="https://RuanGuoHui.github.io/tags/%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之树结构实际应用</title>
    <link href="https://RuanGuoHui.github.io/2019/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <id>https://RuanGuoHui.github.io/2019/07/25/数据结构与算法之树结构实际应用/</id>
    <published>2019-07-25T01:24:20.000Z</published>
    <updated>2019-07-25T11:04:50.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1.堆排序"></a>1.堆排序</h2><h3 id="1-1-堆排序基本介绍"><a href="#1-1-堆排序基本介绍" class="headerlink" title="1.1 堆排序基本介绍"></a>1.1 堆排序基本介绍</h3><p>1）堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为<strong>O(nlogn)</strong>，它也是不稳定排序。  <a id="more"></a><br>2）堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，注意：没有要求结点的左孩子的值和右孩子的值的大小关系。<br>3）每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆<br>4）大顶堆举例说明<br><img src="001.PNG" alt><br>5）小顶堆举例说明<br><img src="002.PNG" alt><br>6）一般升序采用大顶堆，降序采用小顶堆  </p><h3 id="1-2-堆排序基本思想"><a href="#1-2-堆排序基本思想" class="headerlink" title="1.2 堆排序基本思想"></a>1.2 堆排序基本思想</h3><p>堆排序的基本思想是：<br>1）将待排序序列构造成一个大顶堆<br>2）此时，整个序列的最大值就是堆顶的根节点。<br>3）将其与末尾元素进行交换，此时末尾就为最大值。<br>4）然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。  </p><p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.  </p><h3 id="1-3-堆排序步骤图解说明"><a href="#1-3-堆排序步骤图解说明" class="headerlink" title="1.3 堆排序步骤图解说明"></a>1.3 堆排序步骤图解说明</h3><p>要求：给你一个数组{4，6，8，5，9}，要求使用堆排序法，将数组升序排序。  </p><p><strong>步骤一构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆）。原始的数组[4，6，8，5，9]</strong><br>1）.假设给定无序序列结构如下<br><img src="003.PNG" alt><br>2）.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。<br><img src="004.PNG" alt><br>3）.找到第二个非叶节点4，由于[4，9，8]中9元素最大，4和9交换。<br><img src="005.PNG" alt><br>4）这时，交换导致了子根[4，5，6]结构混乱，继续调整，[4，5，6]中6最大，交换4和6。<br><img src="006.PNG" alt><br>此时，我们就将一个无序序列构造成了一个大顶堆。  </p><p><strong>步骤二将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong><br>1）.将堆顶元素9和末尾元素4进行交换<br><img src="007.PNG" alt><br>2）.重新调整结构，使其继续满足堆定义<br><img src="008.PNG" alt><br>3）.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.<br><img src="009.PNG" alt><br>4）后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序<br><img src="010.PNG" alt><br><strong>再简单总结下堆排序的基本思路：</strong>  </p><p>1）.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆：<br>2）.将堆顶元素与末尾元素交换，将最大元素“沉”到数组未端；<br>3）.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤现<br>要求：给你一个数组{4，68，5，9}，要求使用堆排序法，将数组升序排序。<br>代码实现：：<br>说明：<br>1）堆排序不是很好理解，通过Debug帮助大家理解堆排序<br>2）堆排序的速度非常快，在我的机器上8百万数据3秒左右。O（nlogn）<br>3）代码实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//要求将数组进行升序排序</span></span><br><span class="line"><span class="comment">//int arr[] = &#123;4, 6, 8, 5, 9&#125;;</span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line">heapSort(arr);</span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"><span class="comment">//System.out.println("排序后=" + Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个堆排序的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">System.out.println(<span class="string">"堆排序!!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">////分步完成</span></span><br><span class="line"><span class="comment">//adjustHeap(arr, 1, arr.length);</span></span><br><span class="line"><span class="comment">//System.out.println("第一次" + Arrays.toString(arr)); // 4, 9, 8, 5, 6</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//adjustHeap(arr, 0, arr.length);</span></span><br><span class="line"><span class="comment">//System.out.println("第2次" + Arrays.toString(arr)); // 9,6,8,5,4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//完成我们最终代码</span></span><br><span class="line"><span class="comment">//将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> -<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">adjustHeap(arr, i, arr.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</span></span><br><span class="line"><span class="comment">　　3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length-<span class="number">1</span>;j &gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = temp;</span><br><span class="line">adjustHeap(arr, <span class="number">0</span>, j); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("数组=" + Arrays.toString(arr)); </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个数组(二叉树), 调整成一个大顶堆</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆</span></span><br><span class="line"><span class="comment"> * 举例  int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125;</span></span><br><span class="line"><span class="comment"> * 如果我们再次调用  adjustHeap 传入的是 i = 0 =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待调整的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 表示非叶子结点在数组中索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lenght 表示对多少个元素继续调整， length 是在逐渐的减少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> lenght)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line"><span class="comment">//开始调整</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. k = i * 2 + 1 k 是 i结点的左子结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; lenght; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(k+<span class="number">1</span> &lt; lenght &amp;&amp; arr[k] &lt; arr[k+<span class="number">1</span>]) &#123; <span class="comment">//说明左子结点的值小于右子结点的值</span></span><br><span class="line">k++; <span class="comment">// k 指向右子结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(arr[k] &gt; temp) &#123; <span class="comment">//如果子结点大于父结点</span></span><br><span class="line">arr[i] = arr[k]; <span class="comment">//把较大的值赋给当前结点</span></span><br><span class="line">i = k; <span class="comment">//!!! i 指向 k,继续循环比较</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)</span></span><br><span class="line">arr[i] = temp;<span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-赫夫曼树"><a href="#2-赫夫曼树" class="headerlink" title="2.赫夫曼树"></a>2.赫夫曼树</h2><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h3><p>1）给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度（wpl）达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree），还有的书翻译为霍夫曼树。<br>2）赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近  </p><h3 id="2-2-赫夫曼树几个重要概念和举例说明"><a href="#2-2-赫夫曼树几个重要概念和举例说明" class="headerlink" title="2.2 赫夫曼树几个重要概念和举例说明"></a>2.2 赫夫曼树几个重要概念和举例说明</h3><p>1）<strong>路径和路径长度：</strong>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。<strong>通路中分支的数目称为路径长度</strong>。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为<strong>L-1</strong><br>2）<strong>结点的权及带权路径长度</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。<strong>结点的带权路径长度为</strong>：从根结点到该结点之间的路径长度与该结点的权的乘积<br>3）树的带权路径长度：树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和</strong>，记为WPL（weighted path length），权值越大的结点离根结点越近的二叉树才是最优二叉树。<br>4）WPL最小的就是赫夫曼树<br><img src="011.PNG" alt>  </p><h3 id="2-3-赫夫曼树创建思路图解"><a href="#2-3-赫夫曼树创建思路图解" class="headerlink" title="2.3 赫夫曼树创建思路图解"></a>2.3 赫夫曼树创建思路图解</h3><p>给你一个数列{13，7，8，3，29，6，1}，要求转成一颗赫夫曼树.</p><h4 id="2-3-1-思路分析（示意图）："><a href="#2-3-1-思路分析（示意图）：" class="headerlink" title="2.3.1 思路分析（示意图）："></a>2.3.1 思路分析（示意图）：</h4><p>{13，7，8，3，29，6，1}<br><strong>构成赫夫曼树的步骤：</strong><br>1）从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树<br>2）取出根节点权值最小的两颗二叉树<br>3）组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和<br>4）再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树<br>5）图解：<br><img src="012.PNG" alt>  </p><h3 id="2-4-赫夫曼树的代码实现"><a href="#2-4-赫夫曼树的代码实现" class="headerlink" title="2.4 赫夫曼树的代码实现"></a>2.4 赫夫曼树的代码实现</h3><p>代码实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.huffmantree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span> &#125;;</span><br><span class="line">Node root = createHuffmanTree(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一把</span></span><br><span class="line">preOrder(root); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.preOrder();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"是空树，不能遍历~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建赫夫曼树的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 需要创建成哈夫曼树的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 创建好后的赫夫曼树的root结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 第一步为了操作方便</span></span><br><span class="line"><span class="comment">// 1. 遍历 arr 数组</span></span><br><span class="line"><span class="comment">// 2. 将arr的每个元素构成成一个Node</span></span><br><span class="line"><span class="comment">// 3. 将Node 放入到ArrayList中</span></span><br><span class="line">List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们处理的过程是一个循环的过程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序 从小到大 </span></span><br><span class="line">Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"nodes ="</span> + nodes);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出根节点权值最小的两颗二叉树 </span></span><br><span class="line"><span class="comment">//(1) 取出权值最小的结点（二叉树）</span></span><br><span class="line">Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//(2) 取出权值第二小的结点（二叉树）</span></span><br><span class="line">Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)构建一颗新的二叉树</span></span><br><span class="line">Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">parent.left = leftNode;</span><br><span class="line">parent.right = rightNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">nodes.remove(leftNode);</span><br><span class="line">nodes.remove(rightNode);</span><br><span class="line"><span class="comment">//(5)将parent加入到nodes</span></span><br><span class="line">nodes.add(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回哈夫曼树的root结点</span></span><br><span class="line"><span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建结点类</span></span><br><span class="line"><span class="comment">// 为了让Node 对象持续排序Collections集合排序</span></span><br><span class="line"><span class="comment">// 让Node 实现Comparable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value; <span class="comment">// 结点权值</span></span><br><span class="line"><span class="keyword">char</span> c; <span class="comment">//字符</span></span><br><span class="line">Node left; <span class="comment">// 指向左子结点</span></span><br><span class="line">Node right; <span class="comment">// 指向右子结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">// 表示从小到大排序</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.value - o.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-赫夫曼编码"><a href="#3-赫夫曼编码" class="headerlink" title="3.赫夫曼编码"></a>3.赫夫曼编码</h2><h3 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1 基本介绍"></a>3.1 基本介绍</h3><p>1）赫夫曼编码也翻译为哈夫曼编码（Huffman Coding），又称霍夫曼编码，是一种编码方式，属于一种程序算法<br>2）赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。<br>3）赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间<br>4）赫夫曼码是可变字长编码（VLC）的一种。Huffman于1952年提出一种编码方法，称之为最佳编码  </p><h3 id="3-2-原理剖析"><a href="#3-2-原理剖析" class="headerlink" title="3.2 原理剖析"></a>3.2 原理剖析</h3><h4 id="3-2-1-通信领域中信息的处理方式1-定长编码"><a href="#3-2-1-通信领域中信息的处理方式1-定长编码" class="headerlink" title="3.2.1 通信领域中信息的处理方式1-定长编码"></a>3.2.1 通信领域中信息的处理方式1-定长编码</h4><p><img src="013.PNG" alt>  </p><h4 id="3-2-2-通信领域中信息的处理方式2-变长编码"><a href="#3-2-2-通信领域中信息的处理方式2-变长编码" class="headerlink" title="3.2.2 通信领域中信息的处理方式2-变长编码"></a>3.2.2 通信领域中信息的处理方式2-变长编码</h4><p><img src="014.PNG" alt>  </p><h4 id="3-2-3-通信领域中信息的处理方式3-赫夫曼编码"><a href="#3-2-3-通信领域中信息的处理方式3-赫夫曼编码" class="headerlink" title="3.2.3 通信领域中信息的处理方式3-赫夫曼编码"></a>3.2.3 通信领域中信息的处理方式3-赫夫曼编码</h4><p>步骤如下；  </p><p>传输的字符串<br>1）i like like like java do you like a java<br>2）d：1y：1u：1j：2 v：2 o：2 1：4k：4e：4i：5 a：5：9//各个字符对应的个数3）按照上面字符出现的次数构建一颗赫夫曼树，次数作为权值  </p><pre><code>步骤：构成赫夫曼树的步骤：1）从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树2）取出根节点权值最小的两颗二叉树3）组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和4）再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树  </code></pre><p><img src="015.PNG" alt><br>4）根据赫夫曼树，给各个字符，规定编码（前缀编码），向左的路径为0向右的路径为1，编码如下：</p><pre><code>o：1000 u：10010 d：100110 y：100111 i：101  a：110    k：1110 e：1111 j：0000    v：0001  l：001    ：01  </code></pre><p>5）按照上面的赫夫曼编码，我们的“ilike like like java do you like a java”字符串对应的编码为（注意这里我们使用的无损压缩）  </p><pre><code>*101***01***001*1011110111101001101111011110100110111101111010000110    0001110011001111000011001111000100100100110111101111011100100001100001110通过赫夫曼编码处理长度为133</code></pre><p>6）长度为：133<br>说明：<br>原来长度是359，压缩了（359-133）/359=62.9%<br>此编码满足前缀编码，即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性赫夫曼编码是无损处理方案  </p><h4 id="3-2-4-注意事项"><a href="#3-2-4-注意事项" class="headerlink" title="3.2.4 注意事项"></a>3.2.4 注意事项</h4><p>注意，这个赫夫曼树根据<strong>排序方法不同</strong>，也可能不太一样，这样对应的<strong>赫夫曼编码也不完全一样</strong>，但是wpl是一样的，都是最小的，最后生成的赫夫曼编码的长度是一样，比如：如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为：<br><img src="016.PNG" alt>  </p><h3 id="3-3-最佳实践-数据压缩（创建赫夫曼树）"><a href="#3-3-最佳实践-数据压缩（创建赫夫曼树）" class="headerlink" title="3.3 最佳实践-数据压缩（创建赫夫曼树）"></a>3.3 最佳实践-数据压缩（创建赫夫曼树）</h3><p>将给出的一段文本，比如”ilike like like java do you like a java”，根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理，形式如<br>“101010011011110111101001101111011110100110111101111010000<br>1100001110011001111000011001111000100100100110111101111011<br>100100001100001110”<br><strong>步骤1</strong>：根据赫夫曼编码压缩数据的原理，需要创建”ilike like like java do you like a java”对应的赫夫曼树.<br>思路：前面已经分析过了，而且我们已然讲过了构建赫夫曼树的具体实现。<br>代码实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过List 创建对应的赫夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//排序, 从小到大</span></span><br><span class="line">Collections.sort(nodes);</span><br><span class="line"><span class="comment">//取出第一颗最小的二叉树</span></span><br><span class="line">Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//取出第二颗最小的二叉树</span></span><br><span class="line">Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//创建一颗新的二叉树,它的根节点 没有data, 只有权值</span></span><br><span class="line">Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">parent.left = leftNode;</span><br><span class="line">parent.right = rightNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将已经处理的两颗二叉树从nodes删除</span></span><br><span class="line">nodes.remove(leftNode);</span><br><span class="line">nodes.remove(rightNode);</span><br><span class="line"><span class="comment">//将新的二叉树，加入到nodes</span></span><br><span class="line">nodes.add(parent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nodes 最后的结点，就是赫夫曼树的根结点</span></span><br><span class="line"><span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-最佳实践-数据压缩（生成赫夫曼编码和赫夫曼编码后的数据）"><a href="#3-4-最佳实践-数据压缩（生成赫夫曼编码和赫夫曼编码后的数据）" class="headerlink" title="3.4 最佳实践-数据压缩（生成赫夫曼编码和赫夫曼编码后的数据）"></a>3.4 最佳实践-数据压缩（生成赫夫曼编码和赫夫曼编码后的数据）</h3><p>我们已经生成了赫夫曼树，下面我们继续完成任务<br>1）生成赫夫曼树对应的赫夫曼编码，如下表：<br>=01a=100d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011<br>2）使用赫夫曼编码来生成赫夫曼编码数据，即按照上面的赫夫曼编码，将”ilike like like java do you like a java”<br>字符串生成对应的编码数据，形式如下。<br>1010100010111111110010001011111111001000101111111100100<br>1010011011100011100000110111010001111001010001011111111<br>00110001001010011011100<br>3）思路：前面已经分析过了，而且我们讲过了生成赫夫曼编码的具体实现。<br>4）代码实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了调用方便，我们重载 getCodes</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理root的左子树</span></span><br><span class="line">getCodes(root.left, <span class="string">"0"</span>, stringBuilder);</span><br><span class="line"><span class="comment">//处理root的右子树</span></span><br><span class="line">getCodes(root.right, <span class="string">"1"</span>, stringBuilder);</span><br><span class="line"><span class="keyword">return</span> huffmanCodes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node  传入结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code  路径： 左子结点是 0, 右子结点 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line"><span class="comment">//将code 加入到 stringBuilder2</span></span><br><span class="line">stringBuilder2.append(code);</span><br><span class="line"><span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123; <span class="comment">//如果node == null不处理</span></span><br><span class="line"><span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>) &#123; <span class="comment">//非叶子结点</span></span><br><span class="line"><span class="comment">//递归处理</span></span><br><span class="line"><span class="comment">//向左递归</span></span><br><span class="line">getCodes(node.left, <span class="string">"0"</span>, stringBuilder2);</span><br><span class="line"><span class="comment">//向右递归</span></span><br><span class="line">getCodes(node.right, <span class="string">"1"</span>, stringBuilder2);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line"><span class="comment">//就表示找到某个叶子结点的最后</span></span><br><span class="line">huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5最佳实践-数据解压（使用赫夫曼编码解码）"><a href="#3-5最佳实践-数据解压（使用赫夫曼编码解码）" class="headerlink" title="3.5最佳实践-数据解压（使用赫夫曼编码解码）"></a>3.5最佳实践-数据解压（使用赫夫曼编码解码）</h3><p>使用赫夫曼编码来解码数据，具体要求是<br>1）前面我们得到了赫夫曼编码和对应的编码<br>byte[]，即：[-88，-65，-56，-65，-56，-65，-55，77<br>，-57，6，-24，-14，-117，-4，-60，-90，28]<br>2）现在要求使用赫夫曼编码，进行解码，又<br>重新得到原来的字符串”ilike like like java do you like a java”<br>3）思路：解码过程，就是编码的一个逆向操作。<br>4）代码实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 传入的 byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是该b 对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用变量保存 b</span></span><br><span class="line"><span class="keyword">int</span> temp = b; <span class="comment">//将 b 转成 int</span></span><br><span class="line"><span class="comment">//如果是正数我们还存在补高位</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">temp |= <span class="number">256</span>; <span class="comment">//按位与 256  1 0000 0000  | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">&#125;</span><br><span class="line">String str = Integer.toBinaryString(temp); <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个方法，完成对压缩数据的解码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte,String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//将byte数组转成二进制的字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line"><span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line"><span class="comment">//判断是不是最后一个字节</span></span><br><span class="line"><span class="keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把字符串安装指定的赫夫曼编码进行解码</span></span><br><span class="line"><span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a</span></span><br><span class="line">Map&lt;String, Byte&gt;  map = <span class="keyword">new</span> HashMap&lt;String,Byte&gt;();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Byte, String&gt; entry: huffmanCodes.entrySet()) &#123;</span><br><span class="line">map.put(entry.getValue(), entry.getKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建要给集合，存放byte</span></span><br><span class="line">List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//i 可以理解成就是索引,扫描 stringBuilder </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 小的计数器</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">Byte b = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(flag) &#123;</span><br><span class="line"><span class="comment">//1010100010111...</span></span><br><span class="line"><span class="comment">//递增的取出 key 1 </span></span><br><span class="line">String key = stringBuilder.substring(i, i+count);<span class="comment">//i 不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">b = map.get(key);</span><br><span class="line"><span class="keyword">if</span>(b == <span class="keyword">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">count++;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//匹配到</span></span><br><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">list.add(b);</span><br><span class="line">i += count;<span class="comment">//i 直接移动到 count</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当for循环结束后，我们list中就存放了所有的字符  "i like like like java do you like a java"</span></span><br><span class="line"><span class="comment">//把list 中的数据放入到byte[] 并返回</span></span><br><span class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; b.length; i++) &#123;</span><br><span class="line">b[i] = list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-最佳实践-文件压缩"><a href="#3-6-最佳实践-文件压缩" class="headerlink" title="3.6 最佳实践-文件压缩"></a>3.6 最佳实践-文件压缩</h3><p>我们学习了通过赫夫曼编码对一个字符串进行编码和解码，下面我们来完成对文件的压缩和解压，具体要求：<br>给你一个图片文件，要求对其进行无损压缩，看看压缩效果如何。<br>1）思路：读取文件-&gt;得到赫夫曼编码表&gt;完成压缩<br>2）代码实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写方法，将一个文件进行压缩</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcFile, String dstFile)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建输出流</span></span><br><span class="line">OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//创建文件的输入流</span></span><br><span class="line">FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建文件的输入流</span></span><br><span class="line">is = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line"><span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">is.read(b);</span><br><span class="line"><span class="comment">//直接对源文件压缩</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line"><span class="comment">//创建文件的输出流, 存放压缩文件</span></span><br><span class="line">os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line"><span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line"><span class="comment">//把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">oos.writeObject(huffmanBytes); <span class="comment">//我们是把</span></span><br><span class="line"><span class="comment">//这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line"><span class="comment">//注意一定要把赫夫曼编码 写入压缩文件</span></span><br><span class="line">oos.writeObject(huffmanCodes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">is.close();</span><br><span class="line">oos.close();</span><br><span class="line">os.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-最佳实践-文件解压（文件恢复）"><a href="#3-7-最佳实践-文件解压（文件恢复）" class="headerlink" title="3.7 最佳实践-文件解压（文件恢复）"></a>3.7 最佳实践-文件解压（文件恢复）</h3><p>具体要求：将前面压缩的文件，重新恢复成原来的文件。<br>1）思路：读取压缩文件（数据和赫夫曼编码表）-&gt;完成解压（文件恢复）<br>2）代码实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个方法，完成对压缩文件的解压</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义文件输入流</span></span><br><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//定义一个对象输入流</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//定义文件的输出流</span></span><br><span class="line">OutputStream os = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建文件输入流</span></span><br><span class="line">is = <span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line"><span class="comment">//创建一个和  is关联的对象输入流</span></span><br><span class="line">ois = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line"><span class="comment">//读取byte数组  huffmanBytes</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanBytes = (<span class="keyword">byte</span>[])ois.readObject();</span><br><span class="line"><span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line"><span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line"><span class="comment">//写数据到 dstFile 文件</span></span><br><span class="line">os.write(bytes);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">os.close();</span><br><span class="line">ois.close();</span><br><span class="line">is.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e2.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-代码汇总，把前面所有的方法放在一起"><a href="#3-8-代码汇总，把前面所有的方法放在一起" class="headerlink" title="3.8 代码汇总，把前面所有的方法放在一起"></a>3.8 代码汇总，把前面所有的方法放在一起</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.huffmancode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试压缩文件</span></span><br><span class="line"><span class="comment">//String srcFile = "d://Uninstall.xml";</span></span><br><span class="line"><span class="comment">//String dstFile = "d://Uninstall.zip";</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//zipFile(srcFile, dstFile);</span></span><br><span class="line"><span class="comment">//System.out.println("压缩文件ok~~");</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试解压文件</span></span><br><span class="line">String zipFile = <span class="string">"d://Uninstall.zip"</span>;</span><br><span class="line">String dstFile = <span class="string">"d://Uninstall2.xml"</span>;</span><br><span class="line">unZipFile(zipFile, dstFile);</span><br><span class="line">System.out.println(<span class="string">"解压成功!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">String content = "i like like like java do you like a java";</span></span><br><span class="line"><span class="comment">byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">System.out.println(contentBytes.length); //40</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">byte[] huffmanCodesBytes= huffmanZip(contentBytes);</span></span><br><span class="line"><span class="comment">System.out.println("压缩后的结果是:" + Arrays.toString(huffmanCodesBytes) + " 长度= " + huffmanCodesBytes.length);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//测试一把byteToBitString方法</span></span><br><span class="line"><span class="comment">//System.out.println(byteToBitString((byte)1));</span></span><br><span class="line"><span class="comment">byte[] sourceBytes = decode(huffmanCodes, huffmanCodesBytes);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("原来的字符串=" + new String(sourceBytes)); // "i like like like java do you like a java"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何将 数据进行解压(解码)  </span></span><br><span class="line"><span class="comment">//分步过程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">List&lt;Node&gt; nodes = getNodes(contentBytes);</span></span><br><span class="line"><span class="comment">System.out.println("nodes=" + nodes);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//测试一把，创建的赫夫曼树</span></span><br><span class="line"><span class="comment">System.out.println("赫夫曼树");</span></span><br><span class="line"><span class="comment">Node huffmanTreeRoot = createHuffmanTree(nodes);</span></span><br><span class="line"><span class="comment">System.out.println("前序遍历");</span></span><br><span class="line"><span class="comment">huffmanTreeRoot.preOrder();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//测试一把是否生成了对应的赫夫曼编码</span></span><br><span class="line"><span class="comment">Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span></span><br><span class="line"><span class="comment">System.out.println("~生成的赫夫曼编码表= " + huffmanCodes);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">byte[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">System.out.println("huffmanCodeBytes=" + Arrays.toString(huffmanCodeBytes));//17</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//发送huffmanCodeBytes 数组 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个方法，完成对压缩文件的解压</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义文件输入流</span></span><br><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//定义一个对象输入流</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//定义文件的输出流</span></span><br><span class="line">OutputStream os = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建文件输入流</span></span><br><span class="line">is = <span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line"><span class="comment">//创建一个和  is关联的对象输入流</span></span><br><span class="line">ois = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line"><span class="comment">//读取byte数组  huffmanBytes</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanBytes = (<span class="keyword">byte</span>[])ois.readObject();</span><br><span class="line"><span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line"><span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line"><span class="comment">//写数据到 dstFile 文件</span></span><br><span class="line">os.write(bytes);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">os.close();</span><br><span class="line">ois.close();</span><br><span class="line">is.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e2.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写方法，将一个文件进行压缩</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcFile, String dstFile)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建输出流</span></span><br><span class="line">OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//创建文件的输入流</span></span><br><span class="line">FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建文件的输入流</span></span><br><span class="line">is = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line"><span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">is.read(b);</span><br><span class="line"><span class="comment">//直接对源文件压缩</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line"><span class="comment">//创建文件的输出流, 存放压缩文件</span></span><br><span class="line">os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line"><span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line"><span class="comment">//把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">oos.writeObject(huffmanBytes); <span class="comment">//我们是把</span></span><br><span class="line"><span class="comment">//这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line"><span class="comment">//注意一定要把赫夫曼编码 写入压缩文件</span></span><br><span class="line">oos.writeObject(huffmanCodes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">is.close();</span><br><span class="line">oos.close();</span><br><span class="line">os.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成数据的解压</span></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">//1. 将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</span></span><br><span class="line"><span class="comment">//   重写先转成 赫夫曼编码对应的二进制的字符串 "1010100010111..."</span></span><br><span class="line"><span class="comment">//2.  赫夫曼编码对应的二进制的字符串 "1010100010111..." =》 对照 赫夫曼编码  =》 "i like like like java do you like a java"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个方法，完成对压缩数据的解码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte,String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//将byte数组转成二进制的字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line"><span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line"><span class="comment">//判断是不是最后一个字节</span></span><br><span class="line"><span class="keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把字符串安装指定的赫夫曼编码进行解码</span></span><br><span class="line"><span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a</span></span><br><span class="line">Map&lt;String, Byte&gt;  map = <span class="keyword">new</span> HashMap&lt;String,Byte&gt;();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Byte, String&gt; entry: huffmanCodes.entrySet()) &#123;</span><br><span class="line">map.put(entry.getValue(), entry.getKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建要给集合，存放byte</span></span><br><span class="line">List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//i 可以理解成就是索引,扫描 stringBuilder </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 小的计数器</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">Byte b = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(flag) &#123;</span><br><span class="line"><span class="comment">//1010100010111...</span></span><br><span class="line"><span class="comment">//递增的取出 key 1 </span></span><br><span class="line">String key = stringBuilder.substring(i, i+count);<span class="comment">//i 不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">b = map.get(key);</span><br><span class="line"><span class="keyword">if</span>(b == <span class="keyword">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">count++;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//匹配到</span></span><br><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">list.add(b);</span><br><span class="line">i += count;<span class="comment">//i 直接移动到 count</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当for循环结束后，我们list中就存放了所有的字符  "i like like like java do you like a java"</span></span><br><span class="line"><span class="comment">//把list 中的数据放入到byte[] 并返回</span></span><br><span class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; b.length; i++) &#123;</span><br><span class="line">b[i] = list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 传入的 byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是该b 对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用变量保存 b</span></span><br><span class="line"><span class="keyword">int</span> temp = b; <span class="comment">//将 b 转成 int</span></span><br><span class="line"><span class="comment">//如果是正数我们还存在补高位</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">temp |= <span class="number">256</span>; <span class="comment">//按位与 256  1 0000 0000  | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">&#125;</span><br><span class="line">String str = Integer.toBinaryString(temp); <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是经过 赫夫曼编码处理后的字节数组(压缩后的数组)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line"><span class="comment">//根据 nodes 创建的赫夫曼树</span></span><br><span class="line">Node huffmanTreeRoot = createHuffmanTree(nodes);</span><br><span class="line"><span class="comment">//对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line"><span class="comment">//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line"><span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 这时原始的字符串对应的 byte[]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanCodes 生成的赫夫曼编码map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回赫夫曼编码处理后的 byte[] </span></span><br><span class="line"><span class="comment"> * 举例： String content = "i like like like java do you like a java"; =》 byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment"> * 返回的是 字符串 "1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100"</span></span><br><span class="line"><span class="comment"> * =&gt; 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes</span></span><br><span class="line"><span class="comment"> * huffmanCodeBytes[0] =  10101000(补码) =&gt; byte  [推导  10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ]</span></span><br><span class="line"><span class="comment"> * huffmanCodeBytes[1] = -88</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//遍历bytes 数组 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">byte</span> b: bytes) &#123;</span><br><span class="line">stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("测试 stringBuilder~~~=" + stringBuilder.toString());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 "1010100010111111110..." 转成 byte[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//统计返回  byte[] huffmanCodeBytes 长度</span></span><br><span class="line"><span class="comment">//一句话 int len = (stringBuilder.length() + 7) / 8;</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">if</span>(stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">String strByte;</span><br><span class="line"><span class="keyword">if</span>(i+<span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">strByte = stringBuilder.substring(i);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">huffmanCodeBytes[index] = (<span class="keyword">byte</span>)Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line"><span class="comment">//思路:</span></span><br><span class="line"><span class="comment">//1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式</span></span><br><span class="line"><span class="comment">//   生成的赫夫曼编码表&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125;</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;Byte,String&gt;();</span><br><span class="line"><span class="comment">//2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径</span></span><br><span class="line"><span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了调用方便，我们重载 getCodes</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理root的左子树</span></span><br><span class="line">getCodes(root.left, <span class="string">"0"</span>, stringBuilder);</span><br><span class="line"><span class="comment">//处理root的右子树</span></span><br><span class="line">getCodes(root.right, <span class="string">"1"</span>, stringBuilder);</span><br><span class="line"><span class="keyword">return</span> huffmanCodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node  传入结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code  路径： 左子结点是 0, 右子结点 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line"><span class="comment">//将code 加入到 stringBuilder2</span></span><br><span class="line">stringBuilder2.append(code);</span><br><span class="line"><span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123; <span class="comment">//如果node == null不处理</span></span><br><span class="line"><span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>) &#123; <span class="comment">//非叶子结点</span></span><br><span class="line"><span class="comment">//递归处理</span></span><br><span class="line"><span class="comment">//向左递归</span></span><br><span class="line">getCodes(node.left, <span class="string">"0"</span>, stringBuilder2);</span><br><span class="line"><span class="comment">//向右递归</span></span><br><span class="line">getCodes(node.right, <span class="string">"1"</span>, stringBuilder2);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line"><span class="comment">//就表示找到某个叶子结点的最后</span></span><br><span class="line">huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.preOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"赫夫曼树为空"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的就是 List 形式   [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]......],</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1创建一个ArrayList</span></span><br><span class="line">ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value]</span></span><br><span class="line">Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">Integer count = counts.get(b);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123; <span class="comment">// Map还没有这个字符数据,第一次</span></span><br><span class="line">counts.put(b, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把每一个键值对转成一个Node 对象，并加入到nodes集合</span></span><br><span class="line"><span class="comment">//遍历map</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry: counts.entrySet()) &#123;</span><br><span class="line">nodes.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nodes;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过List 创建对应的赫夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//排序, 从小到大</span></span><br><span class="line">Collections.sort(nodes);</span><br><span class="line"><span class="comment">//取出第一颗最小的二叉树</span></span><br><span class="line">Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//取出第二颗最小的二叉树</span></span><br><span class="line">Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//创建一颗新的二叉树,它的根节点 没有data, 只有权值</span></span><br><span class="line">Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">parent.left = leftNode;</span><br><span class="line">parent.right = rightNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将已经处理的两颗二叉树从nodes删除</span></span><br><span class="line">nodes.remove(leftNode);</span><br><span class="line">nodes.remove(rightNode);</span><br><span class="line"><span class="comment">//将新的二叉树，加入到nodes</span></span><br><span class="line">nodes.add(parent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nodes 最后的结点，就是赫夫曼树的根结点</span></span><br><span class="line"><span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node ,待数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;  </span>&#123;</span><br><span class="line">Byte data; <span class="comment">// 存放数据(字符)本身，比如'a' =&gt; 97 ' ' =&gt; 32</span></span><br><span class="line"><span class="keyword">int</span> weight; <span class="comment">//权值, 表示字符出现的次数</span></span><br><span class="line">Node left;<span class="comment">//</span></span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line"><span class="keyword">this</span>.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 从小到大排序</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [data = "</span> + data + <span class="string">" weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-赫夫曼编码压缩文件注意事项"><a href="#3-9-赫夫曼编码压缩文件注意事项" class="headerlink" title="3.9 赫夫曼编码压缩文件注意事项"></a>3.9 赫夫曼编码压缩文件注意事项</h3><p>1）如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化，比如视频，ppt等等文件<br>[举例压一个.ppt]<br>2）赫夫曼编码是按字节来处理的，因此可以处理所有的文件（二进制文件、文本文件）[举例压一个.xml文件]<br>3）如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显.    </p><h2 id="4-二又排序树"><a href="#4-二又排序树" class="headerlink" title="4.二又排序树"></a>4.二又排序树</h2><h3 id="4-1-先看一个需求"><a href="#4-1-先看一个需求" class="headerlink" title="4.1 先看一个需求"></a>4.1 先看一个需求</h3><p>给你一个数列（7，3，10，12，5，1，9），要求能够高效的完成对数据的查询和添加  </p><h3 id="4-2-解决方案分析"><a href="#4-2-解决方案分析" class="headerlink" title="4.2 解决方案分析"></a>4.2 解决方案分析</h3><h4 id="4-2-1-使用数组"><a href="#4-2-1-使用数组" class="headerlink" title="4.2.1 使用数组"></a>4.2.1 使用数组</h4><p>数组未排序，优点：直接在数组尾添加，速度快。缺点：查找速度慢.[示意图]<br>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。[示意图]  </p><h4 id="4-2-2-使用链式存储-链表"><a href="#4-2-2-使用链式存储-链表" class="headerlink" title="4.2.2 使用链式存储-链表"></a>4.2.2 使用链式存储-链表</h4><p>不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。[示意图]</p><h4 id="4-2-3-使用二叉排序树"><a href="#4-2-3-使用二叉排序树" class="headerlink" title="4.2.3 使用二叉排序树"></a>4.2.3 使用二叉排序树</h4><h3 id="4-3-二又排序树介绍"><a href="#4-3-二又排序树介绍" class="headerlink" title="4.3 二又排序树介绍"></a>4.3 二又排序树介绍</h3><p><strong>二叉排序树</strong>：BST:（Binary Sort（Search）Tree），对于二又排序树的<strong>任何一个非叶子节点</strong>，要求<strong>左子节点的值比当前节点的值小</strong>，<strong>右子节点的值比当前节点的值大</strong>。<br><strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点<br>比如针对前面的数据（7，3，10，12，5，1，9），对应的二叉排序树为：<br><img src="017.PNG" alt>  </p><h3 id="4-4-二叉排序树创建和遍历"><a href="#4-4-二叉排序树创建和遍历" class="headerlink" title="4.4 二叉排序树创建和遍历"></a>4.4 二叉排序树创建和遍历</h3><p>一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如：数组为Array（7，3，10，12，5，1，9），创建成对应的二叉排序树为：<br><img src="018.PNG" alt>  </p><h3 id="4-5-二叉排序树的删除"><a href="#4-5-二叉排序树的删除" class="headerlink" title="4.5 二叉排序树的删除"></a>4.5 二叉排序树的删除</h3><p>二又排序树的删除情况比较复杂，有下面三种情况需要考虑<br>1）<strong>删除叶子节点</strong>（比如：2，5，9，12）<br>2）删除<strong>只有一颗子树的节点</strong>（比如：1）<br>3）删除<strong>有两颗子树的节点</strong>.（比如：7，3，10）<br>4）操作的思路分析<br><img src="019.PNG" alt> </p><pre><code>//对删除结点的各种情况的思路分析：第一种情况：删除叶子节点（比如：2，5，9，12）思路（1）需求先去找到要删除的结点 targetNode（2）找到targetNode的父结点parent（3）确定targetNode是parent的左子结点还是右子结点（4）根据前面的情况来对应删除左子结点parent.left=null右子结点 parent.right=null；第二种情况：删除只有一颗子树的节点比如1思路（1）需求先去找到要删除的结点 targetNode（2）找到targetNode的父结点parent（3）确定targetNode的子结点是左子结点还是右子结点（4）targetNode是parent的左子结点还是右子结点（5）如果targetNode有左子结点5.1如果targetNode是parent的左子结点parent.left =targetNode.left；5.2如果targetNode是parent的右子结点parent.right=targetNode.left；（6）如果targetNode有右子结点6.1如果targetNode是parent的左子结点parent.left=targetNode.right；6.2如果targetNode是parent的右子结点parent.right=targetNode.right情况三：删除有两颗子树的节点.（比如：7，3，10）思路（1）需求先去找到要删除的结点 targetNode（2）找到targetNode的父结点parent（3）从targetNode的右子树找到最小的结点（4）用一个临时变量，将最小结点的值保存temp=11（5）删除该最小结点（6）targetNode.value=temp</code></pre><h3 id="4-6-二叉排序树删除结点的代码实现："><a href="#4-6-二叉排序树删除结点的代码实现：" class="headerlink" title="4.6 二叉排序树删除结点的代码实现："></a>4.6 二叉排序树删除结点的代码实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line"><span class="comment">//循环的添加结点到二叉排序树</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">System.out.println(<span class="string">"中序遍历二叉排序树~"</span>);</span><br><span class="line">binarySortTree.infixOrder(); <span class="comment">// 1, 3, 5, 7, 9, 10, 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一下删除叶子结点</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    binarySortTree.delNode(<span class="number">12</span>);</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line">    binarySortTree.delNode(<span class="number">5</span>);</span><br><span class="line">    binarySortTree.delNode(<span class="number">10</span>);</span><br><span class="line">    binarySortTree.delNode(<span class="number">2</span>);</span><br><span class="line">    binarySortTree.delNode(<span class="number">3</span>);</span><br><span class="line">   </span><br><span class="line">    binarySortTree.delNode(<span class="number">9</span>);</span><br><span class="line">    binarySortTree.delNode(<span class="number">1</span>);</span><br><span class="line">    binarySortTree.delNode(<span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"root="</span> + binarySortTree.getRoot());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"删除结点后"</span>);</span><br><span class="line">binarySortTree.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找父结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写方法: </span></span><br><span class="line"><span class="comment">//1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">//2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">Node target = node;</span><br><span class="line"><span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line"><span class="keyword">while</span>(target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">target = target.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这时 target就指向了最小结点</span></span><br><span class="line"><span class="comment">//删除最小结点</span></span><br><span class="line">delNode(target.value);</span><br><span class="line"><span class="keyword">return</span> target.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">Node targetNode = search(value);</span><br><span class="line"><span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">Node parent = searchParent(value);</span><br><span class="line"><span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是由子结点</span></span><br><span class="line">parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line"><span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">targetNode.value = minVal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line"><span class="comment">//如果要删除的结点有左子结点 </span></span><br><span class="line"><span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.left;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.left;</span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果要删除的结点有右子结点 </span></span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加结点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = node;<span class="comment">//如果root为空则直接让root指向node</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的结点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 希望删除的结点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到返回该结点，否则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(value == <span class="keyword">this</span>.value) &#123; <span class="comment">//找到就是该结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; <span class="keyword">this</span>.value) &#123;<span class="comment">//如果查找的值小于当前结点，向左子树递归查找</span></span><br><span class="line"><span class="comment">//如果左子结点为空</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left  == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果查找的值不小于当前结点，向右子树递归查找</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找要删除结点的父结点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要找到的结点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是要删除的结点的父结点，如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果当前结点就是要删除的结点的父结点，就返回</span></span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) || </span><br><span class="line">(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空</span></span><br><span class="line"><span class="keyword">if</span>(value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value); <span class="comment">//向左子树递归查找</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value); <span class="comment">//向右子树递归查找</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 没有找到父结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加结点的方法</span></span><br><span class="line"><span class="comment">//递归的形式添加结点，注意需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断传入的结点的值，和当前子树的根结点的值关系</span></span><br><span class="line"><span class="keyword">if</span>(node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="comment">//如果当前结点左子结点为null</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//递归的向左子树添加</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//添加的结点的值大于 当前结点的值</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//递归的向右子树添加</span></span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-平衡二又树（AVL树）"><a href="#5-平衡二又树（AVL树）" class="headerlink" title="5.平衡二又树（AVL树）"></a>5.平衡二又树（AVL树）</h2><h3 id="5-1-看一个案例（说明二又排序树可能的问题）"><a href="#5-1-看一个案例（说明二又排序树可能的问题）" class="headerlink" title="5.1 看一个案例（说明二又排序树可能的问题）"></a>5.1 看一个案例（说明二又排序树可能的问题）</h3><p>给你一个数列{1，2，3，4，5，6}，要求创建一颗二又排序树（BST），并分析问题所在.</p><h4 id="5-1-1-左边BST存在的问题分析："><a href="#5-1-1-左边BST存在的问题分析：" class="headerlink" title="5.1.1 左边BST存在的问题分析："></a>5.1.1 左边BST存在的问题分析：</h4><p>1）左子树全部为空，从形式上看，更像一个单链表.<br>2）插入速度没有影响<br>3）查询速度明显降低（因为需要依次比较），不能发挥BST<br>的优势，因为每次还需要比较左子树，其查询速度比<br>单链表还慢<br>4）解决方案-平衡二叉树（AVL）  </p><h3 id="5-2-基本介绍"><a href="#5-2-基本介绍" class="headerlink" title="5.2 基本介绍"></a>5.2 基本介绍</h3><p>1）平衡二叉树也叫平衡<strong>二叉搜索树</strong>（Self-balancing binary search tree）又被称为AVL树，可以保证查询效率较高。<br>2）具有以下特点：它是一<strong>棵空树</strong>或<strong>它的左右两个子树的高度差的绝对值不超过1</strong>，并且<strong>左右两个子树都是一棵平衡二叉树</strong>。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。<br>3）举例说明，看看下面哪些AVL树，为什么？<br><img src="020.PNG" alt>  </p><h3 id="5-3-应用案例-单旋转（左旋转）"><a href="#5-3-应用案例-单旋转（左旋转）" class="headerlink" title="5.3 应用案例-单旋转（左旋转）"></a>5.3 应用案例-单旋转（左旋转）</h3><p>1）要求：给你一个数列，创建出对应的平衡二叉树.数列{4，3，6，5，7，8}<br>2）思路分析（示意图）<br><img src="021.PNG" alt>  </p><pre><code>//左旋转方法private void leftRotateO{    //创建新的结点，以当前根结点的值Node newNode=new Node（value）；    //把新的结点的左子树设置成当前结点的左子树newNode.left=left；    //把新的结点的右子树设置成带你过去结点的右子树的左子树newNode.right=right.left；    //把当前结点的值替换成右子结点的值value=right.value；    /把当前结点的右子树设置成当前结点右子树的右子树right=right.right；    //把当前结点的左子树（左子结点）设置成新的结点    left= newNode;</code></pre><h3 id="5-4-应用案例-单旋转（右旋转）"><a href="#5-4-应用案例-单旋转（右旋转）" class="headerlink" title="5.4 应用案例-单旋转（右旋转）"></a>5.4 应用案例-单旋转（右旋转）</h3><p>1）要求：给你一个数列，创建出对应的平衡二叉树，数列{10，12，8，9，7，6}<br>2）思路分析（示意图）<br><img src="022.PNG" alt>  </p><pre><code>//右旋转private void rightRotate(){Node newNode=new Node（value）；newNode.right=right；newNode.left=left.right；value=left.value；left=left.left；right=newNode；}</code></pre><h3 id="5-5-应用案例-双旋转"><a href="#5-5-应用案例-双旋转" class="headerlink" title="5.5 应用案例-双旋转"></a>5.5 应用案例-双旋转</h3><p>前面的两个数列，进行单旋转（即一次旋转）就可以将非平衡二又树转成平衡二又树，但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列<br>int[]arr={10，11，7，6，8，9}；运行原来的代码可以看到，并没有转成AVL树.<br>intt]arr={2，1，6，5，7，3}；//运行原来的代码可以看到，并没有转成AVL树<br>1）问题分析<br><img src="023.PNG" alt><br>2）解决思路分析<br>1.当符号右旋转的条件时<br>2.如果它的左子树的右子树高度大于它的左子树的高度<br>3.先对当前这个结点的左节点进行左旋转<br>4.在对当前结点进行右旋转的操作即可<br>3）代码实现[AVL树的汇总代码（完整代码）】  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.avl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int[] arr = &#123;4,3,6,5,7,8&#125;;</span></span><br><span class="line"><span class="comment">//int[] arr = &#123; 10, 12, 8, 9, 7, 6 &#125;;</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;  </span><br><span class="line"><span class="comment">//创建一个 AVLTree对象</span></span><br><span class="line">AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line"><span class="comment">//添加结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">avlTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">System.out.println(<span class="string">"中序遍历"</span>);</span><br><span class="line">avlTree.infixOrder();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"在平衡处理~~"</span>);</span><br><span class="line">System.out.println(<span class="string">"树的高度="</span> + avlTree.getRoot().height()); <span class="comment">//3</span></span><br><span class="line">System.out.println(<span class="string">"树的左子树高度="</span> + avlTree.getRoot().leftHeight()); <span class="comment">// 2</span></span><br><span class="line">System.out.println(<span class="string">"树的右子树高度="</span> + avlTree.getRoot().rightHeight()); <span class="comment">// 2</span></span><br><span class="line">System.out.println(<span class="string">"当前的根结点="</span> + avlTree.getRoot());<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建AVLTree</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找要删除的结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找父结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写方法:</span></span><br><span class="line"><span class="comment">// 1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">// 2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> *            传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">Node target = node;</span><br><span class="line"><span class="comment">// 循环的查找左子节点，就会找到最小值</span></span><br><span class="line"><span class="keyword">while</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">target = target.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时 target就指向了最小结点</span></span><br><span class="line"><span class="comment">// 删除最小结点</span></span><br><span class="line">delNode(target.value);</span><br><span class="line"><span class="keyword">return</span> target.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 1.需求先去找到要删除的结点 targetNode</span></span><br><span class="line">Node targetNode = search(value);</span><br><span class="line"><span class="comment">// 如果没有找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span> (targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去找到targetNode的父结点</span></span><br><span class="line">Node parent = searchParent(value);</span><br><span class="line"><span class="comment">// 如果要删除的结点是叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line"><span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">// 是左子结点</span></span><br><span class="line">parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">// 是由子结点</span></span><br><span class="line">parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">// 删除有两颗子树的节点</span></span><br><span class="line"><span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">targetNode.value = minVal;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line"><span class="comment">// 如果要删除的结点有左子结点</span></span><br><span class="line"><span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.left;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果要删除的结点有右子结点</span></span><br><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加结点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = node;<span class="comment">// 如果root为空则直接让root指向node</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Node结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回左子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回右子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> right.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 以该结点为根结点的树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.max(left == <span class="keyword">null</span> ? <span class="number">0</span> : left.height(), right == <span class="keyword">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左旋转方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新的结点，以当前根结点的值</span></span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"><span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">newNode.left = left;</span><br><span class="line"><span class="comment">//把新的结点的右子树设置成带你过去结点的右子树的左子树</span></span><br><span class="line">newNode.right = right.left;</span><br><span class="line"><span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">value = right.value;</span><br><span class="line"><span class="comment">//把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line">right = right.right;</span><br><span class="line"><span class="comment">//把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line">left = newNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">newNode.right = right;</span><br><span class="line">newNode.left = left.right;</span><br><span class="line">value = left.value;</span><br><span class="line">left = left.left;</span><br><span class="line">right = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找要删除的结点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> *            希望删除的结点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到返回该结点，否则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123; <span class="comment">// 找到就是该结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;<span class="comment">// 如果查找的值小于当前结点，向左子树递归查找</span></span><br><span class="line"><span class="comment">// 如果左子结点为空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果查找的值不小于当前结点，向右子树递归查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找要删除结点的父结点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> *            要找到的结点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是要删除的结点的父结点，如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果当前结点就是要删除的结点的父结点，就返回</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) || (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value); <span class="comment">// 向左子树递归查找</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value); <span class="comment">// 向右子树递归查找</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 没有找到父结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加结点的方法</span></span><br><span class="line"><span class="comment">// 递归的形式添加结点，注意需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断传入的结点的值，和当前子树的根结点的值关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="comment">// 如果当前结点左子结点为null</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 递归的向左子树添加</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 添加的结点的值大于 当前结点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 递归的向右子树添加</span></span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line"><span class="keyword">if</span>(rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line"><span class="keyword">if</span>(right != <span class="keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line"><span class="comment">//先对右子结点进行右旋转</span></span><br><span class="line">right.rightRotate();</span><br><span class="line"><span class="comment">//然后在对当前结点进行左旋转</span></span><br><span class="line">leftRotate(); <span class="comment">//左旋转..</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行左旋转即可</span></span><br><span class="line">leftRotate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ; <span class="comment">//必须要!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line"><span class="keyword">if</span>(leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line"><span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line"><span class="comment">//先对当前结点的左结点(左子树)-&gt;左旋转</span></span><br><span class="line">left.leftRotate();</span><br><span class="line"><span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行右旋转即可</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-堆排序&quot;&gt;&lt;a href=&quot;#1-堆排序&quot; class=&quot;headerlink&quot; title=&quot;1.堆排序&quot;&gt;&lt;/a&gt;1.堆排序&lt;/h2&gt;&lt;h3 id=&quot;1-1-堆排序基本介绍&quot;&gt;&lt;a href=&quot;#1-1-堆排序基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 堆排序基本介绍&quot;&gt;&lt;/a&gt;1.1 堆排序基本介绍&lt;/h3&gt;&lt;p&gt;1）堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为&lt;strong&gt;O(nlogn)&lt;/strong&gt;，它也是不稳定排序。
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树结构实际应用" scheme="https://RuanGuoHui.github.io/tags/%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之树结构的基础部分</title>
    <link href="https://RuanGuoHui.github.io/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/"/>
    <id>https://RuanGuoHui.github.io/2019/07/24/数据结构与算法之树结构的基础部分/</id>
    <published>2019-07-24T05:52:37.000Z</published>
    <updated>2019-07-24T08:23:35.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h2><h3 id="1-1为什么需要树这种数据结构"><a href="#1-1为什么需要树这种数据结构" class="headerlink" title="1.1为什么需要树这种数据结构"></a>1.1为什么需要树这种数据结构</h3><h4 id="1-1-1数组存储方式的分析"><a href="#1-1-1数组存储方式的分析" class="headerlink" title="1.1.1数组存储方式的分析"></a>1.1.1数组存储方式的分析</h4><p><strong>优点</strong>：通过<strong>下标方式访问元素</strong>，速度快。对于有序数组，还可使用<strong>二分查找</strong>提高检索速度。  <a id="more"></a><br><strong>缺点</strong>：如果要检索具体某个值，或者<strong>插入值（按一定顺序）会整体移动</strong>，效率较低[示意图]<br><strong>画出操作示意图：</strong><br><img src="001.PNG" alt>  </p><h4 id="1-1-2链式存储方式的分析"><a href="#1-1-2链式存储方式的分析" class="headerlink" title="1.1.2链式存储方式的分析"></a>1.1.2链式存储方式的分析</h4><p><strong>优点</strong>：在一定程度上对数组存储方式有优化（比如：<strong>插入</strong>一个数值节点，只需要将插入节点，链接到链表中即可，<strong>删除</strong>效率也很好）。  </p><p><strong>缺点</strong>：在进行<strong>检索时</strong>，效率仍然较低，比如（检索某个值，需要从头节点开始遍历）【示意图】<br><strong>操作示意图：</strong><br><img src="002.PNG" alt>  </p><h4 id="1-1-3树存储方式的分析"><a href="#1-1-3树存储方式的分析" class="headerlink" title="1.1.3树存储方式的分析"></a>1.1.3树存储方式的分析</h4><p>能提高数据<strong>存储</strong>，<strong>读取</strong>的效率，比如利用<strong>二叉排序树（Binary Sort Tree）</strong>，既可以保证数据的检索速度，同时也可以保证数据的<strong>插入</strong>，<strong>删除</strong>，<strong>修改</strong>的速度。【示意图，后面详讲】<br><strong>案例</strong>：[7，3，10，1，5，9，12]<br><img src="003.PNG" alt>  </p><h3 id="1-2-树示意图"><a href="#1-2-树示意图" class="headerlink" title="1.2 树示意图"></a>1.2 树示意图</h3><p><img src="004.PNG" alt>  </p><pre><code>树的常用术语（结合示意图理解）：1）节点2）根节点3）父节点4）子节点5）叶子节点（没有子节点的节点）6）节点的权（节点值）7）路径（从root 节点找到该节点的路线）8）层9）子树10）树的高度（最大层数）11）森林：多颗子树构成森林</code></pre><h3 id="1-3-二叉树的概念"><a href="#1-3-二叉树的概念" class="headerlink" title="1.3 二叉树的概念"></a>1.3 二叉树的概念</h3><p>1）树有很多种，每个节点<strong>最多只能有两个子节点</strong>的一种形式称为二叉树。<br>2）二叉树的子节点分为左节点和右节点<br>3）<strong>示意图</strong><br><img src="005.PNG" alt><br>4）如果该二叉树的所有<strong>叶子节点都在最后一层</strong>，并且结点总数=<strong>2^n-1</strong>，n为层数，则我们称为满二叉树。<br><img src="006.PNG" alt><br>5）如果该二叉树的所有<strong>叶子节点</strong>都在最后一层或者<strong>倒数第二层</strong>，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树<br><img src="007.PNG" alt>  </p><h3 id="1-4-二叉树遍历的说明"><a href="#1-4-二叉树遍历的说明" class="headerlink" title="1.4 二叉树遍历的说明"></a>1.4 二叉树遍历的说明</h3><p>使用<strong>前序，中序和后序</strong>对下面的二叉树进行遍历.<br>1）前序遍历：先输出父节点，再遍历左子树和右子树<br>2）中序遍历：先遍历左子树，再输出父节点，再遍历右子树<br>3）后序遍历：先遍历左子树，再遍历右子树，最后输出父节点<br>4）<strong>小结</strong>：看输出父节点的顺序，就确定是前序，中序还是后序  </p><h3 id="1-5-二叉树遍历应用实例（前序，中序，后序）"><a href="#1-5-二叉树遍历应用实例（前序，中序，后序）" class="headerlink" title="1.5 二叉树遍历应用实例（前序，中序，后序）"></a>1.5 二叉树遍历应用实例（前序，中序，后序）</h3><h4 id="1-5-1-应用实例的说明和思路"><a href="#1-5-1-应用实例的说明和思路" class="headerlink" title="1.5.1 应用实例的说明和思路"></a>1.5.1 应用实例的说明和思路</h4><p><img src="008.PNG" alt>  </p><h4 id="1-5-2-代码实现"><a href="#1-5-2-代码实现" class="headerlink" title="1.5.2 代码实现"></a>1.5.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先需要创建一颗二叉树</span></span><br><span class="line">BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line"><span class="comment">//创建需要的结点</span></span><br><span class="line">HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"吴用"</span>);</span><br><span class="line">HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>);</span><br><span class="line">HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">"关胜"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">root.setLeft(node2);</span><br><span class="line">root.setRight(node3);</span><br><span class="line">node3.setRight(node4);</span><br><span class="line">node3.setLeft(node5);</span><br><span class="line">binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">//System.out.println("前序遍历"); // 1,2,3,5,4</span></span><br><span class="line"><span class="comment">//binaryTree.preOrder();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试 </span></span><br><span class="line"><span class="comment">//System.out.println("中序遍历");</span></span><br><span class="line"><span class="comment">//binaryTree.infixOrder(); // 2,1,5,3,4</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//System.out.println("后序遍历");</span></span><br><span class="line"><span class="comment">//binaryTree.postOrder(); // 2,5,4,3,1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="comment">//前序遍历的次数 ：4 </span></span><br><span class="line"><span class="comment">//System.out.println("前序遍历方式~~~");</span></span><br><span class="line"><span class="comment">//HeroNode resNode = binaryTree.preOrderSearch(5);</span></span><br><span class="line"><span class="comment">//if (resNode != null) &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());</span></span><br><span class="line"><span class="comment">//&#125; else &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("没有找到 no = %d 的英雄", 5);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历查找</span></span><br><span class="line"><span class="comment">//中序遍历3次</span></span><br><span class="line"><span class="comment">//System.out.println("中序遍历方式~~~");</span></span><br><span class="line"><span class="comment">//HeroNode resNode = binaryTree.infixOrderSearch(5);</span></span><br><span class="line"><span class="comment">//if (resNode != null) &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());</span></span><br><span class="line"><span class="comment">//&#125; else &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("没有找到 no = %d 的英雄", 5);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历查找</span></span><br><span class="line"><span class="comment">//后序遍历查找的次数  2次</span></span><br><span class="line"><span class="comment">//System.out.println("后序遍历方式~~~");</span></span><br><span class="line"><span class="comment">//HeroNode resNode = binaryTree.postOrderSearch(5);</span></span><br><span class="line"><span class="comment">//if (resNode != null) &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());</span></span><br><span class="line"><span class="comment">//&#125; else &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("没有找到 no = %d 的英雄", 5);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一把删除结点</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"删除前,前序遍历"</span>);</span><br><span class="line">binaryTree.preOrder(); <span class="comment">//  1,2,3,5,4</span></span><br><span class="line">binaryTree.delNode(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//binaryTree.delNode(3);</span></span><br><span class="line">System.out.println(<span class="string">"删除后，前序遍历"</span>);</span><br><span class="line">binaryTree.preOrder(); <span class="comment">// 1,2,3,4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line"><span class="keyword">if</span>(root.getNo() == no) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//递归删除</span></span><br><span class="line">root.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"空树，不能删除~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.preOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.postOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归删除结点</span></span><br><span class="line"><span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line"><span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>); <span class="comment">//先输出父结点</span></span><br><span class="line"><span class="comment">//递归向左子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归向右子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归向左子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出父结点</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//递归向右子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.postOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.postOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-二叉树-查找指定节点要求"><a href="#1-6-二叉树-查找指定节点要求" class="headerlink" title="1.6 二叉树-查找指定节点要求"></a>1.6 二叉树-查找指定节点要求</h3><p>1）请编写前序查找，中序查找和后序查找的方法。<br>2）并分别使用三种查找方式，查找heroNO=5的节点<br>3）并分析各种查找方式，分别比较了多少次<br>4）思路分析图解<br><img src="009.PNG" alt><br>5)代码实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先需要创建一颗二叉树</span></span><br><span class="line">BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line"><span class="comment">//创建需要的结点</span></span><br><span class="line">HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"吴用"</span>);</span><br><span class="line">HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>);</span><br><span class="line">HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">"关胜"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">root.setLeft(node2);</span><br><span class="line">root.setRight(node3);</span><br><span class="line">node3.setRight(node4);</span><br><span class="line">node3.setLeft(node5);</span><br><span class="line">binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">//System.out.println("前序遍历"); // 1,2,3,5,4</span></span><br><span class="line"><span class="comment">//binaryTree.preOrder();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试 </span></span><br><span class="line"><span class="comment">//System.out.println("中序遍历");</span></span><br><span class="line"><span class="comment">//binaryTree.infixOrder(); // 2,1,5,3,4</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//System.out.println("后序遍历");</span></span><br><span class="line"><span class="comment">//binaryTree.postOrder(); // 2,5,4,3,1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="comment">//前序遍历的次数 ：4 </span></span><br><span class="line"><span class="comment">//System.out.println("前序遍历方式~~~");</span></span><br><span class="line"><span class="comment">//HeroNode resNode = binaryTree.preOrderSearch(5);</span></span><br><span class="line"><span class="comment">//if (resNode != null) &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());</span></span><br><span class="line"><span class="comment">//&#125; else &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("没有找到 no = %d 的英雄", 5);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历查找</span></span><br><span class="line"><span class="comment">//中序遍历3次</span></span><br><span class="line"><span class="comment">//System.out.println("中序遍历方式~~~");</span></span><br><span class="line"><span class="comment">//HeroNode resNode = binaryTree.infixOrderSearch(5);</span></span><br><span class="line"><span class="comment">//if (resNode != null) &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());</span></span><br><span class="line"><span class="comment">//&#125; else &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("没有找到 no = %d 的英雄", 5);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历查找</span></span><br><span class="line"><span class="comment">//后序遍历查找的次数  2次</span></span><br><span class="line"><span class="comment">//System.out.println("后序遍历方式~~~");</span></span><br><span class="line"><span class="comment">//HeroNode resNode = binaryTree.postOrderSearch(5);</span></span><br><span class="line"><span class="comment">//if (resNode != null) &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());</span></span><br><span class="line"><span class="comment">//&#125; else &#123;</span></span><br><span class="line"><span class="comment">//System.out.printf("没有找到 no = %d 的英雄", 5);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一把删除结点</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"删除前,前序遍历"</span>);</span><br><span class="line">binaryTree.preOrder(); <span class="comment">//  1,2,3,5,4</span></span><br><span class="line">binaryTree.delNode(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//binaryTree.delNode(3);</span></span><br><span class="line">System.out.println(<span class="string">"删除后，前序遍历"</span>);</span><br><span class="line">binaryTree.preOrder(); <span class="comment">// 1,2,3,4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line"><span class="keyword">if</span>(root.getNo() == no) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//递归删除</span></span><br><span class="line">root.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"空树，不能删除~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.preOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.postOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归删除结点</span></span><br><span class="line"><span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line"><span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>); <span class="comment">//先输出父结点</span></span><br><span class="line"><span class="comment">//递归向左子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归向右子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归向左子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出父结点</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//递归向右子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.postOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.postOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历查找</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> no 查找no</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到就返回该Node ,如果没有找到返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"进入前序遍历"</span>);</span><br><span class="line"><span class="comment">//比较当前结点是不是</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line"><span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;<span class="comment">//说明我们左子树找到</span></span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line"><span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"进入中序查找"</span>);</span><br><span class="line"><span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则继续进行右递归的中序查找</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;<span class="comment">//说明在左子树找到</span></span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果左子树没有找到，则向右子树递归进行后序遍历查找</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"进入后序查找"</span>);</span><br><span class="line"><span class="comment">//如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="1-7-二叉树-删除节点"><a href="#1-7-二叉树-删除节点" class="headerlink" title="1.7 二叉树-删除节点"></a>1.7 二叉树-删除节点</h3><h4 id="1-7-1要求"><a href="#1-7-1要求" class="headerlink" title="1.7.1要求"></a>1.7.1要求</h4><p>1）如果删除的节点是叶子节点，则删除该节点<br>2）如果删除的节点是非叶子节点，则删除该子树.<br>3）测试，删除掉5号叶子节点和3号子树.<br>4）完成删除思路分析<br><img src="010.PNG" alt><br>5）代码实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归删除结点</span></span><br><span class="line"><span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line"><span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/在Binary Tree类增加方法</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> delNode（<span class="keyword">int</span> no）&#123;</span><br><span class="line"><span class="keyword">if</span>(root！=<span class="keyword">null</span>）&#123;</span><br><span class="line"><span class="comment">//如果只有一个root结点，这里立即判断root是不是就是要删除结点if（root.getNo()==no）&#123;</span></span><br><span class="line">root=<span class="keyword">null</span>；</span><br><span class="line">&#125;<span class="keyword">else</span>（</span><br><span class="line"><span class="comment">//递归删除</span></span><br><span class="line">root.delNode（no）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.printin（“空树，不能删除~”）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在BinaryTreeDemo类增加测试代码：</span></span><br><span class="line"><span class="comment">//测试一把删除结点</span></span><br><span class="line">System.out.println（<span class="string">"删除前，前序遍历”）；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">binary Tree.preOrderO；//1，2，3，5，4</span></span><br><span class="line"><span class="string">binary Tree.delNode（5）；</span></span><br><span class="line"><span class="string">//binary Tree.delNode（3）；System.out.printin（"</span>删除后，前序遍历”）；binary Tree.preOrderO；<span class="comment">//1，2，3，4</span></span><br></pre></td></tr></table></figure><h3 id="1-8-二叉树-删除节点"><a href="#1-8-二叉树-删除节点" class="headerlink" title="1.8 二叉树-删除节点"></a>1.8 二叉树-删除节点</h3><p>思考题（课后练习）<br>1）如果要删除的节点是非叶子节点，现在我们不希望将该非叶子节点为根节点的子树删除，需要指定规则，假如规定如下：<br>2）如果该非叶子节点A只有一个子节点B，则子节点B替代节点A<br>3）如果该非叶子节点A有左子节点B和右子节点C，则让左子节点B替代节点A。<br>4）请大家思考，如何完成该删除功能，老师给出提示.（课后练习）<br>5）后面在讲解二叉排序树时，在给大家讲解具体的删除方法<br><img src="011.PNG" alt>  </p><h2 id="2-顺序存储二叉树"><a href="#2-顺序存储二叉树" class="headerlink" title="2.顺序存储二叉树"></a>2.顺序存储二叉树</h2><h3 id="2-1-顺序存储二又树的概念"><a href="#2-1-顺序存储二又树的概念" class="headerlink" title="2.1 顺序存储二又树的概念"></a>2.1 顺序存储二又树的概念</h3><h4 id="2-1-1-基本说明"><a href="#2-1-1-基本说明" class="headerlink" title="2.1.1 基本说明"></a>2.1.1 基本说明</h4><p>从数据存储来看，数组存储方式和树的存储方式可以相互转换，<strong>即数组可以转换成树，树也可以转换成数组</strong>，看右面的示意图。<br><img src="012.PNG" alt>  </p><h4 id="2-1-2-要求："><a href="#2-1-2-要求：" class="headerlink" title="2.1.2 要求："></a>2.1.2 要求：</h4><p>1）右图的二叉树的结点，要求以数组的方式来存放arr:[1，2，3，4，5，6，6]<br>2）要求在遍历数组arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历  </p><h4 id="2-1-3-顺序存储二叉树的特点："><a href="#2-1-3-顺序存储二叉树的特点：" class="headerlink" title="2.1.3 顺序存储二叉树的特点："></a>2.1.3 顺序存储二叉树的特点：</h4><p>1）顺序二叉树通常只考虑完全二叉树<br>2）第n个元素的左子节点为2<em>n+1<br>3）第n个元素的右子节点为2</em>n+2<br>4）第n个元素的父节点为（n-1）/2<br>5）n：表示二叉树中的第几个元素（按0开始编号如图所示）  </p><h3 id="2-2-顺序存储二叉树遍历"><a href="#2-2-顺序存储二叉树遍历" class="headerlink" title="2.2 顺序存储二叉树遍历"></a>2.2 顺序存储二叉树遍历</h3><p>需求：给你一个数组{1，2，3，4，5，6，7}，要求以二叉树前序遍历的方式进行遍历。前序遍历的结果应当为1，2，4，5，3，6，7<br><strong>代码实现</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="comment">//创建一个 ArrBinaryTree</span></span><br><span class="line">ArrBinaryTree arrBinaryTree = <span class="keyword">new</span> ArrBinaryTree(arr);</span><br><span class="line">arrBinaryTree.preOrder(); <span class="comment">// 1,2,4,5,3,6,7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个ArrayBinaryTree, 实现顺序存储二叉树遍历</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存储数据结点的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.arr = arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载preOrder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个方法，完成顺序存储二叉树的前序遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 数组的下标 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果数组为空，或者 arr.length = 0</span></span><br><span class="line"><span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"数组为空，不能按照二叉树的前序遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出当前这个元素</span></span><br><span class="line">System.out.println(arr[index]); </span><br><span class="line"><span class="comment">//向左递归遍历</span></span><br><span class="line"><span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">preOrder(<span class="number">2</span> * index + <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向右递归遍历</span></span><br><span class="line"><span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-顺序存储二又树应用实例"><a href="#2-3-顺序存储二又树应用实例" class="headerlink" title="2.3 顺序存储二又树应用实例"></a>2.3 顺序存储二又树应用实例</h3><p>八大排序算法中的堆排序，就会使用到顺序存储二叉树，关于堆排序，我们放在&lt;&lt;<strong>树结构实际应用</strong>&gt;&gt;章节讲解。</p><h2 id="3-线索化二叉树"><a href="#3-线索化二叉树" class="headerlink" title="3.线索化二叉树"></a>3.线索化二叉树</h2><h3 id="3-1-先看一个问题"><a href="#3-1-先看一个问题" class="headerlink" title="3.1 先看一个问题"></a>3.1 先看一个问题</h3><p>将数列{1，3，6，8，10，14}构建成一颗二叉树.n+1=7<br><img src="013.PNG" alt><br>问题分析：<br>1）当我们对上面的二叉树进行中序遍历时，数列为{8，3，10，1，6，14}<br>2）但是6，8，10，14这几个节点的左右指针，并没有完全的利用上.<br>3）如果我们希望充分的利用各个节点的左右指针，让各个节点可以指向自  己的前后节点，怎么办？<br>4）解决方案-<strong>线索二叉树</strong>   </p><h3 id="3-2-线索二又树基本介绍"><a href="#3-2-线索二又树基本介绍" class="headerlink" title="3.2 线索二又树基本介绍"></a>3.2 线索二又树基本介绍</h3><p>1）n个结点的二叉链表中含有n+1【公式2n-（n-1）=n+1】个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）<br>2）这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（Threaded BinaryTree）。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种<br>3）一个结点的前一个结点，称为<strong>前驱</strong>结点<br>4）一个结点的后一个结点，称为后继结点  </p><h3 id="3-3-线索二又树应用案例"><a href="#3-3-线索二又树应用案例" class="headerlink" title="3.3 线索二又树应用案例"></a>3.3 线索二又树应用案例</h3><p>应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为{8，3，10，1，14，6}<br><img src="014.PNG" alt><br>思路分析：中序遍历的结果：（8，3，10，1，14，6}<br><img src="015.PNG" alt>  </p><h4 id="3-3-1-说明：当线索化二叉树后，Node节点的属性left和right，有如下情况："><a href="#3-3-1-说明：当线索化二叉树后，Node节点的属性left和right，有如下情况：" class="headerlink" title="3.3.1 说明：当线索化二叉树后，Node节点的属性left和right，有如下情况："></a>3.3.1 说明：当线索化二叉树后，Node节点的属性left和right，有如下情况：</h4><p>1）left指向的是左子树，也可能是指向的前驱节点.比如①节点left指向的左子树，而①节点的left指向的就是前驱节点.<br>2）right指向的是右子树，也可能是指向后继节点，比如①节点right指向的是右子树，而①节点的right指向的是后继节点.  </p><h4 id="3-3-2代码实现："><a href="#3-3-2代码实现：" class="headerlink" title="3.3.2代码实现："></a>3.3.2代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.tree.threadedbinarytree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试一把中序线索二叉树的功能</span></span><br><span class="line">HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"tom"</span>);</span><br><span class="line">HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"jack"</span>);</span><br><span class="line">HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">"smith"</span>);</span><br><span class="line">HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">"mary"</span>);</span><br><span class="line">HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">"king"</span>);</span><br><span class="line">HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">"dim"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span></span><br><span class="line">root.setLeft(node2);</span><br><span class="line">root.setRight(node3);</span><br><span class="line">node2.setLeft(node4);</span><br><span class="line">node2.setRight(node5);</span><br><span class="line">node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试中序线索化</span></span><br><span class="line">ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">threadedBinaryTree.setRoot(root);</span><br><span class="line">threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试: 以10号节点测试</span></span><br><span class="line">HeroNode leftNode = node5.getLeft();</span><br><span class="line">HeroNode rightNode = node5.getRight();</span><br><span class="line">System.out.println(<span class="string">"10号结点的前驱结点是 ="</span>  + leftNode); <span class="comment">//3</span></span><br><span class="line">System.out.println(<span class="string">"10号结点的后继结点是="</span>  + rightNode); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当线索化二叉树后，能在使用原来的遍历方法</span></span><br><span class="line"><span class="comment">//threadedBinaryTree.infixOrder();</span></span><br><span class="line">System.out.println(<span class="string">"使用线索化的方式遍历 线索化二叉树"</span>);</span><br><span class="line">threadedBinaryTree.threadedList(); <span class="comment">// 8, 3, 10, 1, 14, 6</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义ThreadedBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了实现线索化，需要创建要给指向当前结点的前驱结点的指针</span></span><br><span class="line"><span class="comment">//在递归进行线索化时，pre 总是保留前一个结点</span></span><br><span class="line"><span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载一把threadedNodes方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.threadedNodes(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">HeroNode node = root;</span><br><span class="line"><span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//循环的找到leftType == 1的结点，第一个找到就是8结点</span></span><br><span class="line"><span class="comment">//后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化</span></span><br><span class="line"><span class="comment">//处理后的有效结点</span></span><br><span class="line"><span class="keyword">while</span>(node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">node = node.getLeft();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印当前这个结点</span></span><br><span class="line">System.out.println(node);</span><br><span class="line"><span class="comment">//如果当前结点的右指针指向的是后继结点,就一直输出</span></span><br><span class="line"><span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//获取到当前结点的后继结点</span></span><br><span class="line">node = node.getRight();</span><br><span class="line">System.out.println(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//替换这个遍历的结点</span></span><br><span class="line">node = node.getRight();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写对二叉树进行中序线索化的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 就是当前需要线索化的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果node==null, 不能线索化</span></span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(一)先线索化左子树</span></span><br><span class="line">threadedNodes(node.getLeft());</span><br><span class="line"><span class="comment">//(二)线索化当前结点[有难度]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line"><span class="comment">//以8结点来理解</span></span><br><span class="line"><span class="comment">//8结点的.left = null , 8结点的.leftType = 1</span></span><br><span class="line"><span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//让当前结点的左指针指向前驱结点 </span></span><br><span class="line">node.setLeft(pre); </span><br><span class="line"><span class="comment">//修改当前结点的左指针的类型,指向前驱结点</span></span><br><span class="line">node.setLeftType(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理后继结点</span></span><br><span class="line"><span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//让前驱结点的右指针指向当前结点</span></span><br><span class="line">pre.setRight(node);</span><br><span class="line"><span class="comment">//修改前驱结点的右指针类型</span></span><br><span class="line">pre.setRightType(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">pre = node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(三)在线索化右子树</span></span><br><span class="line">threadedNodes(node.getRight());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line"><span class="keyword">if</span>(root.getNo() == no) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//递归删除</span></span><br><span class="line">root.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"空树，不能删除~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.preOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.postOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点</span></span><br><span class="line"><span class="comment">//2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> leftType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rightType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归删除结点</span></span><br><span class="line"><span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line"><span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>); <span class="comment">//先输出父结点</span></span><br><span class="line"><span class="comment">//递归向左子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归向右子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归向左子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出父结点</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//递归向右子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.postOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.postOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历查找</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> no 查找no</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到就返回该Node ,如果没有找到返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"进入前序遍历"</span>);</span><br><span class="line"><span class="comment">//比较当前结点是不是</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line"><span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;<span class="comment">//说明我们左子树找到</span></span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line"><span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"进入中序查找"</span>);</span><br><span class="line"><span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则继续进行右递归的中序查找</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;<span class="comment">//说明在左子树找到</span></span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果左子树没有找到，则向右子树递归进行后序遍历查找</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"进入后序查找"</span>);</span><br><span class="line"><span class="comment">//如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-遍历线索化二叉树"><a href="#3-4-遍历线索化二叉树" class="headerlink" title="3.4 遍历线索化二叉树"></a>3.4 遍历线索化二叉树</h3><p>1）说明：对前面的中序线索化的二叉树，进行遍历<br>2）分析：因为线索化后，<strong>各个结点指向有变化，因此原来的遍历方式不能使用</strong>，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。遍历的次序应当和中序遍历保持一致。<br>3）代码：  </p><pre><code class="java"><span class="comment">//遍历线索化二叉树的方法</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>{    <span class="comment">//定义一个变量，存储当前遍历的结点，从root开始</span>    HeroNode node = root;    <span class="keyword">while</span>(node != <span class="keyword">null</span>) {        <span class="comment">//循环的找到leftType == 1的结点，第一个找到就是8结点</span>        <span class="comment">//后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化</span>        <span class="comment">//处理后的有效结点</span>        <span class="keyword">while</span>(node.getLeftType() == <span class="number">0</span>) {            node = node.getLeft();        }        <span class="comment">//打印当前这个结点</span>        System.out.println(node);        <span class="comment">//如果当前结点的右指针指向的是后继结点,就一直输出</span>        <span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>) {            <span class="comment">//获取到当前结点的后继结点</span>            node = node.getRight();            System.out.println(node);        }        <span class="comment">//替换这个遍历的结点</span>        node = node.getRight();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-二叉树&quot;&gt;&lt;a href=&quot;#1-二叉树&quot; class=&quot;headerlink&quot; title=&quot;1.二叉树&quot;&gt;&lt;/a&gt;1.二叉树&lt;/h2&gt;&lt;h3 id=&quot;1-1为什么需要树这种数据结构&quot;&gt;&lt;a href=&quot;#1-1为什么需要树这种数据结构&quot; class=&quot;headerlink&quot; title=&quot;1.1为什么需要树这种数据结构&quot;&gt;&lt;/a&gt;1.1为什么需要树这种数据结构&lt;/h3&gt;&lt;h4 id=&quot;1-1-1数组存储方式的分析&quot;&gt;&lt;a href=&quot;#1-1-1数组存储方式的分析&quot; class=&quot;headerlink&quot; title=&quot;1.1.1数组存储方式的分析&quot;&gt;&lt;/a&gt;1.1.1数组存储方式的分析&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：通过&lt;strong&gt;下标方式访问元素&lt;/strong&gt;，速度快。对于有序数组，还可使用&lt;strong&gt;二分查找&lt;/strong&gt;提高检索速度。
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树的基础部分" scheme="https://RuanGuoHui.github.io/tags/%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之哈希表</title>
    <link href="https://RuanGuoHui.github.io/2019/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://RuanGuoHui.github.io/2019/07/23/数据结构与算法之哈希表/</id>
    <published>2019-07-23T01:29:15.000Z</published>
    <updated>2019-07-23T02:03:53.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-哈希表（散列）-Google上机题"><a href="#1-哈希表（散列）-Google上机题" class="headerlink" title="1.哈希表（散列）-Google上机题"></a>1.哈希表（散列）-Google上机题</h2><ol><li>看一个实际需求，google公司的一个上机题：</li><li>有一个公司，当有新的员工来报道时，要求将该员工的信息加入（id，性别，年龄，住址.），当输入该员工的id时，要求查找到该员工的所有信息.<a id="more"></a></li><li>要求：不使用数据库，尽量节省内存，速度越快越好=&gt;哈希表（散列）</li></ol><h2 id="2-哈希表的基本介绍"><a href="#2-哈希表的基本介绍" class="headerlink" title="2.哈希表的基本介绍"></a>2.哈希表的基本介绍</h2><p>散列表（Hashtable，也叫哈希表），是根据关键码值（Key value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br><img src="001.PNG" alt>  </p><h2 id="3-google公司的一个上机题："><a href="#3-google公司的一个上机题：" class="headerlink" title="3.google公司的一个上机题："></a>3.google公司的一个上机题：</h2><p>有一个公司，当有新的员工来报道时，要求将该员工的信息加入（id，性别，年龄，名字，住址.），当输入该员工的id时，要求查找到该员工的所有信息.<br><strong>要求：</strong></p><ol><li>不使用数据库，速度越快越好=&gt;哈希表（散列）</li><li>添加时，保证按照id从低到高插入[课后思考：<strong>如果id不是从低到高插入</strong>，但要求各条链表仍是从低到高，怎么解决？]</li><li>使用链表来实现哈希表，该链表不带表头[即：链表的第一个结点就存放雇员信息]</li><li>思路分析并画出示意图<img src="002.PNG" alt></li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.hashtab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTabDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建哈希表</span></span><br><span class="line">HashTab hashTab = <span class="keyword">new</span> HashTab(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个简单的菜单</span></span><br><span class="line">String key = <span class="string">""</span>;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"add:  添加雇员"</span>);</span><br><span class="line">System.out.println(<span class="string">"list: 显示雇员"</span>);</span><br><span class="line">System.out.println(<span class="string">"find: 查找雇员"</span>);</span><br><span class="line">System.out.println(<span class="string">"exit: 退出系统"</span>);</span><br><span class="line"></span><br><span class="line">key = scanner.next();</span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">System.out.println(<span class="string">"输入id"</span>);</span><br><span class="line"><span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">"输入名字"</span>);</span><br><span class="line">String name = scanner.next();</span><br><span class="line"><span class="comment">//创建 雇员</span></span><br><span class="line">Emp emp = <span class="keyword">new</span> Emp(id, name);</span><br><span class="line">hashTab.add(emp);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"list"</span>:</span><br><span class="line">hashTab.list();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"find"</span>:</span><br><span class="line">System.out.println(<span class="string">"请输入要查找的id"</span>);</span><br><span class="line">id = scanner.nextInt();</span><br><span class="line">hashTab.findEmpById(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">scanner.close();</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HashTab 管理多条链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTab</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//表示有多少条链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.size = size;</span><br><span class="line"><span class="comment">//初始化empLinkedListArray</span></span><br><span class="line">empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line"><span class="comment">//？留一个坑, 这时不要分别初始化每个链表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">empLinkedListArray[i] = <span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加雇员</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line"><span class="comment">//根据员工的id ,得到该员工应当添加到哪条链表</span></span><br><span class="line"><span class="keyword">int</span> empLinkedListNO = hashFun(emp.id);</span><br><span class="line"><span class="comment">//将emp 添加到对应的链表中</span></span><br><span class="line">empLinkedListArray[empLinkedListNO].add(emp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历所有的链表,遍历hashtab</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">empLinkedListArray[i].list(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据输入的id,查找雇员</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用散列函数确定到哪条链表查找</span></span><br><span class="line"><span class="keyword">int</span> empLinkedListNO = hashFun(id);</span><br><span class="line">Emp emp = empLinkedListArray[empLinkedListNO].findEmpById(id);</span><br><span class="line"><span class="keyword">if</span>(emp != <span class="keyword">null</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">System.out.printf(<span class="string">"在第%d条链表中找到 雇员 id = %d\n"</span>, (empLinkedListNO + <span class="number">1</span>), id);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"在哈希表中，没有找到该雇员~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写散列函数, 使用一个简单取模法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id % size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示一个雇员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> Emp next; <span class="comment">//next 默认为 null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建EmpLinkedList ,表示链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">//头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp</span></span><br><span class="line"><span class="keyword">private</span> Emp head; <span class="comment">//默认null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加雇员到链表</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大</span></span><br><span class="line"><span class="comment">//   因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果是添加第一个雇员</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">head = emp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后</span></span><br><span class="line">Emp curEmp = head;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明到链表最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curEmp = curEmp.next; <span class="comment">//后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出时直接将emp 加入链表</span></span><br><span class="line">curEmp.next = emp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链表的雇员信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123; <span class="comment">//说明链表为空</span></span><br><span class="line">System.out.println(<span class="string">"第 "</span>+(no+<span class="number">1</span>)+<span class="string">" 链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">"第 "</span>+(no+<span class="number">1</span>)+<span class="string">" 链表的信息为"</span>);</span><br><span class="line">Emp curEmp = head; <span class="comment">//辅助指针</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">" =&gt; id=%d name=%s\t"</span>, curEmp.id, curEmp.name);</span><br><span class="line"><span class="keyword">if</span>(curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明curEmp已经是最后结点</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curEmp = curEmp.next; <span class="comment">//后移，遍历</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据id查找雇员</span></span><br><span class="line"><span class="comment">//如果查找到，就返回Emp, 如果没有找到，就返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//辅助指针</span></span><br><span class="line">Emp curEmp = head;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(curEmp.id == id) &#123;<span class="comment">//找到</span></span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//这时curEmp就指向要查找的雇员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出</span></span><br><span class="line"><span class="keyword">if</span>(curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明遍历当前链表没有找到该雇员</span></span><br><span class="line">curEmp = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curEmp = curEmp.next;<span class="comment">//以后</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> curEmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-哈希表（散列）-Google上机题&quot;&gt;&lt;a href=&quot;#1-哈希表（散列）-Google上机题&quot; class=&quot;headerlink&quot; title=&quot;1.哈希表（散列）-Google上机题&quot;&gt;&lt;/a&gt;1.哈希表（散列）-Google上机题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;看一个实际需求，google公司的一个上机题：&lt;/li&gt;
&lt;li&gt;有一个公司，当有新的员工来报道时，要求将该员工的信息加入（id，性别，年龄，住址.），当输入该员工的id时，要求查找到该员工的所有信息.
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="https://RuanGuoHui.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之查找算法</title>
    <link href="https://RuanGuoHui.github.io/2019/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://RuanGuoHui.github.io/2019/07/22/数据结构与算法之查找算法/</id>
    <published>2019-07-22T01:32:42.000Z</published>
    <updated>2019-07-22T03:38:37.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查找算法介绍"><a href="#1-查找算法介绍" class="headerlink" title="1.查找算法介绍"></a>1.查找算法介绍</h2><p>在java中，我们常用的查找有四种：  </p><ol><li>顺序（线性）查找</li><li>二分查找/折半查找  <a id="more"></a></li><li>插值查找  </li><li>斐波那契查找  <h2 id="2-线性查找算法"><a href="#2-线性查找算法" class="headerlink" title="2.线性查找算法"></a>2.线性查找算法</h2>有一个数列：{1.8，10，89，1000，1234}，判断数列中是否包含此名称【顺序查找】要求：如果找到了，就提示找到，并给出下标值。  </li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">9</span>, <span class="number">11</span>, -<span class="number">1</span>, <span class="number">34</span>, <span class="number">89</span> &#125;;<span class="comment">// 没有顺序的数组</span></span><br><span class="line"><span class="keyword">int</span> index = seqSearch(arr, -<span class="number">11</span>);</span><br><span class="line"><span class="keyword">if</span>(index == -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"没有找到到"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"找到，下标为="</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里我们实现的线性查找是找到一个满足条件的值，就返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线性查找是逐一比对，发现有相同值，就返回下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] == value) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-二分查找算法"><a href="#3-二分查找算法" class="headerlink" title="3.二分查找算法"></a>3.二分查找算法</h2><h3 id="3-1-二分查找："><a href="#3-1-二分查找：" class="headerlink" title="3.1 二分查找："></a>3.1 二分查找：</h3><p>  请对一个有序数组进行二分查找{1，8，10，89，1000，1234}，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”“没有这个数”。  </p><h3 id="3-2二分查找算法的思路"><a href="#3-2二分查找算法的思路" class="headerlink" title="3.2二分查找算法的思路"></a>3.2二分查找算法的思路</h3><p><img src="001.PNG" alt>  </p><h3 id="3-3二分查找的代码"><a href="#3-3二分查找的代码" class="headerlink" title="3.3二分查找的代码"></a>3.3二分查找的代码</h3><p>说明：增加了找到所有的满足条件的元素下标：<br>课后思考题：{1，8，10，89，1000，1000，1234}当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的1000.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：使用二分查找的前提是 该数组是有序的.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;;</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> , <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int resIndex = binarySearch(arr, 0, arr.length - 1, 1000);</span></span><br><span class="line"><span class="comment">//System.out.println("resIndex=" + resIndex);</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; resIndexList = binarySearch2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"resIndexList="</span> + resIndexList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找算法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> *            数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> *            左边的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> *            右边的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> findVal</span></span><br><span class="line"><span class="comment"> *            要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到就返回下标，如果没有找到，就返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成一个课后思考题:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，</span></span><br><span class="line"><span class="comment"> * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路分析</span></span><br><span class="line"><span class="comment"> * 1. 在找到mid 索引值，不要马上返回</span></span><br><span class="line"><span class="comment"> * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment"> * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment"> * 4. 将Arraylist返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"hello~"</span>);</span><br><span class="line"><span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch2(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch2(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// * 思路分析</span></span><br><span class="line"><span class="comment">// * 1. 在找到mid 索引值，不要马上返回</span></span><br><span class="line"><span class="comment">// * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">// * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">// * 4. 将Arraylist返回</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; resIndexlist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="keyword">int</span> temp = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; <span class="number">0</span> || arr[temp] != findVal) &#123;<span class="comment">//退出</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则，就temp 放入到 resIndexlist</span></span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp -= <span class="number">1</span>; <span class="comment">//temp左移</span></span><br><span class="line">&#125;</span><br><span class="line">resIndexlist.add(mid);  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">temp = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &gt; arr.length - <span class="number">1</span> || arr[temp] != findVal) &#123;<span class="comment">//退出</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则，就temp 放入到 resIndexlist</span></span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp += <span class="number">1</span>; <span class="comment">//temp右移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resIndexlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-插值查找算法"><a href="#4-插值查找算法" class="headerlink" title="4.插值查找算法"></a>4.插值查找算法</h2><p>1）插值查找原理介绍：<br>插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。<br>2）将折半查找中的求mid索引的公式，low表示左边索引left，high 表示右边索引right.key 就是前面我们讲的findVal<br><img src="002.PNG" alt><br>3）int mid=low+（high-low）<em>（key-arr[low]）/（arr[high]-arr[low]）；/*插值索引</em>/<br>对应前面的代码公式：<br>int mid=left+（right-left）*（findVal-arr[left]）/（arrlright]-arr[left]）<br>4）举例说明插值查找算法1-100的数组<br><img src="003.PNG" alt></p><h2 id="4-1插值查找应用案例："><a href="#4-1插值查找应用案例：" class="headerlink" title="4.1插值查找应用案例："></a>4.1插值查找应用案例：</h2><p>请对一个有序数组进行插值查找{1，8，10，89，1000，1234}，输入一个数看看该数组是否存在此<br>数，并且求出下标，如果没有就提示“没有这个数”。<br>代码实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertValueSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int [] arr = new int[100];</span></span><br><span class="line"><span class="comment">//for(int i = 0; i &lt; 100; i++) &#123;</span></span><br><span class="line"><span class="comment">//arr[i] = i + 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>,<span class="number">1000</span>,<span class="number">1000</span>, <span class="number">1234</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1234</span>);</span><br><span class="line"><span class="comment">//int index = binarySearch(arr, 0, arr.length, 1);</span></span><br><span class="line">System.out.println(<span class="string">"index = "</span> + index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"二分查找被调用~"</span>);</span><br><span class="line"><span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写插值查找算法</span></span><br><span class="line"><span class="comment">//说明：插值查找算法，也要求数组是有序的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> findVal 查找值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到，就返回对应的下标，如果没有找到，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"插值查找次数~~"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span></span><br><span class="line"><span class="comment">//否则我们得到的 mid 可能越界</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出mid, 自适应</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"><span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 说明应该向右边递归</span></span><br><span class="line"><span class="keyword">return</span> insertValueSearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 说明向左递归查找</span></span><br><span class="line"><span class="keyword">return</span> insertValueSearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-插值查找注意事项："><a href="#4-2-插值查找注意事项：" class="headerlink" title="4.2 插值查找注意事项："></a>4.2 插值查找注意事项：</h3><ol><li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快.</li><li>关键字分布不均匀的情况下，该方法不一定比折半查找要好<h2 id="5-斐波那契（黄金分割法）查找算法"><a href="#5-斐波那契（黄金分割法）查找算法" class="headerlink" title="5.斐波那契（黄金分割法）查找算法"></a>5.斐波那契（黄金分割法）查找算法</h2><h3 id="5-1斐波那契（黄金分割法）查找基本介绍："><a href="#5-1斐波那契（黄金分割法）查找基本介绍：" class="headerlink" title="5. 1斐波那契（黄金分割法）查找基本介绍："></a>5. 1斐波那契（黄金分割法）查找基本介绍：</h3></li><li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。</li><li>斐波那契数列{1，1，2，3，5，8，13，21，34，55}发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值<h3 id="5-2-斐波那契（黄金分割法）原理："><a href="#5-2-斐波那契（黄金分割法）原理：" class="headerlink" title="5.2 斐波那契（黄金分割法）原理："></a>5.2 斐波那契（黄金分割法）原理：</h3>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F（k-1）-1（F代表斐波那契数列），如下图所示<br><img src="004.PNG" alt>  <h4 id="5-2-1对F（k-1）-1的理解："><a href="#5-2-1对F（k-1）-1的理解：" class="headerlink" title="5.2.1对F（k-1）-1的理解："></a>5.2.1对F（k-1）-1的理解：</h4></li><li>由斐波那契数列F[k]=F[k-1]+F[k-2]的性质，可以得到（F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1。该式说明：  只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。从而中间位置为mid=low+F（k-1）-1</li><li>类似的，每一子段也可以用相同的方式分割</li><li>但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到，顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。<br>while（n&gt;fib（k）-1）<br>k++；  <h3 id="5-3斐波那契查找应用案例："><a href="#5-3斐波那契查找应用案例：" class="headerlink" title="5.3斐波那契查找应用案例："></a>5.3斐波那契查找应用案例：</h3>请对一个<strong>有序数组</strong>进行斐波那契查找{1，8，10，89，1000，1234}，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。  </li></ol><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"index="</span> + fibSearch(arr, <span class="number">189</span>));<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span></span><br><span class="line"><span class="comment">//非递归方法得到一个斐波那契数列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line"><span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写斐波那契查找算法</span></span><br><span class="line"><span class="comment">//使用非递归的方式编写算法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a  数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 我们需要查找的关键码(值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回对应的下标，如果没有-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>; <span class="comment">//存放mid值</span></span><br><span class="line"><span class="keyword">int</span> f[] = fib(); <span class="comment">//获取到斐波那契数列</span></span><br><span class="line"><span class="comment">//获取到斐波那契分割数值的下标</span></span><br><span class="line"><span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line"><span class="comment">//不足的部分会使用0填充</span></span><br><span class="line"><span class="keyword">int</span>[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line"><span class="comment">//实际上需求使用a数组最后的数填充 temp</span></span><br><span class="line"><span class="comment">//举例:</span></span><br><span class="line"><span class="comment">//temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125;  =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">temp[i] = a[high];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用while来循环处理，找到我们的数 key</span></span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123; <span class="comment">// 只要这个条件满足，就可以找</span></span><br><span class="line">mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">//我们应该继续向数组的前面查找(左边)</span></span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//为甚是 k--</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line"><span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line"><span class="comment">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span></span><br><span class="line"><span class="comment">//即 在 f[k-1] 的前面继续查找 k--</span></span><br><span class="line"><span class="comment">//即下次循环 mid = f[k-1-1]-1</span></span><br><span class="line">k--;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">// 我们应该继续向数组的后面查找(右边)</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//为什么是k -=2</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line"><span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line"><span class="comment">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]</span></span><br><span class="line"><span class="comment">//4. 即在f[k-2] 的前面进行查找 k -=2</span></span><br><span class="line"><span class="comment">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span></span><br><span class="line">k -= <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//找到</span></span><br><span class="line"><span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line"><span class="keyword">if</span>(mid &lt;= high) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-查找算法介绍&quot;&gt;&lt;a href=&quot;#1-查找算法介绍&quot; class=&quot;headerlink&quot; title=&quot;1.查找算法介绍&quot;&gt;&lt;/a&gt;1.查找算法介绍&lt;/h2&gt;&lt;p&gt;在java中，我们常用的查找有四种：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序（线性）查找&lt;/li&gt;
&lt;li&gt;二分查找/折半查找
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="查找算法" scheme="https://RuanGuoHui.github.io/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之排序算法</title>
    <link href="https://RuanGuoHui.github.io/2019/07/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://RuanGuoHui.github.io/2019/07/21/数据结构与算法之排序算法/</id>
    <published>2019-07-21T04:41:48.000Z</published>
    <updated>2019-07-21T07:17:48.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-排序算法的介绍"><a href="#1-排序算法的介绍" class="headerlink" title="1.排序算法的介绍"></a>1.排序算法的介绍</h2><p>排序也称排序算法（Sort Algorithm），排序是将一组<strong>数据</strong>，依<strong>指定的顺序</strong>进行<strong>排列的过程</strong>。……  <a id="more"></a></p><h2 id="2-排序的分类："><a href="#2-排序的分类：" class="headerlink" title="2.排序的分类："></a>2.排序的分类：</h2><p>1）内部排序：指将需要处理的所有数据都加载到<strong>内部存储器（内存）</strong>中进行排序。<br>2）外部排序法：<br><strong>数据量过大</strong>，无法全部加载到内存中，需要借助<strong>外部存储（文件等）</strong>进行排序。<br>3）常见的排序算法分类（见右图）：<br><img src="001.PNG" alt></p><h2 id="3-算法的时间复杂度"><a href="#3-算法的时间复杂度" class="headerlink" title="3.算法的时间复杂度"></a>3.算法的时间复杂度</h2><h3 id="3-1度量一个程序（算法）执行时间的两种方法"><a href="#3-1度量一个程序（算法）执行时间的两种方法" class="headerlink" title="3.1度量一个程序（算法）执行时间的两种方法"></a>3.1度量一个程序（算法）执行时间的两种方法</h3><p>1）事后统计的方法<br>这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。<br>2）事前估算的方法<br>通过分析某个算法的时间复杂度来判断哪个算法更优.  </p><h2 id="3-2-时间频度"><a href="#3-2-时间频度" class="headerlink" title="3.2 时间频度"></a>3.2 时间频度</h2><h3 id="3-2-1-基本介绍"><a href="#3-2-1-基本介绍" class="headerlink" title="3.2.1 基本介绍"></a>3.2.1 基本介绍</h3><p>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。<strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为<strong>T（n）</strong>。[举例说明]  </p><h3 id="3-2-2-举例说明-基本案例"><a href="#3-2-2-举例说明-基本案例" class="headerlink" title="3.2.2 举例说明-基本案例"></a>3.2.2 举例说明-基本案例</h3><p>比如计算1-100所有数字之和，我们设计两种算法：<br><img src="002.PNG" alt>  </p><h3 id="3-2-3-举例说明-忽略常数项"><a href="#3-2-3-举例说明-忽略常数项" class="headerlink" title="3.2.3 举例说明-忽略常数项"></a>3.2.3 举例说明-忽略常数项</h3><p><img src="003.PNG" alt><br>结论：<br>1）2n+20和2n随着n变大，执行曲线无限接近，20可以忽略<br>2）3n+10和3n随着n变大，执行曲线无限接近，10可以忽略  </p><h3 id="3-2-4-举例说明-忽略低次项"><a href="#3-2-4-举例说明-忽略低次项" class="headerlink" title="3.2.4 举例说明-忽略低次项"></a>3.2.4 举例说明-忽略低次项</h3><p><img src="005.PNG" alt><br>结论：<br>1）2n<del>2+3n+10和2n</del>2随着n变大，执行曲线无限接近，可以忽略3n+10<br>2）n<del>2+5n+20和n</del>2随着n变大，执行曲线无限接近，可以忽略5n+20</p><h3 id="3-2-5-举例说明-忽略系数"><a href="#3-2-5-举例说明-忽略系数" class="headerlink" title="3.2.5 举例说明-忽略系数"></a>3.2.5 举例说明-忽略系数</h3><p><img src="005.PNG" alt><br>结论：<br>1）随着n值变大，5n<del>2+7n和3n</del>2+2n，执行曲线重合，说明这种情况下，5和3可以忽略。<br>2）而n<del>3+5n和6n</del>3+4n，执行曲线分离，说明多少次方式关键  </p><h3 id="3-3-时间复杂度"><a href="#3-3-时间复杂度" class="headerlink" title="3.3 时间复杂度"></a>3.3 时间复杂度</h3><p>1）一般情况下，<strong>算法中的基本操作语句的重复执行次数是问题规模n的某个函数</strong>，用<strong>T（n）</strong>表示，若有某个辅助函数<strong>f（n）</strong>，使得当<strong>n</strong>趋近于无穷大时，<strong>T（n）/f（n）</strong>的极限值为不等于零的常数，则称f（n）是T（n）的同数量级函数。<br>记作<strong>T（n）=0（f（n）</strong>），称<strong>O（f（n））</strong>为算法的渐进时间复杂度，简称时间复杂度。<br>2）T（n）不同，但时间复杂度可能相同。如：T（n）=n2+7n+6与T（n）=3n2+2n+2它们的T（n）不同，但时间复杂度相同，都为<strong>O（n2）</strong>。<br>3）计算时间复杂度的方法：<br>    <em>用常数*</em>1<strong>代替运行时间中的所有加法常数</strong>T（n）=n2+7n+6=&gt;T（n）=n2+7n+1**<br>    <em>修改后的运行次数函数中，只保留最高阶项*</em>T（n）=n2+7n+1=&gt;T（n）=n2**<br>    <em>去除最高阶项的系数*</em>T（n）=n2=&gt;T（n）=n2=&gt;0（n2）**    </p><h3 id="3-4常见的时间复杂度"><a href="#3-4常见的时间复杂度" class="headerlink" title="3.4常见的时间复杂度"></a>3.4常见的时间复杂度</h3><p>1）常数阶O（1）<br>2）对数阶O（log2n）<br>3）线性阶O（n）<br>4）线性对数阶O（nlog2n）<br>5）平方阶O（n-2）<br>6）立方阶O（n-3）<br>7）k次方阶O（nk）<br>8）指数阶O（2n）<br>常见的时间复杂度对应的图：<br><img src="006.PNG" alt><br>说明： </p><p>1）常见的算法时间复杂度由小到大依次为：O（<strong>1</strong>）&lt;O（<strong>log2n</strong>）&lt;O（<strong>n</strong>）&lt;O（<strong>nlog2n</strong>）&lt;O（<strong>n2</strong>）&lt;O（<strong>n3</strong>）&lt;O（<strong>nk</strong>）&lt;O（<strong>2n</strong>），随着问题规模<strong>n</strong>的不断增大，上述时间复杂度不断增大，算法的执行效率越低<br>2）从图中可见，我们应该尽可能避免使用指数阶的算法  </p><p>1)常数阶O(1)<br><img src="007.PNG" alt><br>2)对数阶O(log2n)<br><img src="008.PNG" alt><br>3)线性阶O(n)<br><img src="009.PNG" alt><br>4)线性对数阶O(nlogN)<br><img src="010.PNG" alt><br>5)平方阶O(n^2)<br><img src="011.PNG" alt><br>6)立方阶O(n^3)，K次方O(n^k)<br>说明：参考上面的O(n^2)去理解就好了O(n^3)相当于n循环，其它的类似</p><h3 id="3-5-平均时间复杂度和最坏时间复杂度"><a href="#3-5-平均时间复杂度和最坏时间复杂度" class="headerlink" title="3.5 平均时间复杂度和最坏时间复杂度"></a>3.5 平均时间复杂度和最坏时间复杂度</h3><p>1）平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。<br>2）最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。<br>3）平均时间复杂度和最坏时间复杂度是否一致，和算法有关（如图：）。<br><img src="012.PNG" alt>  </p><h2 id="4-算法的空间复杂度简介"><a href="#4-算法的空间复杂度简介" class="headerlink" title="4.算法的空间复杂度简介"></a>4.算法的空间复杂度简介</h2><h3 id="4-1基本介绍"><a href="#4-1基本介绍" class="headerlink" title="4.1基本介绍"></a>4.1基本介绍</h3><p>1）类似于时间复杂度的讨论，一个算法的空间复杂度<strong>（Space Complexity）</strong>定义为该算法所耗费的存储空间，它也是问题规模<strong>n</strong>的函数。<br>2）空间复杂度（Space Complexity）是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和<strong>归并排序算法，基数排序</strong>就属于这种情况<br>3）在做算法分析时，主要讨论的是时间复杂度。<strong>从用户使用体验上看，更看重的程序执行的速度</strong>。一些缓存产品（redis，memcache）和算法（基数排序）*<em>本质就是用空间换时间. *</em>  </p><h2 id="5-冒泡排序"><a href="#5-冒泡排序" class="headerlink" title="5.冒泡排序"></a>5.冒泡排序</h2><h3 id="5-1-基本介绍"><a href="#5-1-基本介绍" class="headerlink" title="5.1 基本介绍"></a>5.1 基本介绍</h3><p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），<strong>依次比较相邻元素的值，若发现逆序则交换</strong>，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。<br>优化：<br>因为排序的过程中，各元素不断接近自己的位置，<strong>如果一趟比较下来没有进行过交换，就说明序列有序</strong>，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。（这里说的优化，可以在冒泡排序写好后，在进行）  </p><h3 id="5-2-演示冒泡过程的例子-图解"><a href="#5-2-演示冒泡过程的例子-图解" class="headerlink" title="5.2 演示冒泡过程的例子(图解)"></a>5.2 演示冒泡过程的例子(图解)</h3><p><img src="013.PNG" alt><br>小结上面的图解过程：  </p><p>（1）一共进行数组的大小-1次大的循环<br>（2）每一趟排序的次数在逐渐的减少<br>（3）如果我们发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序。这个就是优化  </p><h3 id="5-3-冒泡排序应用实例"><a href="#5-3-冒泡排序应用实例" class="headerlink" title="5.3 冒泡排序应用实例"></a>5.3 冒泡排序应用实例</h3><p>我们举一个具体的案例来说明冒泡法。我们将五个无序的数：3，9，-1，10，-2使用冒泡排序法将其排成一个从小到大的有序数列。<br><strong>代码实现</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int arr[] = &#123;3, 9, -1, 10, 20&#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//System.out.println("排序前");</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了容量理解，我们把冒泡排序的演变过程，给大家展示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一下冒泡排序的速度O(n^2), 给80000个数据，测试</span></span><br><span class="line"><span class="comment">//创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">80000</span>;i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>)(Math.random() * <span class="number">8000000</span>); <span class="comment">//生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试冒泡排序</span></span><br><span class="line">bubbleSort(arr);</span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序后的时间是="</span> + date2Str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("排序后");</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 第二趟排序，就是将第二大的数排在倒数第二位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt; arr.length - 1 - 1 ; j++) &#123;</span></span><br><span class="line"><span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="comment">if (arr[j] &gt; arr[j + 1]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j + 1];</span></span><br><span class="line"><span class="comment">arr[j + 1] = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第二趟排序后的数组");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 第三趟排序，就是将第三大的数排在倒数第三位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt; arr.length - 1 - 2; j++) &#123;</span></span><br><span class="line"><span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="comment">if (arr[j] &gt; arr[j + 1]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j + 1];</span></span><br><span class="line"><span class="comment">arr[j + 1] = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第三趟排序后的数组");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 第四趟排序，就是将第4大的数排在倒数第4位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt; arr.length - 1 - 3; j++) &#123;</span></span><br><span class="line"><span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="comment">if (arr[j] &gt; arr[j + 1]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j + 1];</span></span><br><span class="line"><span class="comment">arr[j + 1] = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第四趟排序后的数组");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr)); */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将前面额冒泡排序算法，封装成一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 冒泡排序 的时间复杂度 O(n^2), 自己写出</span></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">// 临时变量</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line"><span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//System.out.println("第" + (i + 1) + "趟排序后的数组");</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!flag) &#123; <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">flag = <span class="keyword">false</span>; <span class="comment">// 重置flag!!!, 进行下次判断</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-选择排序"><a href="#6-选择排序" class="headerlink" title="6.选择排序"></a>6.选择排序</h2><h3 id="6-1-基本介绍"><a href="#6-1-基本介绍" class="headerlink" title="6.1 基本介绍"></a>6.1 基本介绍</h3><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p><h3 id="6-2-选择排序思想："><a href="#6-2-选择排序思想：" class="headerlink" title="6.2 选择排序思想："></a>6.2 选择排序思想：</h3><p>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]-arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]-arr[n-1]中选取最小值，与arr[2]交换，…，第i次从ar[i-1]-arr[n-1]中选取最小值，与ar[i-1]交换，，第n-1次从arr[n-2]-arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。</p><h3 id="6-3-选择排序思路分析图"><a href="#6-3-选择排序思路分析图" class="headerlink" title="6.3 选择排序思路分析图"></a>6.3 选择排序思路分析图</h3><p><img src="014.PNG" alt>  </p><h4 id="6-3-1-对一个数组的选择排序再进行讲解"><a href="#6-3-1-对一个数组的选择排序再进行讲解" class="headerlink" title="6.3.1 对一个数组的选择排序再进行讲解"></a>6.3.1 对一个数组的选择排序再进行讲解</h4><p><img src="015.PNG" alt>  </p><h2 id="6-4-选择排序应用实例："><a href="#6-4-选择排序应用实例：" class="headerlink" title="6.4 选择排序应用实例："></a>6.4 选择排序应用实例：</h2><p>有一群牛，颜值分别是101，34，119，1请使用选择排序从低到高进行排序[101，34，119，1]<br><img src="016.PNG" alt><br><strong>代码实现</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int [] arr = &#123;101, 34, 119, 1, -1, 90, 123&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line">selectSort(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("排序后");</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在推导的过程，我们发现了规律，因此，可以使用for来解决</span></span><br><span class="line"><span class="comment">//选择排序时间复杂度是 O(n^2)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> minIndex = i;</span><br><span class="line"><span class="keyword">int</span> min = arr[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">arr[minIndex] = arr[i];</span><br><span class="line">arr[i] = min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("第"+(i+1)+"轮后~~");</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));// 1, 34, 119, 101</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//使用逐步推导的方式来，讲解选择排序</span></span><br><span class="line"><span class="comment">//第1轮</span></span><br><span class="line"><span class="comment">//原始的数组 ： 101, 34, 119, 1</span></span><br><span class="line"><span class="comment">//第一轮排序 :   1, 34, 119, 101</span></span><br><span class="line"><span class="comment">//算法 先简单--》 做复杂， 就是可以把一个复杂的算法，拆分成简单的问题-》逐步解决</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第1轮</span></span><br><span class="line"><span class="comment">int minIndex = 0;</span></span><br><span class="line"><span class="comment">int min = arr[0];</span></span><br><span class="line"><span class="comment">for(int j = 0 + 1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">if (min &gt; arr[j]) &#123; //说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">min = arr[j]; //重置min</span></span><br><span class="line"><span class="comment">minIndex = j; //重置minIndex</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="comment">if(minIndex != 0) &#123;</span></span><br><span class="line"><span class="comment">arr[minIndex] = arr[0];</span></span><br><span class="line"><span class="comment">arr[0] = min;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第1轮后~~");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));// 1, 34, 119, 101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第2轮</span></span><br><span class="line"><span class="comment">minIndex = 1;</span></span><br><span class="line"><span class="comment">min = arr[1];</span></span><br><span class="line"><span class="comment">for (int j = 1 + 1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">min = arr[j]; // 重置min</span></span><br><span class="line"><span class="comment">minIndex = j; // 重置minIndex</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="comment">if(minIndex != 1) &#123;</span></span><br><span class="line"><span class="comment">arr[minIndex] = arr[1];</span></span><br><span class="line"><span class="comment">arr[1] = min;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第2轮后~~");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));// 1, 34, 119, 101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第3轮</span></span><br><span class="line"><span class="comment">minIndex = 2;</span></span><br><span class="line"><span class="comment">min = arr[2];</span></span><br><span class="line"><span class="comment">for (int j = 2 + 1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">min = arr[j]; // 重置min</span></span><br><span class="line"><span class="comment">minIndex = j; // 重置minIndex</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="comment">if (minIndex != 2) &#123;</span></span><br><span class="line"><span class="comment">arr[minIndex] = arr[2];</span></span><br><span class="line"><span class="comment">arr[2] = min;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第3轮后~~");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));// 1, 34, 101, 119 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-插入排序"><a href="#7-插入排序" class="headerlink" title="7.插入排序"></a>7.插入排序</h2><h3 id="7-1插入排序法介绍："><a href="#7-1插入排序法介绍：" class="headerlink" title="7.1插入排序法介绍："></a>7.1插入排序法介绍：</h3><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p><h3 id="7-2插入排序法思想："><a href="#7-2插入排序法思想：" class="headerlink" title="7.2插入排序法思想："></a>7.2插入排序法思想：</h3><p>插入排序（Insertion Sorting）的基本思想是：<strong>把n个待排序的元素看成为一个有序表和一个无序表</strong>，开始时<strong>有序表中只包含一个元素</strong>，无序表中包含有<strong>n-1个元素</strong>，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p><h3 id="7-3插入排序思路图："><a href="#7-3插入排序思路图：" class="headerlink" title="7.3插入排序思路图："></a>7.3插入排序思路图：</h3><p><img src="017.PNG" alt>  </p><h3 id="7-4插入排序法应用实例："><a href="#7-4插入排序法应用实例：" class="headerlink" title="7.4插入排序法应用实例："></a>7.4插入排序法应用实例：</h3><p>有一群小牛，考试成绩分别是101，34，119，1请从小到大排序<br><strong>代码实现：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int[] arr = &#123;101, 34, 119, 1, -1, 89&#125;; </span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"插入排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line">insertSort(arr); <span class="comment">//调用插入排序算法</span></span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> insertVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> insertIndex = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//使用for循环来把代码简化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="comment">//定义待插入的数</span></span><br><span class="line">insertVal = arr[i];</span><br><span class="line">insertIndex = i - <span class="number">1</span>; <span class="comment">// 即arr[1]的前面这个数的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line"><span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line"><span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line"><span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">insertIndex--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line"><span class="comment">// 举例：理解不了，我们一会 debug</span></span><br><span class="line"><span class="comment">//这里我们判断是否需要赋值</span></span><br><span class="line"><span class="keyword">if</span>(insertIndex + <span class="number">1</span> != i) &#123;</span><br><span class="line">arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("第"+i+"轮插入");</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//使用逐步推导的方式来讲解，便利理解</span></span><br><span class="line"><span class="comment">//第1轮 &#123;101, 34, 119, 1&#125;;  =&gt; &#123;34, 101, 119, 1&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//&#123;101, 34, 119, 1&#125;; =&gt; &#123;101,101,119,1&#125;</span></span><br><span class="line"><span class="comment">//定义待插入的数</span></span><br><span class="line"><span class="comment">int insertVal = arr[1];</span></span><br><span class="line"><span class="comment">int insertIndex = 1 - 1; //即arr[1]的前面这个数的下标</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//给insertVal 找到插入的位置</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line"><span class="comment">//2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line"><span class="comment">//3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line"><span class="comment">while(insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex] ) &#123;</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex]</span></span><br><span class="line"><span class="comment">insertIndex--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line"><span class="comment">//举例：理解不了，我们一会 debug</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第1轮插入");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第2轮</span></span><br><span class="line"><span class="comment">insertVal = arr[2];</span></span><br><span class="line"><span class="comment">insertIndex = 2 - 1; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while(insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex] ) &#123;</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex]</span></span><br><span class="line"><span class="comment">insertIndex--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">System.out.println("第2轮插入");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第3轮</span></span><br><span class="line"><span class="comment">insertVal = arr[3];</span></span><br><span class="line"><span class="comment">insertIndex = 3 - 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex]</span></span><br><span class="line"><span class="comment">insertIndex--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">System.out.println("第3轮插入");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr)); */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-希尔排序"><a href="#8-希尔排序" class="headerlink" title="8.希尔排序"></a>8.希尔排序</h2><h3 id="8-1-简单插入排序存在的问题"><a href="#8-1-简单插入排序存在的问题" class="headerlink" title="8.1 简单插入排序存在的问题"></a>8.1 简单插入排序存在的问题</h3><p>我们看简单的插入排序可能存在的问题.<br>数组arr={2，3，4，5，6，1}这时需要插入的数<strong>1（最小）</strong>，这样的过程是：<br>{2，3，4，5，6，6}<br>{2，3，4，5，5，6}<br>{2，3，4，4，5，6}<br>{2，3，3，4，5，6}<br>{2，2，3，4，5，6}<br>{1，2，3，4，5，6}<br><strong>结论</strong>：当<strong>需要插入的数是较小的数时，后移的次数明显增多</strong>，对<strong>效率</strong>有影响.  </p><h3 id="8-2-希尔排序法介绍"><a href="#8-2-希尔排序法介绍" class="headerlink" title="8.2 希尔排序法介绍"></a>8.2 希尔排序法介绍</h3><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种<strong>插入排序</strong>，它是简单插入排序经过改进之后的一个<strong>更高效的版本</strong>，也称为<strong>缩小增量排序</strong>。</p><h3 id="8-3-希尔排序法基本思想"><a href="#8-3-希尔排序法基本思想" class="headerlink" title="8.3 希尔排序法基本思想"></a>8.3 希尔排序法基本思想</h3><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，<strong>当增量减至1时</strong>，整个文件恰被分成一组，算法便终止</p><h3 id="8-4-希尔排序法的示意图"><a href="#8-4-希尔排序法的示意图" class="headerlink" title="8.4 希尔排序法的示意图"></a>8.4 希尔排序法的示意图</h3><p><img src="018.PNG" alt><br><img src="019.PNG" alt>  </p><h3 id="8-5希尔排序法应用实例："><a href="#8-5希尔排序法应用实例：" class="headerlink" title="8.5希尔排序法应用实例："></a>8.5希尔排序法应用实例：</h3><p>有一群小牛，考试成绩分别是{8，9，1，7，2，3，5，4，6，0}请从小到大排序。请分别使用<br>1）希尔排序时，对有序序列在插入时采用<strong>交换法</strong>，并测试排序速度.<br>2）希尔排序时，对有序序列在插入时采用<strong>移动法</strong>，并测试排序速度<br>3）代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int[] arr = &#123; 8, 9, 1, 7, 2, 3, 5, 4, 6, 0 &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//shellSort(arr); //交换式</span></span><br><span class="line">shellSort2(arr);<span class="comment">//移位方式</span></span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用逐步推导的方式来编写希尔排序</span></span><br><span class="line"><span class="comment">// 希尔排序时， 对有序序列在插入时采用交换法, </span></span><br><span class="line"><span class="comment">// 思路(算法) ===&gt; 代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="comment">// 遍历各组中所有的元素(共gap组，每组有个元素), 步长gap</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line"><span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + gap];</span><br><span class="line">arr[j + gap] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//System.out.println("希尔排序第" + (++count) + "轮 =" + Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 希尔排序的第1轮排序</span></span><br><span class="line"><span class="comment">// 因为第1轮排序，是将10个数据分成了 5组</span></span><br><span class="line"><span class="comment">for (int i = 5; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line"><span class="comment">for (int j = i - 5; j &gt;= 0; j -= 5) &#123;</span></span><br><span class="line"><span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">if (arr[j] &gt; arr[j + 5]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j + 5];</span></span><br><span class="line"><span class="comment">arr[j + 5] = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("希尔排序1轮后=" + Arrays.toString(arr));//</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 希尔排序的第2轮排序</span></span><br><span class="line"><span class="comment">// 因为第2轮排序，是将10个数据分成了 5/2 = 2组</span></span><br><span class="line"><span class="comment">for (int i = 2; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line"><span class="comment">for (int j = i - 2; j &gt;= 0; j -= 2) &#123;</span></span><br><span class="line"><span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">if (arr[j] &gt; arr[j + 2]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j + 2];</span></span><br><span class="line"><span class="comment">arr[j + 2] = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("希尔排序2轮后=" + Arrays.toString(arr));//</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 希尔排序的第3轮排序</span></span><br><span class="line"><span class="comment">// 因为第3轮排序，是将10个数据分成了 2/2 = 1组</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line"><span class="comment">for (int j = i - 1; j &gt;= 0; j -= 1) &#123;</span></span><br><span class="line"><span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">if (arr[j] &gt; arr[j + 1]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j + 1];</span></span><br><span class="line"><span class="comment">arr[j + 1] = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("希尔排序3轮后=" + Arrays.toString(arr));//</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对交换式的希尔排序进行优化-&gt;移位法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增量gap, 并逐步的缩小增量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line"><span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line"><span class="comment">//移动</span></span><br><span class="line">arr[j] = arr[j-gap];</span><br><span class="line">j -= gap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当退出while后，就给temp找到插入的位置</span></span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-快速排序"><a href="#9-快速排序" class="headerlink" title="9.快速排序"></a>9.快速排序</h2><h3 id="9-1快速排序法介绍："><a href="#9-1快速排序法介绍：" class="headerlink" title="9.1快速排序法介绍："></a>9.1快速排序法介绍：</h3><p>快速排序（Quicksort）是对<strong>冒泡排序</strong>的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，<strong>整个排序过程可以递归进行</strong>，以此达到整个数据变成有序序列</p><h3 id="9-2-快速排序法示意图："><a href="#9-2-快速排序法示意图：" class="headerlink" title="9.2 快速排序法示意图："></a>9.2 快速排序法示意图：</h3><p><img src="020.PNG" alt>  </p><h3 id="9-3快速排序法应用实例："><a href="#9-3快速排序法应用实例：" class="headerlink" title="9.3快速排序法应用实例："></a>9.3快速排序法应用实例：</h3><p>要求：对[-9，78，0，23-567，70]进行从小到大的排序，要求使用快速排序法。【测试8w和800w】<br>说明[验证分析]：<br>1）如果取消左右递归，结果是-9-5670237870<br>2）如果取消右递归，结果是-567-90237870<br>3）如果取消左递归，结果是-9-5670237078<br>4）代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int[] arr = &#123;-9,78,0,23,-567,70, -1,900, 4561&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试快排的执行速度</span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line">quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"><span class="comment">//System.out.println("arr=" + Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = left; <span class="comment">//左下标</span></span><br><span class="line"><span class="keyword">int</span> r = right; <span class="comment">//右下标</span></span><br><span class="line"><span class="comment">//pivot 中轴值</span></span><br><span class="line"><span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">//临时变量，作为交换时使用</span></span><br><span class="line"><span class="comment">//while循环的目的是让比pivot 值小放到左边</span></span><br><span class="line"><span class="comment">//比pivot 值大放到右边</span></span><br><span class="line"><span class="keyword">while</span>( l &lt; r) &#123; </span><br><span class="line"><span class="comment">//在pivot的左边一直找,找到大于等于pivot值,才退出</span></span><br><span class="line"><span class="keyword">while</span>( arr[l] &lt; pivot) &#123;</span><br><span class="line">l += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在pivot的右边一直找,找到小于等于pivot值,才退出</span></span><br><span class="line"><span class="keyword">while</span>(arr[r] &gt; pivot) &#123;</span><br><span class="line">r -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是</span></span><br><span class="line"><span class="comment">//小于等于pivot值，右边全部是大于等于pivot值</span></span><br><span class="line"><span class="keyword">if</span>( l &gt;= r) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line">temp = arr[l];</span><br><span class="line">arr[l] = arr[r];</span><br><span class="line">arr[r] = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span></span><br><span class="line"><span class="keyword">if</span>(arr[l] == pivot) &#123;</span><br><span class="line">r -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span></span><br><span class="line"><span class="keyword">if</span>(arr[r] == pivot) &#123;</span><br><span class="line">l += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span></span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">l += <span class="number">1</span>;</span><br><span class="line">r -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向左递归</span></span><br><span class="line"><span class="keyword">if</span>(left &lt; r) &#123;</span><br><span class="line">quickSort(arr, left, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向右递归</span></span><br><span class="line"><span class="keyword">if</span>(right &gt; l) &#123;</span><br><span class="line">quickSort(arr, l, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-归并排序"><a href="#10-归并排序" class="headerlink" title="10.归并排序"></a>10.归并排序</h2><h3 id="10-1-归并排序介绍："><a href="#10-1-归并排序介绍：" class="headerlink" title="10.1 归并排序介绍："></a>10.1 归并排序介绍：</h3><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的<strong>分治（divide-and-conquer）策略</strong>（分治法将问题分（divide）成一些<strong>小的问题然后递归求解</strong>，而治（conquer）的阶段则将分的阶段得到的各答案”修补“在一起，即分而治之）。</p><h3 id="10-2-归并排序思想示意图1-基本思想："><a href="#10-2-归并排序思想示意图1-基本思想：" class="headerlink" title="10.2 归并排序思想示意图1-基本思想："></a>10.2 归并排序思想示意图1-基本思想：</h3><p><img src="021.PNG" alt></p><h3 id="10-3-归并排序思想示意图2-合并相邻有序子序列："><a href="#10-3-归并排序思想示意图2-合并相邻有序子序列：" class="headerlink" title="10.3 归并排序思想示意图2-合并相邻有序子序列："></a>10.3 归并排序思想示意图2-合并相邻有序子序列：</h3><p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4，5，7，8]和[1，2，3，6]两个已经有序的子序列，合并为最终序列[1，2，3，4，5，6，7，8]，来看下实现步骤<br><img src="022.PNG" alt>  </p><h3 id="10-4-归并排序的应用实例："><a href="#10-4-归并排序的应用实例：" class="headerlink" title="10.4 归并排序的应用实例："></a>10.4 归并排序的应用实例：</h3><p>给你一个数组，val arr=Array（8，4，5，7，1，3，6，2），请使用归并排序完成排序。<br><strong>代码演示</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergetSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int arr[] = &#123; 8, 4, 5, 7, 1, 3, 6, 2 &#125;; //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试快排的执行速度</span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">//归并排序需要一个额外空间</span></span><br><span class="line"> mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line"> </span><br><span class="line"> Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//System.out.println("归并排序后=" + Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//分+合方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">//中间索引</span></span><br><span class="line"><span class="comment">//向左递归进行分解</span></span><br><span class="line">mergeSort(arr, left, mid, temp);</span><br><span class="line"><span class="comment">//向右递归进行分解</span></span><br><span class="line">mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line">merge(arr, left, mid, right, temp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid 中间索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp 做中转的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = left; <span class="comment">// 初始化i, 左边有序序列的初始索引</span></span><br><span class="line"><span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">//初始化j, 右边有序序列的初始索引</span></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(一)</span></span><br><span class="line"><span class="comment">//先把左右两边(有序)的数据按照规则填充到temp数组</span></span><br><span class="line"><span class="comment">//直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<span class="comment">//继续</span></span><br><span class="line"><span class="comment">//如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line"><span class="comment">//即将左边的当前元素，填充到 temp数组 </span></span><br><span class="line"><span class="comment">//然后 t++, i++</span></span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">temp[t] = arr[i];</span><br><span class="line">t += <span class="number">1</span>;</span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">temp[t] = arr[j];</span><br><span class="line">t += <span class="number">1</span>;</span><br><span class="line">j += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(二)</span></span><br><span class="line"><span class="comment">//把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line"><span class="keyword">while</span>( i &lt;= mid) &#123; <span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">temp[t] = arr[i];</span><br><span class="line">t += <span class="number">1</span>;</span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( j &lt;= right) &#123; <span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">temp[t] = arr[j];</span><br><span class="line">t += <span class="number">1</span>;</span><br><span class="line">j += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//(三)</span></span><br><span class="line"><span class="comment">//将temp数组的元素拷贝到arr</span></span><br><span class="line"><span class="comment">//注意，并不是每次都拷贝所有</span></span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tempLeft = left; <span class="comment">// </span></span><br><span class="line"><span class="comment">//第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3</span></span><br><span class="line"><span class="comment">//最后一次 tempLeft = 0  right = 7</span></span><br><span class="line"><span class="keyword">while</span>(tempLeft &lt;= right) &#123; </span><br><span class="line">arr[tempLeft] = temp[t];</span><br><span class="line">t += <span class="number">1</span>;</span><br><span class="line">tempLeft += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-基数排序"><a href="#11-基数排序" class="headerlink" title="11.基数排序"></a>11.基数排序</h2><h3 id="11-1-基数排序（桶排序）介绍："><a href="#11-1-基数排序（桶排序）介绍：" class="headerlink" title="11.1 基数排序（桶排序）介绍："></a>11.1 基数排序（桶排序）介绍：</h3><p>1）基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用<br>2）基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法  </p><p>3）基数排序（Radix Sort）是桶排序的扩展<br>4）基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。  </p><h3 id="11-2-基数排序基本思想"><a href="#11-2-基数排序基本思想" class="headerlink" title="11.2 基数排序基本思想"></a>11.2 基数排序基本思想</h3><p>1）将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。<br>这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。<br>2）这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤  </p><h3 id="11-3-基数排序图文说明"><a href="#11-3-基数排序图文说明" class="headerlink" title="11.3 基数排序图文说明"></a>11.3 基数排序图文说明</h3><p>将数组{53，3，542，748，14，214}使用基数排序，进行升序排序<br><img src="023.PNG" alt><br><img src="024.PNG" alt><br><img src="025.PNG" alt>  </p><h3 id="11-4-基数排序代码实现"><a href="#11-4-基数排序代码实现" class="headerlink" title="11.4 基数排序代码实现"></a>11.4 基数排序代码实现</h3><p>要求：将数组{53，3，542，748，14，214}使用基数排序，进行升序排序  </p><p>1）思路分析：前面的图文已经讲明确<br>2）代码实现：看老师演示  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G </span></span><br><span class="line"><span class="comment">//int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">//arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line">radixSort(arr);</span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"基数排序后 "</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基数排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据前面的推导过程，我们可以得到最终的基数排序代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 得到数组中最大的数的位数</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>]; <span class="comment">//假设第一数就是最大数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到最大数是几位数</span></span><br><span class="line"><span class="keyword">int</span> maxLength = (max + <span class="string">""</span>).length();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line"><span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line"><span class="comment">//3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line"><span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line"><span class="comment">//可以这里理解</span></span><br><span class="line"><span class="comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line"><span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里我们使用循环将代码处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> , n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line"><span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="comment">//取出每个元素的对应位的值</span></span><br><span class="line"><span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>;</span><br><span class="line"><span class="comment">//放入到对应的桶中</span></span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line"><span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line"><span class="comment">//取出元素放入到arr</span></span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//System.out.println("第"+(i+1)+"轮，对个位的排序处理 arr =" + Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第1轮(针对每个元素的个位进行排序处理)</span></span><br><span class="line"><span class="comment">for(int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">//取出每个元素的个位的值</span></span><br><span class="line"><span class="comment">int digitOfElement = arr[j] / 1 % 10;</span></span><br><span class="line"><span class="comment">//放入到对应的桶中</span></span><br><span class="line"><span class="comment">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="comment">int index = 0;</span></span><br><span class="line"><span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">if(bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="comment">for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">//取出元素放入到arr</span></span><br><span class="line"><span class="comment">arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line"><span class="comment">bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println("第1轮，对个位的排序处理 arr =" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//==========================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第2轮(针对每个元素的十位进行排序处理)</span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">// 取出每个元素的十位的值</span></span><br><span class="line"><span class="comment">int digitOfElement = arr[j] / 10  % 10; //748 / 10 =&gt; 74 % 10 =&gt; 4</span></span><br><span class="line"><span class="comment">// 放入到对应的桶中</span></span><br><span class="line"><span class="comment">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="comment">index = 0;</span></span><br><span class="line"><span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">if (bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="comment">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">// 取出元素放入到arr</span></span><br><span class="line"><span class="comment">arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line"><span class="comment">bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println("第2轮，对个位的排序处理 arr =" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第3轮(针对每个元素的百位进行排序处理)</span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">// 取出每个元素的百位的值</span></span><br><span class="line"><span class="comment">int digitOfElement = arr[j] / 100 % 10; // 748 / 100 =&gt; 7 % 10 = 7</span></span><br><span class="line"><span class="comment">// 放入到对应的桶中</span></span><br><span class="line"><span class="comment">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="comment">index = 0;</span></span><br><span class="line"><span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">if (bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="comment">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">// 取出元素放入到arr</span></span><br><span class="line"><span class="comment">arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line"><span class="comment">bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println("第3轮，对个位的排序处理 arr =" + Arrays.toString(arr)); */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-5基数排序的说明："><a href="#11-5基数排序的说明：" class="headerlink" title="11.5基数排序的说明："></a>11.5基数排序的说明：</h3><p>1）基数排序是对传统桶排序的扩展，速度很快.<br>2）基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成OutOfMemoryError。<br>3）基数排序时稳定的。[注：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=ri]，且ri]在rj]之前，而在排序后的序列中，i]仍在]之前，则称这种排序算法是稳定的；否则称为不稳定的]<br>4）有负数的数组，我们不用基数排序来进行排序，如果要支持负数，参考：<a href="https://code.i-harness.com/zh-CN/q/e98fa9" rel="external nofollow noopener noreferrer" target="_blank">文档</a></p><h2 id="12-常用排序算法总结和对比"><a href="#12-常用排序算法总结和对比" class="headerlink" title="12.常用排序算法总结和对比"></a>12.常用排序算法总结和对比</h2><h3 id="12-1-一张排序算法的比较图"><a href="#12-1-一张排序算法的比较图" class="headerlink" title="12.1 一张排序算法的比较图"></a>12.1 一张排序算法的比较图</h3><p><img src="026.PNG" alt>  </p><h3 id="12-2-相关术语解释："><a href="#12-2-相关术语解释：" class="headerlink" title="12.2 相关术语解释："></a>12.2 相关术语解释：</h3><ol><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度：一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li><li>n：数据规模</li><li>k:“桶”的个数</li><li>In-place：不占用额外内存</li><li>Out-place：占用额外内存  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-排序算法的介绍&quot;&gt;&lt;a href=&quot;#1-排序算法的介绍&quot; class=&quot;headerlink&quot; title=&quot;1.排序算法的介绍&quot;&gt;&lt;/a&gt;1.排序算法的介绍&lt;/h2&gt;&lt;p&gt;排序也称排序算法（Sort Algorithm），排序是将一组&lt;strong&gt;数据&lt;/strong&gt;，依&lt;strong&gt;指定的顺序&lt;/strong&gt;进行&lt;strong&gt;排列的过程&lt;/strong&gt;。……
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="https://RuanGuoHui.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之递归</title>
    <link href="https://RuanGuoHui.github.io/2019/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <id>https://RuanGuoHui.github.io/2019/07/20/数据结构与算法之递归/</id>
    <published>2019-07-20T03:22:28.000Z</published>
    <updated>2019-07-20T03:52:21.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-递归的概念"><a href="#1-递归的概念" class="headerlink" title="1.递归的概念"></a>1.递归的概念</h2><p>简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量.递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。……<a id="more"></a></p><h2 id="2-递归调用机制"><a href="#2-递归调用机制" class="headerlink" title="2.递归调用机制"></a>2.递归调用机制</h2><ol><li>打印问题</li><li>阶乘问题</li><li>使用图解方式说明了递归的调用机制<br><img src="001.PNG" alt>  </li><li>代码演示<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//通过打印问题，回顾递归调用机制</span></span><br><span class="line">test(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//int res = factorial(3);</span></span><br><span class="line"><span class="comment">//System.out.println("res=" + res);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印问题. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">test(n - <span class="number">1</span>);</span><br><span class="line">&#125; <span class="comment">//else &#123;</span></span><br><span class="line">System.out.println(<span class="string">"n="</span> + n);</span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//阶乘问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n; <span class="comment">// 1 * 2 * 3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-递归能解决什么样的问题"><a href="#3-递归能解决什么样的问题" class="headerlink" title="3.递归能解决什么样的问题"></a>3.递归能解决什么样的问题</h2><p>递归用于解决什么样的问题  </p><ol><li>各种数学问题如：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题（google 编程大赛）  </li><li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等。  </li><li>将用栈解决的问题-&gt;第归代码比较简洁  </li></ol><h2 id="4-递归需要遵守的重要规则"><a href="#4-递归需要遵守的重要规则" class="headerlink" title="4.递归需要遵守的重要规则"></a>4.递归需要遵守的重要规则</h2><p><strong>递归需要遵守的重要规则</strong></p><ol><li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）  </li><li>方法的局部变量是独立的，不会相互影响，比如n变量  </li><li>如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据.  </li><li>递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了）  </li><li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕  </li></ol><h2 id="5-递归-迷宫问题"><a href="#5-递归-迷宫问题" class="headerlink" title="5.递归-迷宫问题"></a>5.递归-迷宫问题</h2><h3 id="5-1-1迷宫问题"><a href="#5-1-1迷宫问题" class="headerlink" title="5.1.1迷宫问题"></a>5.1.1迷宫问题</h3><p><img src="002.PNG" alt></p><h3 id="5-1-2代码实现"><a href="#5-1-2代码实现" class="headerlink" title="5.1.2代码实现"></a>5.1.2代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先创建一个二维数组，模拟迷宫</span></span><br><span class="line"><span class="comment">// 地图</span></span><br><span class="line"><span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line"><span class="comment">// 使用1 表示墙</span></span><br><span class="line"><span class="comment">// 上下全部置为1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左右全部置为1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置挡板, 1 表示</span></span><br><span class="line">map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//map[1][2] = 1;</span></span><br><span class="line"><span class="comment">//map[2][2] = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出地图</span></span><br><span class="line">System.out.println(<span class="string">"地图的情况"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用递归回溯给小球找路</span></span><br><span class="line"><span class="comment">//setWay(map, 1, 1);</span></span><br><span class="line">setWay2(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出新的地图, 小球走过，并标识过的递归</span></span><br><span class="line">System.out.println(<span class="string">"小球走过，并标识过的 地图的情况"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. map 表示地图</span></span><br><span class="line"><span class="comment">//2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line"><span class="comment">//3. 如果小球能到 map[6][5] 位置，则说明通路找到.</span></span><br><span class="line"><span class="comment">//4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙  ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通</span></span><br><span class="line"><span class="comment">//5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 从哪个位置开始找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到通路，就返回true, 否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123; <span class="comment">// 通路已经找到ok</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(map[i][j] == <span class="number">0</span>) &#123; <span class="comment">//如果当前这个点还没有走过</span></span><br><span class="line"><span class="comment">//按照策略 下-&gt;右-&gt;上-&gt;左  走</span></span><br><span class="line">map[i][j] = <span class="number">2</span>; <span class="comment">// 假定该点是可以走通.</span></span><br><span class="line"><span class="keyword">if</span>(setWay(map, i+<span class="number">1</span>, j)) &#123;<span class="comment">//向下走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j+<span class="number">1</span>)) &#123; <span class="comment">//向右走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i-<span class="number">1</span>, j)) &#123; <span class="comment">//向上</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j-<span class="number">1</span>))&#123; <span class="comment">// 向左走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//说明该点是走不通，是死路</span></span><br><span class="line">map[i][j] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改找路的策略，改成 上-&gt;右-&gt;下-&gt;左</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay2</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123; <span class="comment">// 通路已经找到ok</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(map[i][j] == <span class="number">0</span>) &#123; <span class="comment">//如果当前这个点还没有走过</span></span><br><span class="line"><span class="comment">//按照策略 上-&gt;右-&gt;下-&gt;左</span></span><br><span class="line">map[i][j] = <span class="number">2</span>; <span class="comment">// 假定该点是可以走通.</span></span><br><span class="line"><span class="keyword">if</span>(setWay2(map, i-<span class="number">1</span>, j)) &#123;<span class="comment">//向上走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j+<span class="number">1</span>)) &#123; <span class="comment">//向右走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i+<span class="number">1</span>, j)) &#123; <span class="comment">//向下</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j-<span class="number">1</span>))&#123; <span class="comment">// 向左走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//说明该点是走不通，是死路</span></span><br><span class="line">map[i][j] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-3-对迷宫问题的讨论"><a href="#5-1-3-对迷宫问题的讨论" class="headerlink" title="5.1.3 对迷宫问题的讨论"></a>5.1.3 对迷宫问题的讨论</h3><ol><li>小球得到的路径，和程序员设置的<strong>找路策略</strong>有关即：找路的上下左右的顺序相关</li><li>再得到小球路径时，可以先使用（下右上左），再改成（<strong>上右下左</strong>），看看路径是不是有变化</li><li>测试回溯现象</li><li><strong>思考</strong>：如何求出最短路径？思路-》代码实现</li></ol><h2 id="6-递归-八皇后问题（回溯算法）"><a href="#6-递归-八皇后问题（回溯算法）" class="headerlink" title="6. 递归-八皇后问题（回溯算法）"></a>6. 递归-八皇后问题（回溯算法）</h2><h3 id="6-1-1-八皇后问题介绍"><a href="#6-1-1-八皇后问题介绍" class="headerlink" title="6.1.1 八皇后问题介绍"></a>6.1.1 八皇后问题介绍</h3><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：<strong>任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法（92）</strong>。</p><h3 id="6-1-2-八皇后问题算法思路分析"><a href="#6-1-2-八皇后问题算法思路分析" class="headerlink" title="6.1.2 八皇后问题算法思路分析"></a>6.1.2 八皇后问题算法思路分析</h3><ol><li>第一个皇后先放第一行第一列</li><li>第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li><li>继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li><li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</li><li>然后回头继续第一个皇后放第二列，后面继续循环执行1，2，3，4的步骤</li><li>示意图：<br><img src="003.PNG" alt>  </li></ol><p><strong>说明：</strong><br>理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题.arr[8]=<br>{0，4，7，5，2，6，1，3}//对应arr下标表示第几行，即第几个皇后，arr[i]=val，val表示第i计1个皇后，放在第i计1行的第val+1列  </p><h3 id="6-1-3-八皇后问题算法代码实现"><a href="#6-1-3-八皇后问题算法代码实现" class="headerlink" title="6.1.3 八皇后问题算法代码实现"></a>6.1.3 八皇后问题算法代码实现</h3><p><strong>说明：看代码演示</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个max表示共有多少个皇后</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//定义数组array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; </span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> judgeCount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试一把 ， 8皇后是否正确</span></span><br><span class="line">Queue8 queue8 = <span class="keyword">new</span> Queue8();</span><br><span class="line">queue8.check(<span class="number">0</span>);</span><br><span class="line">System.out.printf(<span class="string">"一共有%d解法"</span>, count);</span><br><span class="line">System.out.printf(<span class="string">"一共判断冲突的次数%d次"</span>, judgeCount); <span class="comment">// 1.5w</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个方法，放置第n个皇后</span></span><br><span class="line"><span class="comment">//特别注意： check 是 每一次递归时，进入到check中都有  for(int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == max) &#123;  <span class="comment">//n = 8 , 其实8个皇后就既然放好</span></span><br><span class="line">print();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line"><span class="comment">//先把当前这个皇后 n , 放到该行的第1列</span></span><br><span class="line">array[n] = i;</span><br><span class="line"><span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line"><span class="keyword">if</span>(judge(n)) &#123; <span class="comment">// 不冲突</span></span><br><span class="line"><span class="comment">//接着放n+1个皇后,即开始递归</span></span><br><span class="line">check(n+<span class="number">1</span>); <span class="comment">//  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 表示第n个皇后</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">judgeCount++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">//1. array[i] == array[n]  表示判断 第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line"><span class="comment">//2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线</span></span><br><span class="line"><span class="comment">// n = 1  放置第 2列 1 n = 1 array[1] = 1</span></span><br><span class="line"><span class="comment">// Math.abs(1-0) == 1  Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1</span></span><br><span class="line"><span class="comment">//3. 判断是否在同一行, 没有必要，n 每次都在递增</span></span><br><span class="line"><span class="keyword">if</span>(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">System.out.print(array[i] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-递归的概念&quot;&gt;&lt;a href=&quot;#1-递归的概念&quot; class=&quot;headerlink&quot; title=&quot;1.递归的概念&quot;&gt;&lt;/a&gt;1.递归的概念&lt;/h2&gt;&lt;p&gt;简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量.递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。……
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之栈</title>
    <link href="https://RuanGuoHui.github.io/2019/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88/"/>
    <id>https://RuanGuoHui.github.io/2019/07/19/数据结构与算法之栈/</id>
    <published>2019-07-19T01:24:01.000Z</published>
    <updated>2019-08-25T08:55:34.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-栈的介绍"><a href="#1-栈的介绍" class="headerlink" title="1.栈的介绍"></a>1.栈的介绍</h2><ol><li>栈的英文为（stack）</li><li>栈是一个<strong>先入后出</strong>（FILO-First In Last Out）的有序列表。  <a id="more"></a></li><li>栈（stack）是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为<strong>变化的一端，称为栈顶（Top）</strong>，另一端为<strong>固定的一端，称为栈底（Bottom）</strong>。</li><li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</li><li>图解方式说明出栈（pop）和入栈（push）的概念  </li></ol><p><img src="001.PNG" alt>  </p><h2 id="2-栈的应用场景"><a href="#2-栈的应用场景" class="headerlink" title="2.栈的应用场景"></a>2.栈的应用场景</h2><ol><li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。</li><li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li><li>表达式的转换[中缀表达式转后缀表达式]与求值（实际解决）。</li><li>二叉树的遍历。</li><li>图形的深度优先（depth一first）搜索法。  </li></ol><h2 id="3-栈的快速入门"><a href="#3-栈的快速入门" class="headerlink" title="3.栈的快速入门"></a>3.栈的快速入门</h2><ol><li>用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。  </li><li>实现思路分析，并画出示意图<br><img src="002.PNG" alt></li><li>代码实现  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试一下ArrayStack 是否正确</span></span><br><span class="line"><span class="comment">//先创建一个ArrayStack对象-&gt;表示栈</span></span><br><span class="line">ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">String key = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>; <span class="comment">//控制是否退出菜单</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"show: 表示显示栈"</span>);</span><br><span class="line">System.out.println(<span class="string">"exit: 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"push: 表示添加数据到栈(入栈)"</span>);</span><br><span class="line">System.out.println(<span class="string">"pop: 表示从栈取出数据(出栈)"</span>);</span><br><span class="line">System.out.println(<span class="string">"请输入你的选择"</span>);</span><br><span class="line">key = scanner.next();</span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">stack.list();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">System.out.println(<span class="string">"请输入一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">stack.push(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"pop"</span>:</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = stack.pop();</span><br><span class="line">System.out.printf(<span class="string">"出栈的数据是 %d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"程序退出~~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个 ArrayStack 表示栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 栈的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] stack; <span class="comment">// 数组，数组模拟栈，数据就放在该数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">// top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈-push</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先判断栈是否满</span></span><br><span class="line"><span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">stack[top] = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈-pop, 将栈顶的数据返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//先判断栈是否空</span></span><br><span class="line"><span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空，没有数据~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> value = stack[top];</span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈空，没有数据~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要从栈顶开始显示数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">System.out.printf(<span class="string">"stack[%d]=%d\n"</span>, i, stack[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-栈实现综合计算器"><a href="#4-栈实现综合计算器" class="headerlink" title="4.栈实现综合计算器"></a>4.栈实现综合计算器</h2><h3 id="4-1使用栈来实现综合计算器"><a href="#4-1使用栈来实现综合计算器" class="headerlink" title="4.1使用栈来实现综合计算器"></a>4.1使用栈来实现综合计算器</h3><p><img src="003.PNG" alt>  </p><h3 id="4-2思路分析-图解"><a href="#4-2思路分析-图解" class="headerlink" title="4.2思路分析(图解)"></a>4.2思路分析(图解)</h3><p><img src="004.PNG" alt>  </p><h3 id="代码实现-1-先实现一位数的运算，2-扩展到多位数的运算"><a href="#代码实现-1-先实现一位数的运算，2-扩展到多位数的运算" class="headerlink" title="代码实现[1.先实现一位数的运算，2.扩展到多位数的运算]"></a>代码实现[1.先实现一位数的运算，2.扩展到多位数的运算]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//根据前面老师思路，完成表达式的运算</span></span><br><span class="line">String expression = <span class="string">"7*2*2-5+1-5+3-4"</span>; <span class="comment">// 15//如何处理多位数的问题？</span></span><br><span class="line"><span class="comment">//创建两个栈，数栈，一个符号栈</span></span><br><span class="line">ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line">ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//定义需要的相关变量</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//用于扫描</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> oper = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">' '</span>; <span class="comment">//将每次扫描得到char保存到ch</span></span><br><span class="line">String keepNum = <span class="string">""</span>; <span class="comment">//用于拼接 多位数</span></span><br><span class="line"><span class="comment">//开始while循环的扫描expression</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//依次得到expression 的每一个字符</span></span><br><span class="line">ch = expression.substring(index, index+<span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//判断ch是什么，然后做相应的处理</span></span><br><span class="line"><span class="keyword">if</span>(operStack.isOper(ch)) &#123;<span class="comment">//如果是运算符</span></span><br><span class="line"><span class="comment">//判断当前的符号栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(!operStack.isEmpty()) &#123;</span><br><span class="line"><span class="comment">//如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数,</span></span><br><span class="line"><span class="comment">//在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈</span></span><br><span class="line"><span class="keyword">if</span>(operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">num1 = numStack.pop();</span><br><span class="line">num2 = numStack.pop();</span><br><span class="line">oper = operStack.pop();</span><br><span class="line">res = numStack.cal(num1, num2, oper);</span><br><span class="line"><span class="comment">//把运算的结果如数栈</span></span><br><span class="line">numStack.push(res);</span><br><span class="line"><span class="comment">//然后将当前的操作符入符号栈</span></span><br><span class="line">operStack.push(ch);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</span></span><br><span class="line">operStack.push(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果为空直接入符号栈..</span></span><br><span class="line">operStack.push(ch); <span class="comment">// 1 + 3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果是数，则直接入数栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//numStack.push(ch - 48); //? "1+3" '1' =&gt; 1</span></span><br><span class="line"><span class="comment">//分析思路</span></span><br><span class="line"><span class="comment">//1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span></span><br><span class="line"><span class="comment">//2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line"><span class="comment">//3. 因此我们需要定义一个变量 字符串，用于拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理多位数</span></span><br><span class="line">keepNum += ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果ch已经是expression的最后一位，就直接入栈</span></span><br><span class="line"><span class="keyword">if</span> (index == expression.length() - <span class="number">1</span>) &#123;</span><br><span class="line">numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span></span><br><span class="line"><span class="comment">//注意是看后一位，不是index++</span></span><br><span class="line"><span class="keyword">if</span> (operStack.isOper(expression.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line"><span class="comment">//如果后一位是运算符，则入栈 keepNum = "1" 或者 "123"</span></span><br><span class="line">numStack.push(Integer.parseInt(keepNum));</span><br><span class="line"><span class="comment">//重要的!!!!!!, keepNum清空</span></span><br><span class="line">keepNum = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让index + 1, 并判断是否扫描到expression最后.</span></span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= expression.length()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】</span></span><br><span class="line"><span class="keyword">if</span>(operStack.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">num1 = numStack.pop();</span><br><span class="line">num2 = numStack.pop();</span><br><span class="line">oper = operStack.pop();</span><br><span class="line">res = numStack.cal(num1, num2, oper);</span><br><span class="line">numStack.push(res);<span class="comment">//入栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将数栈的最后数，pop出，就是结果</span></span><br><span class="line"><span class="keyword">int</span> res2 = numStack.pop();</span><br><span class="line">System.out.printf(<span class="string">"表达式 %s = %d"</span>, expression, res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建一个栈,直接使用前面创建好</span></span><br><span class="line"><span class="comment">//定义一个 ArrayStack2 表示栈, 需要扩展功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack2</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 栈的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] stack; <span class="comment">// 数组，数组模拟栈，数据就放在该数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">// top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayStack2</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> stack[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈-push</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先判断栈是否满</span></span><br><span class="line"><span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">stack[top] = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈-pop, 将栈顶的数据返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//先判断栈是否空</span></span><br><span class="line"><span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空，没有数据~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> value = stack[top];</span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈空，没有数据~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要从栈顶开始显示数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">System.out.printf(<span class="string">"stack[%d]=%d\n"</span>, i, stack[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示</span></span><br><span class="line"><span class="comment">//数字越大，则优先级就越高.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(oper == <span class="string">'*'</span> || oper == <span class="string">'/'</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">'+'</span> || oper == <span class="string">'-'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 假定目前的表达式只有 +, - , * , /</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是不是一个运算符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val == <span class="string">'+'</span> || val == <span class="string">'-'</span> || val == <span class="string">'*'</span> || val == <span class="string">'/'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// res 用于存放计算的结果</span></span><br><span class="line"><span class="keyword">switch</span> (oper) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">res = num1 + num2;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">res = num2 - num1;<span class="comment">// 注意顺序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">res = num1 * num2;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">res = num2 / num1;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5逆波兰计算器"><a href="#5逆波兰计算器" class="headerlink" title="5逆波兰计算器"></a>5逆波兰计算器</h2><h3 id="5-1我们完成一个逆波兰计算器，要求完成如下任务："><a href="#5-1我们完成一个逆波兰计算器，要求完成如下任务：" class="headerlink" title="5.1我们完成一个逆波兰计算器，要求完成如下任务："></a>5.1我们完成一个逆波兰计算器，要求完成如下任务：</h3><h4 id="1-输入一个逆波兰表达式（后缀表达式），使用栈（Stack），计算其结果"><a href="#1-输入一个逆波兰表达式（后缀表达式），使用栈（Stack），计算其结果" class="headerlink" title="1. 输入一个逆波兰表达式（后缀表达式），使用栈（Stack），计算其结果"></a>1. 输入一个逆波兰表达式（后缀表达式），使用栈（Stack），计算其结果</h4><h4 id="2-支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。"><a href="#2-支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。" class="headerlink" title="2. 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。"></a>2. 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。</h4><h4 id="3-思路分析"><a href="#3-思路分析" class="headerlink" title="3. 思路分析"></a>3. 思路分析</h4><h5 id="5-1-1例如：（3-4）×5-6对应的后缀表达式就是34-5×6-，针对后缀表达式求值步骤如下："><a href="#5-1-1例如：（3-4）×5-6对应的后缀表达式就是34-5×6-，针对后缀表达式求值步骤如下：" class="headerlink" title="5.1.1例如：（3+4）×5-6对应的后缀表达式就是34+5×6-，针对后缀表达式求值步骤如下："></a>5.1.1例如：（3+4）×5-6对应的后缀表达式就是34+5×6-，针对后缀表达式求值步骤如下：</h5><ol><li>从左至右扫描，将3和4压入堆栈；  </li><li>遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；  </li><li>将5入栈；  </li><li>接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；  </li><li>将6入栈；  </li><li>最后是-运算符，计算出35-6的值，即29，由此得出最终结果  </li></ol><h4 id="4-代码完成"><a href="#4-代码完成" class="headerlink" title="4.代码完成"></a>4.代码完成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//先定义给逆波兰表达式</span></span><br><span class="line"><span class="comment">//(30+4)×5-6  =&gt; 30 4 + 5 × 6 - =&gt; 164</span></span><br><span class="line"><span class="comment">// 4 * 5 - 8 + 60 + 8 / 2 =&gt; 4 5 * 8 - 60 + 8 2 / + </span></span><br><span class="line"><span class="comment">//测试 </span></span><br><span class="line"><span class="comment">//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开</span></span><br><span class="line"><span class="comment">//String suffixExpression = "30 4 + 5 * 6 -";</span></span><br><span class="line"><span class="comment">String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76</span></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">//1. 先将 "3 4 + 5 × 6 - " =&gt; 放到ArrayList中</span></span><br><span class="line"><span class="comment">//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">List&lt;String&gt; list = getListString(suffixExpression);</span></span><br><span class="line"><span class="comment">System.out.println("rpnList=" + list);</span></span><br><span class="line"><span class="comment">int res = calculate(list);</span></span><br><span class="line"><span class="comment">System.out.println("计算的结果是=" + res);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：将 中缀表达式转成对应的List</span></span><br><span class="line"><span class="comment">//  s="1+((2+3)×4)-5";</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixExpressionList</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义一个List,存放中缀表达式 对应的内容</span></span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//这时是一个指针，用于遍历 中缀表达式字符串</span></span><br><span class="line">String str; <span class="comment">// 对多位数的拼接</span></span><br><span class="line"><span class="keyword">char</span> c; <span class="comment">// 每遍历到一个字符，就放入到c</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//如果c是一个非数字，我需要加入到ls</span></span><br><span class="line"><span class="keyword">if</span>((c=s.charAt(i)) &lt; <span class="number">48</span> ||  (c=s.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line">ls.add(<span class="string">""</span> + c);</span><br><span class="line">i++; <span class="comment">//i需要后移</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果是一个数，需要考虑多位数</span></span><br><span class="line">str = <span class="string">""</span>; <span class="comment">//先将str 置成"" '0'[48]-&gt;'9'[57]</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; s.length() &amp;&amp; (c=s.charAt(i)) &gt;= <span class="number">48</span> &amp;&amp; (c=s.charAt(i)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">str += c;<span class="comment">//拼接</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">ls.add(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(i &lt; s.length());</span><br><span class="line"><span class="keyword">return</span> ls;<span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将 suffixExpression 分割</span></span><br><span class="line">String[] split = suffixExpression.split(<span class="string">" "</span>);</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span>(String ele: split) &#123;</span><br><span class="line">list.add(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1)从左至右扫描，将3和4压入堆栈；</span></span><br><span class="line"><span class="comment">2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment">3)将5入栈；</span></span><br><span class="line"><span class="comment">4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</span></span><br><span class="line"><span class="comment">5)将6入栈；</span></span><br><span class="line"><span class="comment">6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建给栈, 只需要一个栈即可</span></span><br><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"><span class="comment">// 遍历 ls</span></span><br><span class="line"><span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line"><span class="comment">// 这里使用正则表达式来取出数</span></span><br><span class="line"><span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) &#123; <span class="comment">// 匹配的是多位数</span></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line">stack.push(item);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// pop出两个数，并运算， 再入栈</span></span><br><span class="line"><span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line"><span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (item.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">res = num1 + num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">res = num1 - num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">res = num1 * num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">res = num1 / num2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"运算符有误"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把res 入栈</span></span><br><span class="line">stack.push(<span class="string">""</span> + res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后留在stack中的数据是运算结果</span></span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-中缀表达式转换为后缀表达式"><a href="#6-中缀表达式转换为后缀表达式" class="headerlink" title="6.中缀表达式转换为后缀表达式"></a>6.中缀表达式转换为后缀表达式</h2><p>大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将中缀表达式转成后缀表达式。</p><h3 id="6-1具体步骤如下："><a href="#6-1具体步骤如下：" class="headerlink" title="6.1具体步骤如下："></a>6.1具体步骤如下：</h3><p>1）初始化两个栈：运算符栈s1和储存中间结果的栈s2；<br>2）从左至右扫描中缀表达式；<br>3）遇到操作数时，将其压s2；<br>4）遇到运算符时，比较其与s1栈顶运算符的优先级：  </p><pre>1.  如果s1为空，或栈顶运算符为左括号“（”，则直接将此运算符入栈；  2.  否则，若优先级比栈顶运算符的高，也将运算符压入s1；  3.  否则，将s1栈顶的运算符弹出并压入到s2中，再次转到（4-1）与s1中新的栈顶运算符相比较；    </pre><p>5）遇到括号时：</p><pre>（1）如果是左括号“（”，则直接压入s1（2）如果是右括号“）”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</pre><p>6）重复步骤2至5，直到表达式的最右边<br>7）将s1中剩余的运算符依次弹出并压入s28）依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式<br>8）依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式  </p><h3 id="6-2举例说明："><a href="#6-2举例说明：" class="headerlink" title="6.2举例说明："></a>6.2举例说明：</h3><p>将中缀表达式“1+（（2+3）×4）-5”转换为后缀表达式的过程如下<br>因此结果为：”123+4×+5-“<br><img src="005.PNG" alt>  </p><h3 id="6-3代码实现中缀表达式转为后缀表达式"><a href="#6-3代码实现中缀表达式转为后缀表达式" class="headerlink" title="6.3代码实现中缀表达式转为后缀表达式"></a>6.3代码实现中缀表达式转为后缀表达式</h3><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p><img src="006.PNG" alt>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//完成将一个中缀表达式转成后缀表达式的功能</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 1+((2+3)×4)-5 =&gt; 转成  1 2 3 + 4 × + 5 –</span></span><br><span class="line"><span class="comment">//2. 因为直接对str 进行操作，不方便，因此 先将  "1+((2+3)×4)-5" =》 中缀的表达式对应的List</span></span><br><span class="line"><span class="comment">//   即 "1+((2+3)×4)-5" =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line"><span class="comment">//3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line"><span class="comment">//   即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line"></span><br><span class="line">String expression = <span class="string">"1+((2+3)*4)-5"</span>;<span class="comment">//注意表达式 </span></span><br><span class="line">List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">System.out.println(<span class="string">"中缀表达式对应的List="</span> + infixExpressionList); <span class="comment">// ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);</span><br><span class="line">System.out.println(<span class="string">"后缀表达式对应的List"</span> + suffixExpreesionList); <span class="comment">//ArrayList [1,2,3,+,4,*,+,5,–] </span></span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">"expression=%d"</span>, calculate(suffixExpreesionList)); <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line"><span class="comment">//方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpreesionList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义两个栈</span></span><br><span class="line">Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;String&gt;(); <span class="comment">// 符号栈</span></span><br><span class="line"><span class="comment">//说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span></span><br><span class="line"><span class="comment">//因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2</span></span><br><span class="line"><span class="comment">//Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); // 储存中间结果的栈s2</span></span><br><span class="line">List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 储存中间结果的Lists2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历ls</span></span><br><span class="line"><span class="keyword">for</span>(String item: ls) &#123;</span><br><span class="line"><span class="comment">//如果是一个数，加入s2</span></span><br><span class="line"><span class="keyword">if</span>(item.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">s2.add(item);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">")"</span>)) &#123;</span><br><span class="line"><span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line"><span class="keyword">while</span>(!s1.peek().equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">s1.pop();<span class="comment">//!!! 将 ( 弹出 s1栈， 消除小括号</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较</span></span><br><span class="line"><span class="comment">//问题：我们缺少一个比较优先级高低的方法</span></span><br><span class="line"><span class="keyword">while</span>(s1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item) ) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还需要将item压入栈</span></span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将s1中剩余的运算符依次弹出并加入s2</span></span><br><span class="line"><span class="keyword">while</span>(s1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s2; <span class="comment">//注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line"></span><br><span class="line">｝</span><br><span class="line"><span class="comment">//编写一个类 Operation 可以返回一个运算符 对应的优先级</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (operation) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">result = ADD;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">result = SUB;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">result = MUL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">result = DIV;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"不存在该运算符"</span> + operation);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-逆波兰计算器完整版"><a href="#7-逆波兰计算器完整版" class="headerlink" title="7.逆波兰计算器完整版"></a>7.逆波兰计算器完整版</h2><h3 id="7-1完整版的逆波兰计算器，功能包括"><a href="#7-1完整版的逆波兰计算器，功能包括" class="headerlink" title="7.1完整版的逆波兰计算器，功能包括"></a>7.1完整版的逆波兰计算器，功能包括</h3><ol><li>支持+一*/（）</li><li>多位数，支持小数，</li><li>兼容处理，过滤任何空白字符，包括空格、制表符、换页符说明：逆波兰计算器完整版考虑的因素较多，下面给出完整版代码供同学们学习，其基本思路和前面一样，也是使用到：中缀表达式转后缀表达式。  <h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.reversepolishcal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePolishMultiCalc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 + - * / ( ) 运算符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String SYMBOL = <span class="string">"\\+|-|\\*|/|\\(|\\)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEFT = <span class="string">"("</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RIGHT = <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ADD = <span class="string">"+"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MINUS= <span class="string">"-"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TIMES = <span class="string">"*"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIVISION = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加減 + -</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_01 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘除 * /</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_02 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 括号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_HIGH = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; data = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去除所有空白符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceAllBlank</span><span class="params">(String s )</span></span>&#123;</span><br><span class="line">        <span class="comment">// \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]</span></span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">"\\s+"</span>,<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是数字 int double long float</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">"^[-\\+]?[.\\d]*$"</span>);</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(SYMBOL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配运算等级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calcLevel</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"+"</span>.equals(s) || <span class="string">"-"</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_01;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(s) || <span class="string">"/"</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_02;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LEVEL_HIGH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">doMatch</span> <span class="params">(String s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s.trim())) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data is empty"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!isNumber(s.charAt(<span class="number">0</span>)+<span class="string">""</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data illeagle,start not with a number"</span>);</span><br><span class="line"></span><br><span class="line">        s = replaceAllBlank(s);</span><br><span class="line"></span><br><span class="line">        String each;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(s.charAt(i)+<span class="string">""</span>))&#123;</span><br><span class="line">                each = s.charAt(i)+<span class="string">""</span>;</span><br><span class="line">                <span class="comment">//栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || LEFT.equals(each)</span><br><span class="line">                        || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH))&#123;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( !stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                    <span class="comment">//栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()) )&#123;</span><br><span class="line">                        <span class="keyword">if</span>(calcLevel(stack.peek()) == LEVEL_HIGH)&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(RIGHT.equals(each))&#123;</span><br><span class="line">                    <span class="comment">// ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(LEVEL_HIGH == calcLevel(stack.peek()))&#123;</span><br><span class="line">                            stack.pop();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i ;    <span class="comment">//前一个运算符的位置</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( i == s.length()-<span class="number">1</span> || isSymbol(s.charAt(i+<span class="number">1</span>)+<span class="string">""</span>) )&#123;</span><br><span class="line">                each = start == <span class="number">0</span> ? s.substring(start,i+<span class="number">1</span>) : s.substring(start+<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isNumber(each)) &#123;</span><br><span class="line">                    data.add(each);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data not match number"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列</span></span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        data.addAll(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line"></span><br><span class="line">        System.out.println(data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doCalc</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        Double d = <span class="number">0</span>d;</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="keyword">null</span> || list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(list);</span><br><span class="line">            d = Double.valueOf(list.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list1.add(list.get(i));</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(list.get(i)))&#123;</span><br><span class="line">                Double d1 = doTheMath(list.get(i - <span class="number">2</span>), list.get(i - <span class="number">1</span>), list.get(i));</span><br><span class="line">                list1.remove(i);</span><br><span class="line">                list1.remove(i-<span class="number">1</span>);</span><br><span class="line">                list1.set(i-<span class="number">2</span>,d1+<span class="string">""</span>);</span><br><span class="line">                list1.addAll(list.subList(i+<span class="number">1</span>,list.size()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doCalc(list1);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doTheMath</span><span class="params">(String s1,String s2,String symbol)</span></span>&#123;</span><br><span class="line">        Double result ;</span><br><span class="line">        <span class="keyword">switch</span> (symbol)&#123;</span><br><span class="line">            <span class="keyword">case</span> ADD : result = Double.valueOf(s1) + Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : result = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String math = "9+(3-1)*3+10/2";</span></span><br><span class="line">        String math = <span class="string">"12.8 + (2 - 3.55)*4+10/5.0"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doCalc(doMatch(math));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-栈的介绍&quot;&gt;&lt;a href=&quot;#1-栈的介绍&quot; class=&quot;headerlink&quot; title=&quot;1.栈的介绍&quot;&gt;&lt;/a&gt;1.栈的介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;栈的英文为（stack）&lt;/li&gt;
&lt;li&gt;栈是一个&lt;strong&gt;先入后出&lt;/strong&gt;（FILO-First In Last Out）的有序列表。
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://RuanGuoHui.github.io/2019/07/17/%E9%93%BE%E8%A1%A8/"/>
    <id>https://RuanGuoHui.github.io/2019/07/17/链表/</id>
    <published>2019-07-17T01:37:02.000Z</published>
    <updated>2019-08-13T14:06:26.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-链表（Linked-List）介绍"><a href="#1-链表（Linked-List）介绍" class="headerlink" title="1.链表（Linked List）介绍"></a>1.链表（Linked List）介绍</h2><p>链表是有序的列表，但是它在内存中是存储如下 <a id="more"></a><br><img src="001.PNG" alt><br>小结上图：  </p><ol><li>链表是以节点的方式来存储，是链式存储</li><li>每个节点包含data域，next域：指向下一个节点.</li><li>如图：发现链表的各个节点不一定是连续存储.</li><li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定<h3 id="单链表（带头结点）逻辑结构示意图如下"><a href="#单链表（带头结点）逻辑结构示意图如下" class="headerlink" title="单链表（带头结点）逻辑结构示意图如下"></a>单链表（带头结点）逻辑结构示意图如下</h3><img src="002.PNG" alt>  <h2 id="2-单链表的应用实例"><a href="#2-单链表的应用实例" class="headerlink" title="2.单链表的应用实例"></a>2.单链表的应用实例</h2>使用带head头的单向链表实现-水浒英雄排行榜管理完成对英雄人物的增删改查操作  <h3 id="1-第一种方法在添加英雄时，直接添加到链表的尾部"><a href="#1-第一种方法在添加英雄时，直接添加到链表的尾部" class="headerlink" title="1)第一种方法在添加英雄时，直接添加到链表的尾部"></a>1)第一种方法在添加英雄时，直接添加到链表的尾部</h3></li></ol><p><em>思路分析示意图：</em><br><img src="003.PNG" alt>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNodef</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> no;</span><br><span class="line"> String name; </span><br><span class="line">String nickName;</span><br><span class="line">HeroNode next  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">添加（创建)</span></span><br><span class="line"><span class="comment">1.先可建一个head头节点，作用就是表示单道表的头</span></span><br><span class="line"><span class="comment">2.后面我们每添加一个节点，就直接加入到链表的最后</span></span><br><span class="line"><span class="comment">遍历：</span></span><br><span class="line"><span class="comment">1.通过一个辅助变量遍历，帮助遍历整个链表</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="2-第二种方式在添加英雄时，根据排名将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示）"><a href="#2-第二种方式在添加英雄时，根据排名将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示）" class="headerlink" title="2)第二种方式在添加英雄时，根据排名将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示）"></a>2)第二种方式在添加英雄时，<strong>根据排名</strong>将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示）</h3><p>思路的分析示意图：<br><img src="004.PNG" alt>  </p><pre>    需要按照编号的顺序添加    1.首先找到新添加的节点的位置，是通过辅助变量（指针），通过遍历来搞定    2.新的节点.next =temp.next    3.将temp.next=新的节点</pre><h3 id="3-修改节点功能"><a href="#3-修改节点功能" class="headerlink" title="3)修改节点功能"></a>3)修改节点功能</h3><p>思路<br>（1）先找到该节点，通过遍历<br>   （2）temp.name=newHeroNode.name；temp.nickname=newHeroNode.nickname</p><h3 id="4）删除节点"><a href="#4）删除节点" class="headerlink" title="4）删除节点"></a>4）删除节点</h3><p>思路分析的示意图：<br><img src="005.PNG" alt>  </p><pre>    从单链表电删除一个节点的思路    1.我们先找到需要删除的这个节点的前一个节点temp2.temn next=temp.next.next    3.被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收</pre><h3 id="5-完成的代码演示"><a href="#5-完成的代码演示" class="headerlink" title="5)完成的代码演示"></a>5)完成的代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//进行测试</span></span><br><span class="line"><span class="comment">//先创建节点</span></span><br><span class="line">HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建要给链表</span></span><br><span class="line">SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//加入</span></span><br><span class="line">singleLinkedList.add(hero1);</span><br><span class="line">singleLinkedList.add(hero4);</span><br><span class="line">singleLinkedList.add(hero2);</span><br><span class="line">singleLinkedList.add(hero3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下单链表的反转功能</span></span><br><span class="line">System.out.println(<span class="string">"原来链表的情况~~"</span>);</span><br><span class="line">singleLinkedList.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("反转单链表~~");</span></span><br><span class="line"><span class="comment">//reversetList(singleLinkedList.getHead());</span></span><br><span class="line"><span class="comment">//singleLinkedList.list();</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"测试逆序打印单链表, 没有改变链表的结构~~"</span>);</span><br><span class="line">reversePrint(singleLinkedList.getHead());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//加入按照编号的顺序</span></span><br><span class="line"><span class="comment">singleLinkedList.addByOrder(hero1);</span></span><br><span class="line"><span class="comment">singleLinkedList.addByOrder(hero4);</span></span><br><span class="line"><span class="comment">singleLinkedList.addByOrder(hero2);</span></span><br><span class="line"><span class="comment">singleLinkedList.addByOrder(hero3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//显示一把</span></span><br><span class="line"><span class="comment">singleLinkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//测试修改节点的代码</span></span><br><span class="line"><span class="comment">HeroNode newHeroNode = new HeroNode(2, "小卢", "玉麒麟~~");</span></span><br><span class="line"><span class="comment">singleLinkedList.update(newHeroNode);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("修改后的链表情况~~");</span></span><br><span class="line"><span class="comment">singleLinkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//删除一个节点</span></span><br><span class="line"><span class="comment">singleLinkedList.del(1);</span></span><br><span class="line"><span class="comment">singleLinkedList.del(4);</span></span><br><span class="line"><span class="comment">System.out.println("删除后的链表情况~~");</span></span><br><span class="line"><span class="comment">singleLinkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//测试一下 求单链表中有效节点的个数</span></span><br><span class="line"><span class="comment">System.out.println("有效的节点个数=" + getLength(singleLinkedList.getHead()));//2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//测试一下看看是否得到了倒数第K个节点</span></span><br><span class="line"><span class="comment">HeroNode res = findLastIndexNode(singleLinkedList.getHead(), 3);</span></span><br><span class="line"><span class="comment">System.out.println("res=" + res);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：</span></span><br><span class="line"><span class="comment">//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//空链表，不能打印</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建要给一个栈，将各个节点压入栈</span></span><br><span class="line">Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line"><span class="comment">//将链表的所有节点压入栈</span></span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">stack.push(cur);</span><br><span class="line">cur = cur.next; <span class="comment">//cur后移，这样就可以压入下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将栈中的节点进行打印,pop 出栈</span></span><br><span class="line"><span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(stack.pop()); <span class="comment">//stack的特点是先进后出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将单链表反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line">HeroNode next = <span class="keyword">null</span>;<span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span></span><br><span class="line"><span class="comment">//动脑筋</span></span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123; </span><br><span class="line">next = cur.next;<span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">cur.next = reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">reverseHead.next = cur; <span class="comment">//将cur 连接到新的链表上</span></span><br><span class="line">cur = next;<span class="comment">//让cur后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">head.next = reverseHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找单链表中的倒数第k个结点 【新浪面试题】</span></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">//1. 编写一个方法，接收head节点，同时接收一个index </span></span><br><span class="line"><span class="comment">//2. index 表示是倒数第index个节点</span></span><br><span class="line"><span class="comment">//3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment">//4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line"><span class="comment">//5. 如果找到了，则返回该节点，否则返回nulll</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断如果链表为空，返回null</span></span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个遍历得到链表的长度(节点个数)</span></span><br><span class="line"><span class="keyword">int</span> size = getLength(head);</span><br><span class="line"><span class="comment">//第二次遍历  size-index 位置，就是我们倒数的第K个节点</span></span><br><span class="line"><span class="comment">//先做一个index的校验</span></span><br><span class="line"><span class="keyword">if</span>(index &lt;=<span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义给辅助变量， for 循环定位到倒数的index</span></span><br><span class="line">HeroNode cur = head.next; <span class="comment">//3 // 3 - 1 = 2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; size - index; i++) &#123;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123; <span class="comment">//空链表</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义一个辅助的变量, 这里我们没有统计头节点</span></span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">length++;</span><br><span class="line">cur = cur.next; <span class="comment">//遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义SingleLinkedList 管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">//先初始化一个头节点, 头节点不要动, 不存放具体的数据</span></span><br><span class="line"><span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回头节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加节点到单向链表</span></span><br><span class="line"><span class="comment">//思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">//1. 找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">//2. 将最后这个节点的next 指向 新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="comment">//遍历链表，找到最后</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//找到链表的最后</span></span><br><span class="line"><span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有找到最后, 将将temp后移</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line"><span class="comment">//将最后这个节点的next 指向 新的节点</span></span><br><span class="line">temp.next = heroNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">//(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line"><span class="comment">//因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明temp已经在链表的最后</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(temp.next.no &gt; heroNode.no) &#123; <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode的编号已然存在</span></span><br><span class="line"></span><br><span class="line">flag = <span class="keyword">true</span>; <span class="comment">//说明编号存在</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next; <span class="comment">//后移，遍历当前链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断flag 的值</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123; <span class="comment">//不能添加，说明编号存在</span></span><br><span class="line">System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在了, 不能加入\n"</span>, heroNode.no);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//插入到链表中, temp的后面</span></span><br><span class="line">heroNode.next = temp.next;</span><br><span class="line">temp.next = heroNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改节点的信息, 根据no编号来修改，即no编号不能改.</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 根据 newHeroNode 的 no 来修改即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断是否空</span></span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到需要修改的节点, 根据no编号</span></span><br><span class="line"><span class="comment">//定义一个辅助变量</span></span><br><span class="line">HeroNode temp = head.next;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//表示是否找到该节点</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//已经遍历完链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(temp.no == newHeroNode.no) &#123;</span><br><span class="line"><span class="comment">//找到</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据flag 判断是否找到要修改的节点</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">temp.name = newHeroNode.name;</span><br><span class="line">temp.nickname = newHeroNode.nickname;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//没有找到</span></span><br><span class="line">System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">//1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">//2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123; <span class="comment">//已经到链表的最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(temp.next.no == no) &#123;</span><br><span class="line"><span class="comment">//找到的待删除节点的前一个节点temp</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next; <span class="comment">//temp后移，遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断flag</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123; <span class="comment">//找到</span></span><br><span class="line"><span class="comment">//可以删除</span></span><br><span class="line">temp.next = temp.next.next;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示链表[遍历]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">HeroNode temp = head.next;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//判断是否到链表最后</span></span><br><span class="line"><span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出节点的信息</span></span><br><span class="line">System.out.println(temp);</span><br><span class="line"><span class="comment">//将temp后移， 一定小心</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode ， 每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String nickname;</span><br><span class="line"><span class="keyword">public</span> HeroNode next; <span class="comment">//指向下一个节点</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了显示方法，我们重新toString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-单链表面试题（新浪、百度、腾讯）"><a href="#3-单链表面试题（新浪、百度、腾讯）" class="headerlink" title="3.单链表面试题（新浪、百度、腾讯）"></a>3.单链表面试题（新浪、百度、腾讯）</h2><h3 id="单链表的常见面试题有如下："><a href="#单链表的常见面试题有如下：" class="headerlink" title="单链表的常见面试题有如下："></a>单链表的常见面试题有如下：</h3><h4 id="1）求单链表中有效节点的个数"><a href="#1）求单链表中有效节点的个数" class="headerlink" title="1）求单链表中有效节点的个数"></a>1）求单链表中有效节点的个数</h4><p>代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123; <span class="comment">//空链表</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义一个辅助的变量, 这里我们没有统计头节点</span></span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">length++;</span><br><span class="line">cur = cur.next; <span class="comment">//遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）查找单链表中的倒数第k个结点【新浪面试题】"><a href="#2）查找单链表中的倒数第k个结点【新浪面试题】" class="headerlink" title="2）查找单链表中的倒数第k个结点【新浪面试题】"></a>2）查找单链表中的倒数第k个结点【新浪面试题】</h4><p>代码演示：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//查找单链表中的倒数第k个结点 【新浪面试题】</span></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">//1. 编写一个方法，接收head节点，同时接收一个index </span></span><br><span class="line"><span class="comment">//2. index 表示是倒数第index个节点</span></span><br><span class="line"><span class="comment">//3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment">//4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line"><span class="comment">//5. 如果找到了，则返回该节点，否则返回nulll</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断如果链表为空，返回null</span></span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个遍历得到链表的长度(节点个数)</span></span><br><span class="line"><span class="keyword">int</span> size = getLength(head);</span><br><span class="line"><span class="comment">//第二次遍历  size-index 位置，就是我们倒数的第K个节点</span></span><br><span class="line"><span class="comment">//先做一个index的校验</span></span><br><span class="line"><span class="keyword">if</span>(index &lt;=<span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义给辅助变量， for 循环定位到倒数的index</span></span><br><span class="line">HeroNode cur = head.next; <span class="comment">//3 // 3 - 1 = 2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; size - index; i++) &#123;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）单链表的反转【腾讯面试题，有点难度】"><a href="#3）单链表的反转【腾讯面试题，有点难度】" class="headerlink" title="3）单链表的反转【腾讯面试题，有点难度】"></a>3）单链表的反转【腾讯面试题，有点难度】</h4><h5 id="思路分析图解"><a href="#思路分析图解" class="headerlink" title="思路分析图解"></a>思路分析图解</h5><p><img src="006.PNG" alt><br><img src="007.PNG" alt>  </p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//将单链表反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line">HeroNode next = <span class="keyword">null</span>;<span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span></span><br><span class="line"><span class="comment">//动脑筋</span></span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123; </span><br><span class="line">next = cur.next;<span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">cur.next = reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">reverseHead.next = cur; <span class="comment">//将cur 连接到新的链表上</span></span><br><span class="line">cur = next;<span class="comment">//让cur后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">head.next = reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）从尾到头打印单链表【百度，要求方式1：反向遍历。方式2：Stack栈】"><a href="#4）从尾到头打印单链表【百度，要求方式1：反向遍历。方式2：Stack栈】" class="headerlink" title="4）从尾到头打印单链表【百度，要求方式1：反向遍历。方式2：Stack栈】"></a>4）从尾到头打印单链表【百度，要求方式1：反向遍历。方式2：Stack栈】</h4><h5 id="思路分析图解-1"><a href="#思路分析图解-1" class="headerlink" title="思路分析图解"></a>思路分析图解</h5><p><img src="008.PNG" alt></p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>写了一个小程序，测试Stack的使用  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示栈Stack的基本使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line">stack.add(<span class="string">"jack"</span>);</span><br><span class="line">stack.add(<span class="string">"tom"</span>);</span><br><span class="line">stack.add(<span class="string">"smith"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="comment">// smith, tom , jack</span></span><br><span class="line"><span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(stack.pop());<span class="comment">//pop就是将栈顶的数据取出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表的逆序打印代码：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//方式2：</span></span><br><span class="line"><span class="comment">//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//空链表，不能打印</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建要给一个栈，将各个节点压入栈</span></span><br><span class="line">Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line"><span class="comment">//将链表的所有节点压入栈</span></span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">stack.push(cur);</span><br><span class="line">cur = cur.next; <span class="comment">//cur后移，这样就可以压入下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将栈中的节点进行打印,pop 出栈</span></span><br><span class="line"><span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(stack.pop()); <span class="comment">//stack的特点是先进后出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表应用实例"><a href="#双向链表应用实例" class="headerlink" title="双向链表应用实例"></a>双向链表应用实例</h3><h4 id="双向链表的操作分析和实现"><a href="#双向链表的操作分析和实现" class="headerlink" title="双向链表的操作分析和实现"></a>双向链表的操作分析和实现</h4><p>使用带head头的双向链表实现-水浒英雄排行榜  </p><h5 id="管理单向链表的缺点分析："><a href="#管理单向链表的缺点分析：" class="headerlink" title="管理单向链表的缺点分析："></a>管理单向链表的缺点分析：</h5><ol><li>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。</li><li>单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp.temp是待删除节点的前一个节点（认真体会）。</li><li>分析了双向链表如何完成遍历，添加，修改和删除的思路</li></ol><p><img src="009.PNG" alt>  </p><h5 id="对上图的说明："><a href="#对上图的说明：" class="headerlink" title="对上图的说明："></a>对上图的说明：</h5><p>分析双向链表的遍历，添加，修改，删除的操作思路==》代码实现  </p><ol><li>遍历方和单链表一样，只是可以向前，也可以向后查找  </li><li>添加（默认添加到双向链表的最后）<br>（1）先找到双向链表的最后这个节点<br>（2）temp.next=newHeroNode<br>（3）newHeroNode.pre=temp；  </li><li>修改思路和原来的单向链表一样。  </li><li>删除<br>（1）因为是双向链表，因此，我们可以实现自我删除某个节点<br>（2）直接找到要删除的这个节点，比如temp<br>（3）temp.pre.next=temp.next<br>（4）temp.next.pre=temp.pre；<h5 id="双向链表代码的实现"><a href="#双向链表代码的实现" class="headerlink" title="双向链表代码的实现"></a>双向链表代码的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">System.out.println(<span class="string">"双向链表的测试"</span>);</span><br><span class="line"><span class="comment">// 先创建节点</span></span><br><span class="line">HeroNode2 hero1 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">HeroNode2 hero2 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">HeroNode2 hero3 = <span class="keyword">new</span> HeroNode2(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">HeroNode2 hero4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"><span class="comment">// 创建一个双向链表</span></span><br><span class="line">DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">doubleLinkedList.add(hero1);</span><br><span class="line">doubleLinkedList.add(hero2);</span><br><span class="line">doubleLinkedList.add(hero3);</span><br><span class="line">doubleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">HeroNode2 newHeroNode = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"公孙胜"</span>, <span class="string">"入云龙"</span>);</span><br><span class="line">doubleLinkedList.update(newHeroNode);</span><br><span class="line">System.out.println(<span class="string">"修改后的链表情况"</span>);</span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"删除后的链表情况~~"</span>);</span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个双向链表的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span></span><br><span class="line"><span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回头节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历双向链表的方法</span></span><br><span class="line"><span class="comment">// 显示链表[遍历]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">HeroNode2 temp = head.next;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 判断是否到链表最后</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出节点的信息</span></span><br><span class="line">System.out.println(temp);</span><br><span class="line"><span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个节点到双向链表的最后.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">HeroNode2 temp = head;</span><br><span class="line"><span class="comment">// 遍历链表，找到最后</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 找到链表的最后</span></span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有找到最后, 将将temp后移</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line"><span class="comment">// 形成一个双向链表</span></span><br><span class="line">temp.next = heroNode;</span><br><span class="line">heroNode.pre = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span></span><br><span class="line"><span class="comment">// 只是 节点类型改成 HeroNode2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断是否空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到需要修改的节点, 根据no编号</span></span><br><span class="line"><span class="comment">// 定义一个辅助变量</span></span><br><span class="line">HeroNode2 temp = head.next;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 表示是否找到该节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// 已经遍历完链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据flag 判断是否找到要修改的节点</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">temp.name = newHeroNode.name;</span><br><span class="line">temp.nickname = newHeroNode.nickname;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有找到</span></span><br><span class="line">System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双向链表中删除一个节点,</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1 对于双向链表，我们可以直接找到要删除的这个节点</span></span><br><span class="line"><span class="comment">// 2 找到后，自我删除即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;<span class="comment">// 空链表</span></span><br><span class="line">System.out.println(<span class="string">"链表为空，无法删除"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeroNode2 temp = head.next; <span class="comment">// 辅助变量(指针)</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123; <span class="comment">// 已经到链表的最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line"><span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next; <span class="comment">// temp后移，遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断flag</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123; <span class="comment">// 找到</span></span><br><span class="line"><span class="comment">// 可以删除</span></span><br><span class="line"><span class="comment">// temp.next = temp.next.next;[单向链表]</span></span><br><span class="line">temp.pre.next = temp.next;</span><br><span class="line"><span class="comment">// 这里我们的代码有问题?</span></span><br><span class="line"><span class="comment">// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span></span><br><span class="line"><span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">temp.next.pre = temp.pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String nickname;</span><br><span class="line"><span class="keyword">public</span> HeroNode2 next; <span class="comment">// 指向下一个节点, 默认为null</span></span><br><span class="line"><span class="keyword">public</span> HeroNode2 pre; <span class="comment">// 指向前一个节点, 默认为null</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="单向环形链表介绍"><a href="#单向环形链表介绍" class="headerlink" title="单向环形链表介绍"></a>单向环形链表介绍</h3><p><img src="006.PNG" alt>  </p><h3 id="Josephu-问题"><a href="#Josephu-问题" class="headerlink" title="Josephu 问题"></a>Josephu 问题</h3><h5 id="约瑟夫问题的示意图"><a href="#约瑟夫问题的示意图" class="headerlink" title="约瑟夫问题的示意图"></a>约瑟夫问题的示意图</h5><p><img src="010.PNG" alt>  </p><h5 id="Josephu-问题-1"><a href="#Josephu-问题-1" class="headerlink" title="Josephu 问题"></a>Josephu 问题</h5><p>Josephu问题为：设编号为1，2，…n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。  </p><h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><p>用一个不带头结点的循环链表来处理Josephu问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p><h5 id="约瑟夫问题-创建环形链表的思路图解"><a href="#约瑟夫问题-创建环形链表的思路图解" class="headerlink" title="约瑟夫问题-创建环形链表的思路图解"></a>约瑟夫问题-创建环形链表的思路图解</h5><p><img src="011.PNG" alt>  </p><h5 id="约瑟夫问题-小孩出圈的思路分析图"><a href="#约瑟夫问题-小孩出圈的思路分析图" class="headerlink" title="约瑟夫问题-小孩出圈的思路分析图"></a>约瑟夫问题-小孩出圈的思路分析图</h5><p><img src="012.PNG" alt>  </p><h4 id="Jusephu-问题的代码实现"><a href="#Jusephu-问题的代码实现" class="headerlink" title="Jusephu 问题的代码实现"></a>Jusephu 问题的代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Josepfu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">circleSingleLinkedList.addBoy(<span class="number">125</span>);<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一把小孩出圈是否正确</span></span><br><span class="line">circleSingleLinkedList.countBoy(<span class="number">10</span>, <span class="number">20</span>, <span class="number">125</span>); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line"><span class="comment">//String str = "7*2*2-5+1-5+3-3";</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形的单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个first节点,当前没有编号</span></span><br><span class="line"><span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加小孩节点，构建成一个环形的链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">// nums 做一个数据校验</span></span><br><span class="line"><span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"nums的值不正确"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Boy curBoy = <span class="keyword">null</span>; <span class="comment">// 辅助指针，帮助构建环形链表</span></span><br><span class="line"><span class="comment">// 使用for来创建我们的环形链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line"><span class="comment">// 根据编号，创建小孩节点</span></span><br><span class="line">Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line"><span class="comment">// 如果是第一个小孩</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">first = boy;</span><br><span class="line">first.setNext(first); <span class="comment">// 构成环</span></span><br><span class="line">curBoy = first; <span class="comment">// 让curBoy指向第一个小孩</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curBoy.setNext(boy);<span class="comment">//</span></span><br><span class="line">boy.setNext(first);<span class="comment">//</span></span><br><span class="line">curBoy = boy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历当前的环形链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"没有任何小孩~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">Boy curBoy = first;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">"小孩的编号 %d \n"</span>, curBoy.getNo());</span><br><span class="line"><span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curBoy = curBoy.getNext(); <span class="comment">// curBoy后移</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startNo</span></span><br><span class="line"><span class="comment"> *            表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> countNum</span></span><br><span class="line"><span class="comment"> *            表示数几下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> *            表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先对数据进行校验</span></span><br><span class="line"><span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">System.out.println(<span class="string">"参数输入有误， 请重新输入"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建要给辅助指针,帮助完成小孩出圈</span></span><br><span class="line">Boy helper = first;</span><br><span class="line"><span class="comment">// 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (helper.getNext() == first) &#123; <span class="comment">// 说明helper指向最后小孩节点</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">helper = helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小孩报数前，先让 first 和  helper 移动 k - 1次</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; startNo - <span class="number">1</span>; j++) &#123;</span><br><span class="line">first = first.getNext();</span><br><span class="line">helper = helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次, 然后出圈</span></span><br><span class="line"><span class="comment">//这里是一个循环操作，知道圈中只有一个节点</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(helper == first) &#123; <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让 first 和 helper 指针同时 的移动 countNum - 1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">first = first.getNext();</span><br><span class="line">helper = helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">System.out.printf(<span class="string">"小孩%d出圈\n"</span>, first.getNo());</span><br><span class="line"><span class="comment">//这时将first指向的小孩节点出圈</span></span><br><span class="line">first = first.getNext();</span><br><span class="line">helper.setNext(first); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">"最后留在圈中的小孩编号%d \n"</span>, first.getNo());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;<span class="comment">// 编号</span></span><br><span class="line"><span class="keyword">private</span> Boy next; <span class="comment">// 指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-链表（Linked-List）介绍&quot;&gt;&lt;a href=&quot;#1-链表（Linked-List）介绍&quot; class=&quot;headerlink&quot; title=&quot;1.链表（Linked List）介绍&quot;&gt;&lt;/a&gt;1.链表（Linked List）介绍&lt;/h2&gt;&lt;p&gt;链表是有序的列表，但是它在内存中是存储如下
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>shop难点</title>
    <link href="https://RuanGuoHui.github.io/2019/07/16/%E4%B8%80%E4%BA%9B%E5%AE%B9%E6%98%93%E5%BF%98%E8%AE%B0%E7%9A%84%E7%82%B9/"/>
    <id>https://RuanGuoHui.github.io/2019/07/16/一些容易忘记的点/</id>
    <published>2019-07-16T09:40:28.000Z</published>
    <updated>2019-07-16T09:59:29.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-servlet配置"><a href="#1-servlet配置" class="headerlink" title="1.servlet配置"></a>1.servlet配置</h2><p>在web.xml里的配置可用<strong>@WebServlet(“/admin/kdthirdsvlt/*”)</strong>注解代替，<br>写在servlet类的上面,<code>*</code>用来表示去调用哪个方法  <a id="more"></a><br><em>举例</em>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取url</span></span><br><span class="line">String clientUrl = req.getRequestURI();</span><br><span class="line"><span class="comment">//截取最后的操作</span></span><br><span class="line">String end = clientUrl.substring(clientUrl.lastIndexOf(<span class="string">"/"</span>)+<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"\n"</span>+<span class="keyword">this</span>.getClass()+<span class="string">"日志...请求是:"</span>+clientUrl+<span class="string">";截取出来的操作是"</span>+end);</span><br><span class="line"><span class="comment">//分发到方法</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"list"</span>.equals(end))list(req,resp);</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"listPage"</span>.equals(end))listPage(req,resp);</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"preAdd"</span>.equals(end))preAdd(req,resp);</span><br></pre></td></tr></table></figure><h2 id="2-三级菜单的添加和修改"><a href="#2-三级菜单的添加和修改" class="headerlink" title="2.三级菜单的添加和修改"></a>2.三级菜单的添加和修改</h2><h3 id="2-1选择一级分类后用ajax获得二级分类-js代码"><a href="#2-1选择一级分类后用ajax获得二级分类-js代码" class="headerlink" title="2.1选择一级分类后用ajax获得二级分类(js代码)"></a>2.1选择一级分类后用ajax获得二级分类(js代码)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f0</span>(<span class="params"></span>)</span>&#123;<span class="comment">//创建 XMLHttpRequest兼容IE和FireFox</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;<span class="comment">//非IE</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.ActiveXObject)&#123;<span class="comment">//IE</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xml;<span class="comment">//全局</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> shangji = <span class="built_in">document</span>.getElementById(<span class="string">"fname"</span>).value;</span><br><span class="line"><span class="keyword">if</span>(!shangji)<span class="keyword">return</span>;<span class="comment">//没选择，不用发送</span></span><br><span class="line"></span><br><span class="line">xml = f0();</span><br><span class="line">xml.open(<span class="string">"get"</span>,<span class="string">"&lt;%=path%&gt;/admin/kdthirdsvlt/getSecond?xxx="</span>+shangji,<span class="literal">true</span>);</span><br><span class="line">xml.onreadystatechange=f1back;</span><br><span class="line">xml.send(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1back</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xml.readyState ==<span class="number">4</span> &amp;&amp; xml.status==<span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> ret = xml.responseText;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myJs = <span class="built_in">eval</span>(<span class="string">"("</span>+ret+<span class="string">")"</span>);<span class="comment">//文本转json</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> citySel = <span class="built_in">document</span>.getElementById(<span class="string">"sname"</span>);</span><br><span class="line">citySel.innerHTML=<span class="string">"&lt;option value=''&gt;--请选择--&lt;/option&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;myJs.data.length;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> kd = myJs.data[i];</span><br><span class="line"></span><br><span class="line">citySel.innerHTML+=<span class="string">"&lt;option value='"</span>+kd.kid+<span class="string">"'&gt;"</span>+kd.kname+<span class="string">"&lt;/option&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-servlet代码"><a href="#2-2-servlet代码" class="headerlink" title="2.2(servlet代码)"></a>2.2(servlet代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">String p0 = req.getParameter(<span class="string">"xxx"</span>);</span><br><span class="line">System.out.println(<span class="keyword">this</span>.getClass()+<span class="string">":second日志1 要查询的上级id："</span>+p0);</span><br><span class="line">List&lt;Kind&gt; fList = kindMng.findByUpid(p0);</span><br><span class="line">System.out.println(<span class="keyword">this</span>.getClass()+<span class="string">"preAddAjax日志查询一级分类集合"</span>+(<span class="keyword">null</span>!=fList?fList.size():-<span class="number">1</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;data:[</span></span><br><span class="line"><span class="comment">&#123;'kid':'aaa','kname':'点心'&#125;,</span></span><br><span class="line"><span class="comment">&#123;'kid':'a01','kname':'蛋糕'&#125;,</span></span><br><span class="line"><span class="comment">&#123;'kid':'a02','kname':'油炸'&#125;,</span></span><br><span class="line"><span class="comment">]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String str = <span class="string">"&#123;data:["</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fList.size(); i++) &#123;</span><br><span class="line">Kind k = fList.get(i);</span><br><span class="line">str+=<span class="string">"&#123;'kid':'"</span>+k.getKid()+<span class="string">"','kname':'"</span>+k.getKname()+<span class="string">"'&#125;,"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str+=<span class="string">"]&#125;"</span>;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.getClass()+<span class="string">":list日志3生成 json格式数据"</span>);</span><br><span class="line">resp.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">resp.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">resp.getWriter().print(str);</span><br></pre></td></tr></table></figure><h3 id="2-3图片的添加上传"><a href="#2-3图片的添加上传" class="headerlink" title="2.3图片的添加上传"></a>2.3图片的添加上传</h3><p>form表单<br><code>&lt;form method=&quot;post&quot; action=&quot;&lt;%=path%&gt;/admin/kdthirdsvlt/save&quot; enctype=&quot;multipart/form-data&quot;&gt;</code>  </p><h4 id="2-3-1servlet代码-保存信息"><a href="#2-3-1servlet代码-保存信息" class="headerlink" title="2.3.1servlet代码(保存信息)"></a>2.3.1servlet代码(保存信息)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HttpSession session = req.getSession();</span><br><span class="line">String kname = <span class="string">""</span>;<span class="comment">//名称</span></span><br><span class="line">String kdesc = <span class="string">""</span>;<span class="comment">//描述</span></span><br><span class="line">String upid = <span class="string">""</span>;<span class="comment">//上级id</span></span><br><span class="line">String kdId = WebUtil.getUUID32();</span><br><span class="line">String imgName = kdId;<span class="comment">//图片名称</span></span><br><span class="line">String prjRealPath = session.getServletContext().getRealPath(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//磁盘文件工具类</span></span><br><span class="line">DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line"><span class="comment">//上传文件类</span></span><br><span class="line">ServletFileUpload commons = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line"><span class="comment">//上传编码</span></span><br><span class="line">commons.setHeaderEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"><span class="comment">//接收上传的数据，分割成FileItem</span></span><br><span class="line">List&lt;FileItem&gt; list = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">list = commons.parseRequest(req);</span><br><span class="line">&#125;<span class="keyword">catch</span>(FileUploadException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(),e.getCause());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>!=list&amp;&amp;list.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(FileItem f:list)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>!=f&amp;&amp;f.isFormField())&#123;<span class="comment">//非文件</span></span><br><span class="line"><span class="keyword">if</span>(f.getFieldName().equals(<span class="string">"tname"</span>))kname = f.getString(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f.getFieldName().equals(<span class="string">"fdesc"</span>))kdesc = f.getString(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f.getFieldName().equals(<span class="string">"sname"</span>))upid = f.getString(<span class="string">"UTF-8"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>!=f.getName()&amp;&amp;f.getName().indexOf(<span class="string">"."</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//截取文件后缀名 拼接成UUID+.jpg</span></span><br><span class="line">imgName = imgName+f.getName().substring(f.getName().indexOf(<span class="string">"."</span>));</span><br><span class="line"><span class="comment">//拼接保存的目录</span></span><br><span class="line">String filePath = prjRealPath+WebUtil.kind_img_path+imgName;</span><br><span class="line"></span><br><span class="line">BufferedInputStream befin = <span class="keyword">new</span> BufferedInputStream(f.getInputStream(),<span class="number">1024</span>*<span class="number">1024</span>);<span class="comment">//读文件</span></span><br><span class="line">BufferedOutputStream befout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(filePath),<span class="number">1024</span>*<span class="number">1024</span>);<span class="comment">//写文件</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((x=befin.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">befout.write(x);</span><br><span class="line">&#125;</span><br><span class="line">befout.flush();</span><br><span class="line">befout.close();</span><br><span class="line">befin.close();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">imgName = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//上传处理完毕</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n日志1接收到的分类名称："</span>+kname+<span class="string">"\t分类描述"</span>+kdesc+<span class="string">"分类图片"</span>+imgName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KindManager kMan = <span class="keyword">new</span> KindManagerImpl();</span><br><span class="line">Kind k = <span class="keyword">new</span> Kind();</span><br><span class="line">k.setKid(WebUtil.getUUID32());</span><br><span class="line">k.setKname(kname);</span><br><span class="line">System.out.println(<span class="string">"tname="</span>+kname);</span><br><span class="line">k.setKimg(imgName);</span><br><span class="line">k.setKdesc(kdesc);</span><br><span class="line">k.setUpid(upid);</span><br><span class="line">System.out.println(<span class="string">"\n日志2保存数据库"</span>);</span><br><span class="line"></span><br><span class="line">kMan.save(k);</span><br><span class="line">resp.sendRedirect(  req.getContextPath()+ <span class="string">"/admin/kdthirdsvlt/list"</span>);</span><br></pre></td></tr></table></figure><h3 id="2-4修改预处理"><a href="#2-4修改预处理" class="headerlink" title="2.4修改预处理"></a>2.4修改预处理</h3><ol><li>查询所有的一级分类</li><li>查询id为kid的三级分类信息，包含一级分类和二级分类的名字和id</li><li>通过查出的third三级分类信息，找出它的一级分类id，再通过id findByUpid方法查出它所有的二级分类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">String kid = req.getParameter(<span class="string">"updid"</span>);</span><br><span class="line">System.out.println(<span class="string">"KindServlet日志1、、、要修改的id:"</span>+kid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询所有的一级分类</span></span><br><span class="line">List&lt;Kind&gt; first = kindMng.findFirstAll();</span><br><span class="line">System.out.println(<span class="string">"KindServlet_preUpdAjax日志2.。。。查询一级分类集合："</span>+(<span class="keyword">null</span>!=first?first.size():-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询id为kid的三级分类信息，包含一级分类和二级分类的名字和id</span></span><br><span class="line">Map&lt;String,Object&gt; third = kindMng.findThirdById(kid);</span><br><span class="line">System.out.println(<span class="keyword">this</span>.getClass()+<span class="string">"preUpdAjax日志3...查询三级分类信息"</span>+third);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过查出的third三级分类信息，找出它的一级分类id，再通过id findByUpid方法查出它所有的二级分类</span></span><br><span class="line">List&lt;Kind&gt; second = kindMng.findByUpid((String)third.get(<span class="string">"fstId"</span>));</span><br><span class="line">System.out.println(<span class="keyword">this</span>.getClass()+<span class="string">"preUpdAjax日志4...查询三级分类上级的兄弟分类(二级分类)"</span>+(<span class="keyword">null</span>!=second?second.size():-<span class="number">1</span>));</span><br><span class="line">req.setAttribute(<span class="string">"yyy"</span>, first);</span><br><span class="line">req.setAttribute(<span class="string">"eee"</span>, second);</span><br><span class="line">req.setAttribute(<span class="string">"thd"</span>, third);</span><br><span class="line"></span><br><span class="line">req.getRequestDispatcher(<span class="string">"/admin/kind/kindthird_upd222.jsp"</span>).forward(req, resp);</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-4-1回显一级分类"><a href="#2-4-1回显一级分类" class="headerlink" title="2.4.1回显一级分类"></a>2.4.1回显一级分类</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">data-am-selected</span> <span class="attr">name</span>=<span class="string">"fname"</span> <span class="attr">id</span>=<span class="string">"fname"</span> <span class="attr">onchange</span>=<span class="string">"f1()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>--请选择--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag"><span class="attr">if</span> (<span class="attr">null</span> != <span class="string">firstList</span> &amp;&amp; <span class="attr">firstList.size</span>() &gt;</span> 0) &#123;</span><br><span class="line">for (Kind kd : firstList) &#123;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;option value="&lt;%=kd.getKid()%&gt;"&lt;%=kd.getKid().equals(thdType.get("fstId"))?"selected":"" %&gt;&gt;&lt;%=kd.getKname()%&gt;&lt;/option&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">&#125;//<span class="attr">for</span>()</span></span><br><span class="line"><span class="tag">&#125;</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-2回显二级分类"><a href="#2-4-2回显二级分类" class="headerlink" title="2.4.2回显二级分类"></a>2.4.2回显二级分类</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">data-am-selected</span> <span class="attr">name</span>=<span class="string">"sname"</span> <span class="attr">id</span>=<span class="string">"sname"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">if</span>(<span class="attr">null</span>!=<span class="string">second&amp;&amp;second.size()</span>&gt;</span>0)&#123;</span><br><span class="line">for(int i = 0;i<span class="tag">&lt;<span class="name">second.size();i++)&#123;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Kind</span> <span class="attr">sec</span> = <span class="string">second.get(i);</span></span></span><br><span class="line"><span class="tag"> %&gt;</span></span><br><span class="line"> &lt;option value="&lt;%=sec.getKid()%&gt;" &lt;%=sec.getKid().equals(thdType.get("secid"))?"selected":"" %&gt;&gt;&lt;%=sec.getKname() %&gt;&lt;/option&gt;</span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag"> &#125;</span></span><br><span class="line"><span class="tag"> &#125;</span></span><br><span class="line"><span class="tag">  %&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-3选择一级分类用ajax实现二级分类的改变-同上"><a href="#2-4-3选择一级分类用ajax实现二级分类的改变-同上" class="headerlink" title="2.4.3选择一级分类用ajax实现二级分类的改变(同上)"></a>2.4.3选择一级分类用ajax实现二级分类的改变(同上)</h4><h4 id="2-4-4图片的修改"><a href="#2-4-4图片的修改" class="headerlink" title="2.4.4图片的修改"></a>2.4.4图片的修改</h4><p><strong>之前的图片名写在隐藏域中便于判断是否修改</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HttpSession session = req.getSession();</span><br><span class="line">String kname = <span class="string">""</span>;<span class="comment">//名称</span></span><br><span class="line">String kdesc = <span class="string">""</span>;<span class="comment">//描述</span></span><br><span class="line">String upid = <span class="string">""</span>;<span class="comment">//上级id</span></span><br><span class="line">String kdId = <span class="string">""</span>;</span><br><span class="line">String imgName = <span class="string">""</span>;<span class="comment">//图片名称</span></span><br><span class="line">String befImg = <span class="string">""</span>;<span class="comment">//之前的图片</span></span><br><span class="line">String prjRealPath = session.getServletContext().getRealPath(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//磁盘文件工具类</span></span><br><span class="line">DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line"><span class="comment">//上传文件类</span></span><br><span class="line">ServletFileUpload commons = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line"><span class="comment">//上传编码</span></span><br><span class="line">commons.setHeaderEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"><span class="comment">//接收上传的数据，分割成FileItem</span></span><br><span class="line">List&lt;FileItem&gt; list ;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">list = commons.parseRequest(req);</span><br><span class="line">&#125;<span class="keyword">catch</span>(FileUploadException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(),e.getCause());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>!=list&amp;&amp;list.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(FileItem f:list)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>!=f&amp;&amp;f.isFormField())&#123;<span class="comment">//非文件</span></span><br><span class="line"><span class="keyword">if</span>(f.getFieldName().equals(<span class="string">"tname"</span>))kname = f.getString(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f.getFieldName().equals(<span class="string">"fdesc"</span>))kdesc = f.getString(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f.getFieldName().equals(<span class="string">"thdid"</span>))kdId = f.getString(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f.getFieldName().equals(<span class="string">"sname"</span>))upid = f.getString(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f.getFieldName().equals(<span class="string">"thimg"</span>))befImg = f.getString(<span class="string">"UTF-8"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>!=f.getName()&amp;&amp;f.getName().indexOf(<span class="string">"."</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//截取文件后缀名 拼接成UUID+.jpg</span></span><br><span class="line">imgName = kdId+f.getName().substring(f.getName().indexOf(<span class="string">"."</span>));</span><br><span class="line"><span class="comment">//拼接保存的目录</span></span><br><span class="line">String filePath = prjRealPath+WebUtil.kind_img_path+imgName;</span><br><span class="line"></span><br><span class="line">BufferedInputStream befin = <span class="keyword">new</span> BufferedInputStream(f.getInputStream(),<span class="number">1024</span>*<span class="number">1024</span>);<span class="comment">//读文件</span></span><br><span class="line">BufferedOutputStream befout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(filePath),<span class="number">1024</span>*<span class="number">1024</span>);<span class="comment">//写文件</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((x=befin.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">befout.write(x);</span><br><span class="line">&#125;</span><br><span class="line">befout.flush();</span><br><span class="line">befout.close();</span><br><span class="line">befin.close();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">imgName = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//上传处理完毕</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n日志1接收到的分类名称："</span>+kname+<span class="string">"\t分类描述"</span>+kdesc+<span class="string">"分类图片"</span>+imgName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KindManager kMan = <span class="keyword">new</span> KindManagerImpl();</span><br><span class="line">Kind k = <span class="keyword">new</span> Kind();</span><br><span class="line">k.setKid(kdId);</span><br><span class="line">k.setKname(kname);</span><br><span class="line">System.out.println(<span class="string">"kname="</span>+kname);</span><br><span class="line">k.setKimg(imgName==<span class="keyword">null</span>?befImg:imgName);</span><br><span class="line">k.setKdesc(kdesc);</span><br><span class="line">k.setUpid(upid);</span><br><span class="line">System.out.println(<span class="string">"\n日志2保存数据库"</span>);</span><br><span class="line"></span><br><span class="line">kMan.update(k);</span><br><span class="line">resp.sendRedirect( req.getContextPath() + <span class="string">"/admin/kdthirdsvlt/list"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-servlet配置&quot;&gt;&lt;a href=&quot;#1-servlet配置&quot; class=&quot;headerlink&quot; title=&quot;1.servlet配置&quot;&gt;&lt;/a&gt;1.servlet配置&lt;/h2&gt;&lt;p&gt;在web.xml里的配置可用&lt;strong&gt;@WebServlet(“/admin/kdthirdsvlt/*”)&lt;/strong&gt;注解代替，&lt;br&gt;写在servlet类的上面,&lt;code&gt;*&lt;/code&gt;用来表示去调用哪个方法
    
    </summary>
    
      <category term="笔记" scheme="https://RuanGuoHui.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="难点" scheme="https://RuanGuoHui.github.io/categories/%E7%AC%94%E8%AE%B0/%E9%9A%BE%E7%82%B9/"/>
    
    
      <category term="ajax" scheme="https://RuanGuoHui.github.io/tags/ajax/"/>
    
      <category term="上传" scheme="https://RuanGuoHui.github.io/tags/%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组和队列</title>
    <link href="https://RuanGuoHui.github.io/2019/07/15/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://RuanGuoHui.github.io/2019/07/15/稀疏数组和队列/</id>
    <published>2019-07-15T15:14:18.000Z</published>
    <updated>2019-07-18T02:48:39.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-稀疏-sparsearray-数组"><a href="#1-稀疏-sparsearray-数组" class="headerlink" title="1.稀疏 sparsearray 数组"></a>1.稀疏 sparsearray 数组</h2><h3 id="1-1先看一个实际的需求"><a href="#1-1先看一个实际的需求" class="headerlink" title="1.1先看一个实际的需求"></a>1.1先看一个实际的需求</h3><p>编写的五子棋程序中，有存盘退出和续上盘的功能 <a id="more"></a><br><img src="001.PNG" alt><br>分析问题：<br>因为该二维数组的很多值是默认值0，因此记录了<strong>很多没有意义的数据.-&gt;稀疏数组</strong>。  </p><h3 id="1-2基本介绍"><a href="#1-2基本介绍" class="headerlink" title="1.2基本介绍"></a>1.2基本介绍</h3><p>当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。<br>稀疏数组的处理方法是：  </p><ol><li>记录数组<strong>一共有几行几列，有多少个不同</strong>的值  </li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而<strong>缩小程序</strong>的规模  <blockquote><p>稀疏数组举例说明  </p></blockquote></li></ol><p><img src="002.png" alt>  </p><h3 id="1-3应用实例"><a href="#1-3应用实例" class="headerlink" title="1.3应用实例"></a>1.3应用实例</h3><ol><li><p>使用稀疏数组，来保留类似前面的二维数组（棋盘、地图等等)</p></li><li><p>把稀疏数组存盘，并且可以从新恢复原来的二维数组数</p></li><li><p>整体思路分析</p><blockquote><p><img src="003.PNG" alt><br>   <em>二增数组转稀硫数组的思路</em><br>1.遍历原始的二维数组，得到有效数据的个数sum<br>2.根据sum 就可以创速稀疏数组 sparseArr int[sum+1][3]<br>3.将二维数组的有效数据数据存入到稀疏数组  </p></blockquote><blockquote><p><em>稀疏数组转原新的二维数组的思路</em><br>1.先读取稀疏数组的第一行，根据第一行的数据，创连原始的二维数组，比如上面的cheser2=int[11][11]<br>2.在读取稀疏数组后几行的数据，并赋给原始的二维数组即可。  </p></blockquote></li><li><p>代码实现</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rgh.sparsearray;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span></span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;  </span><br><span class="line"><span class="comment">//创建一个原始的二维数组11*11  </span></span><br><span class="line"><span class="comment">//0：表示没有棋子，1表示黑子2表蓝子  </span></span><br><span class="line"><span class="keyword">int</span> chessArr1[<span class="number">0</span>[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];  </span><br><span class="line">chessArrl[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">chessArrl[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">2</span>;   </span><br><span class="line">chessArrl[<span class="number">4</span>][<span class="number">5</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//输出原始的二维数组</span></span><br><span class="line">System.out.println(<span class="string">"原始的二维数组~"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] row:chessArr1)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> data:row)&#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将二维数组转稀疏数组的思想</span></span><br><span class="line"><span class="comment">//1.先遍历二维数组得到非0数据的个数</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(chessArr1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建对应的稀疏数组</span></span><br><span class="line"><span class="keyword">int</span> sparseArr[][]=<span class="keyword">new</span> <span class="keyword">int</span>[sum +<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//给稀疏数组赋值</span></span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">2</span>]=sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历二维数组，将非0的值存放到sparseArr中</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//count 用于记录是第几个非0数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(chessArrl[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">sparseAr[count][<span class="number">0</span>]=i;</span><br><span class="line">sparseAr[count][<span class="number">1</span>]=j;</span><br><span class="line">sparseAr[count][<span class="number">2</span>]=chessArr1[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出稀疏数组的形式</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.<span class="function">out <span class="title">println</span><span class="params">(<span class="string">"得到稀疏数组为~"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; sparseArr.length;i++)&#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>,sparseArr[i][<span class="number">0</span>],sparseAr[i][<span class="number">1</span>],sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">System.<span class="function">out <span class="title">println</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//将稀疏数组-》恢复成原始的二维数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2=int[11][11]</span></span><br><span class="line"><span class="comment">2.在读取稀疏数组后几行的数据，并赋给原始的二维数组即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"><span class="keyword">int</span> chessArr2[][]=<span class="keyword">new</span> <span class="keyword">int</span>[sparseAr[<span class="number">0</span>][<span class="number">0</span>]][sparseAr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"><span class="comment">//2.在读取稀疏数组后几行的数据(从第二行开始)，并赋给原始的二维数组即可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt; sparseArr.length;i++)&#123;</span><br><span class="line">chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]]=sparseAr[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出恢复后的二维数组</span></span><br><span class="line">System.<span class="function">out <span class="title">println</span><span class="params">()</span></span>;</span><br><span class="line">System.out.printin(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] row:chessArr2)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> data:row)&#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h2><h3 id="2-1队列介绍"><a href="#2-1队列介绍" class="headerlink" title="2.1队列介绍"></a>2.1队列介绍</h3><ol><li>队列是一个有序列表，可以用数组或是链表来实现。</li><li>遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li><li>示意图：（使用数组模拟队列示意图）<br>  <img src="004.PNG" alt></li></ol><h3 id="2-2数组模拟环形队列"><a href="#2-2数组模拟环形队列" class="headerlink" title="2.2数组模拟环形队列"></a>2.2数组模拟环形队列</h3><p>充分利用数组.因此将数组看做是一个环形的。（通过取模的方式来实现即可）  </p><h4 id="分析说明："><a href="#分析说明：" class="headerlink" title="分析说明："></a>分析说明：</h4><ol><li>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定，这个在做判断队列满的时候需要注意（rear+1）%maxSize==front 满]</li><li>rear==front[空]</li><li>分析示意图:</li></ol><p><img src="004.PNG" alt><br><em>思路如下</em>    </p><ol><li>front 变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素front的初始值=0  </li><li>rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间做为约定。rear的初始值=0  </li><li>当队列满时，条件是（rear +1)%maxSize=front【满】  </li><li>当队列为空的条件，rear==front空  </li><li>当我们这样分析，队列中有效的数据的个数<strong>（rear+maxsize-front）%maxsize</strong>//rear=1 front=0  </li><li>我们就可以在原来的队列上修改得到，一个环形队列  </li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rgh.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一把</span></span><br><span class="line">System.out.println(<span class="string">"测试数组模拟环形队列的案例~~~"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形队列</span></span><br><span class="line">CircleArray queue = <span class="keyword">new</span> CircleArray(<span class="number">4</span>); <span class="comment">//说明设置4, 其队列的有效数据最大是3</span></span><br><span class="line"><span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">// 接收用户输入</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 输出一个菜单</span></span><br><span class="line"><span class="keyword">while</span> (loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"s(show): 显示队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"e(exit): 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"a(add): 添加数据到队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"g(get): 从队列取出数据"</span>);</span><br><span class="line">System.out.println(<span class="string">"h(head): 查看队列头的数据"</span>);</span><br><span class="line">key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">// 接收一个字符</span></span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">queue.showQueue();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">queue.addQueue(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">// 取出数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">// 查看队列头的数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">// 退出</span></span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line"><span class="comment">//front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 </span></span><br><span class="line"><span class="comment">//front 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front; </span><br><span class="line"><span class="comment">//rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line"><span class="comment">//rear 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">maxSize = arrMaxSize;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (rear  + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据到队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断队列是否满</span></span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列满，不能加入数据~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接将数据加入</span></span><br><span class="line">arr[rear] = n;</span><br><span class="line"><span class="comment">//将 rear 后移, 这里必须考虑取模</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列的数据, 出队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断队列是否空</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 通过抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里需要分析出 front是指向队列的第一个元素</span></span><br><span class="line"><span class="comment">// 1. 先把 front 对应的值保留到一个临时变量</span></span><br><span class="line"><span class="comment">// 2. 将 front 后移, 考虑取模</span></span><br><span class="line"><span class="comment">// 3. 将临时保存的变量返回</span></span><br><span class="line"><span class="keyword">int</span> value = arr[front];</span><br><span class="line">front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line"><span class="comment">// 动脑筋</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size() ; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出当前队列有效数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// rear = 2</span></span><br><span class="line"><span class="comment">// front = 1</span></span><br><span class="line"><span class="comment">// maxSize = 3 </span></span><br><span class="line"><span class="keyword">return</span> (rear + maxSize - front) % maxSize;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[front];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-稀疏-sparsearray-数组&quot;&gt;&lt;a href=&quot;#1-稀疏-sparsearray-数组&quot; class=&quot;headerlink&quot; title=&quot;1.稀疏 sparsearray 数组&quot;&gt;&lt;/a&gt;1.稀疏 sparsearray 数组&lt;/h2&gt;&lt;h3 id=&quot;1-1先看一个实际的需求&quot;&gt;&lt;a href=&quot;#1-1先看一个实际的需求&quot; class=&quot;headerlink&quot; title=&quot;1.1先看一个实际的需求&quot;&gt;&lt;/a&gt;1.1先看一个实际的需求&lt;/h3&gt;&lt;p&gt;编写的五子棋程序中，有存盘退出和续上盘的功能
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法概述</title>
    <link href="https://RuanGuoHui.github.io/2019/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <id>https://RuanGuoHui.github.io/2019/07/14/数据结构与算法概述/</id>
    <published>2019-07-14T11:39:10.000Z</published>
    <updated>2019-07-14T11:45:25.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法概述"><a href="#数据结构与算法概述" class="headerlink" title="数据结构与算法概述"></a>数据结构与算法概述</h1><h2 id="数据结构与算法的关系"><a href="#数据结构与算法的关系" class="headerlink" title="数据结构与算法的关系"></a>数据结构与算法的关系</h2><ol><li>数据data结构(structure)是一门<strong>研究组织数据方式</strong>的学科，有了编程语言也就有了数据结构。学好数据结构可以编写出更加漂亮，更加有效率的代码。<a id="more"></a></li><li>要学习好数据结构就要多多考虑如何将生活中遇到的问题，用程序去实现解决</li><li><strong>程序 = 数据结构 + 算法</strong></li><li><strong>数据结构是算法的基础</strong>，换言之，想要学好算法，需要把数据结构学到位</li></ol><h2 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h2><p>数据结构包括：线性结构和非线性结构。</p><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><ol><li>线性结构作为最常用的数据结构，其特点是<strong>数据元素之间存在一对一</strong>的线性关系</li><li>线性结构有两种不同的存储结构，即<strong>顺序存储结构（数组）</strong>和<strong>链式存储结构（链表）</strong>。顺序存储的线性表称为顺序表，顺序表中的<strong>存储元素是连续</strong>的</li><li>链式存储的线性表称为链表，链表中的<strong>存储元素不一定是连续的</strong>，元素节点中存放数据元素以及相邻元素的地址信息</li><li>线性结构常见的有：<strong>数组、队列、链表和栈</strong>，后面我们会详细讲解<h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构与算法概述&quot;&gt;&lt;a href=&quot;#数据结构与算法概述&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法概述&quot;&gt;&lt;/a&gt;数据结构与算法概述&lt;/h1&gt;&lt;h2 id=&quot;数据结构与算法的关系&quot;&gt;&lt;a href=&quot;#数据结构与算法的关系&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法的关系&quot;&gt;&lt;/a&gt;数据结构与算法的关系&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;数据data结构(structure)是一门&lt;strong&gt;研究组织数据方式&lt;/strong&gt;的学科，有了编程语言也就有了数据结构。学好数据结构可以编写出更加漂亮，更加有效率的代码。
    
    </summary>
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://RuanGuoHui.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://RuanGuoHui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown插入图片补充</title>
    <link href="https://RuanGuoHui.github.io/2019/07/10/MarkDown%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E8%A1%A5%E5%85%85/"/>
    <id>https://RuanGuoHui.github.io/2019/07/10/MarkDown插入图片补充/</id>
    <published>2019-07-10T12:42:18.000Z</published>
    <updated>2019-07-14T14:14:03.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MarkDown插入图片补充"><a href="#MarkDown插入图片补充" class="headerlink" title="MarkDown插入图片补充"></a>MarkDown插入图片补充</h1><h2 id="1-本地引用"><a href="#1-本地引用" class="headerlink" title="1.本地引用"></a>1.本地引用</h2><h3 id="1-1绝对路径"><a href="#1-1绝对路径" class="headerlink" title="1.1绝对路径"></a>1.1绝对路径</h3><p>当Hexo项目中只用到少量图片时，可以将图片统一放在<code>source/images</code>文件夹中，通过markdown语法访问它们。  <a id="more"></a><br><img src="001.PNG" alt><br>图片既可以在首页内容中访问到，也可以在文章正文中访问到。  </p><h3 id="1-2相对路径"><a href="#1-2相对路径" class="headerlink" title="1.2相对路径"></a>1.2相对路径</h3><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。<br><img src="002.PNG" alt><br>将<code>_config.yml</code>文件中的配置项<code>post_asset_folder</code>设为true后，执行命令<code>$ hexo new post_name</code>，在<code>source/_posts</code>中会生成文章<code>post_name.md</code>和同名文件夹<code>post_name</code>。将图片资源放在<code>post_name</code>中，文章就可以使用相对路径引用图片资源了。 </p><p><strong>上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。</strong>  </p><p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。<br><img src="003.PNG" alt>   </p><h2 id="2-CDN引用"><a href="#2-CDN引用" class="headerlink" title="2.CDN引用"></a>2.CDN引用</h2><p>除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。比如Cloudinary提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MarkDown插入图片补充&quot;&gt;&lt;a href=&quot;#MarkDown插入图片补充&quot; class=&quot;headerlink&quot; title=&quot;MarkDown插入图片补充&quot;&gt;&lt;/a&gt;MarkDown插入图片补充&lt;/h1&gt;&lt;h2 id=&quot;1-本地引用&quot;&gt;&lt;a href=&quot;#1-本地引用&quot; class=&quot;headerlink&quot; title=&quot;1.本地引用&quot;&gt;&lt;/a&gt;1.本地引用&lt;/h2&gt;&lt;h3 id=&quot;1-1绝对路径&quot;&gt;&lt;a href=&quot;#1-1绝对路径&quot; class=&quot;headerlink&quot; title=&quot;1.1绝对路径&quot;&gt;&lt;/a&gt;1.1绝对路径&lt;/h3&gt;&lt;p&gt;当Hexo项目中只用到少量图片时，可以将图片统一放在&lt;code&gt;source/images&lt;/code&gt;文件夹中，通过markdown语法访问它们。
    
    </summary>
    
      <category term="语法" scheme="https://RuanGuoHui.github.io/categories/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="MarkDown" scheme="https://RuanGuoHui.github.io/categories/%E8%AF%AD%E6%B3%95/MarkDown/"/>
    
    
      <category term="语法" scheme="https://RuanGuoHui.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="MarkDown" scheme="https://RuanGuoHui.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown常用语法</title>
    <link href="https://RuanGuoHui.github.io/2019/07/09/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>https://RuanGuoHui.github.io/2019/07/09/MarkDown常用语法/</id>
    <published>2019-07-09T12:42:18.000Z</published>
    <updated>2019-07-14T12:31:11.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MarkDown常用语法"><a href="#MarkDown常用语法" class="headerlink" title="MarkDown常用语法"></a>MarkDown常用语法</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>MarkDown语法和Html语法有一定的相似性，比如对于标题的定义，不论是MarkDown还是Html都分了6级。不同的是MarkDown是使用#号来进行标示。<a id="more"></a><br>具体格式为# 内容或者 # 内容 #，这两个语法等效，后者在某些场合应为表明了起始位置而显得更易阅读。其中#号的数量标示了标题的级别，1个#对应1级标题，2个#号对应2级标题。具体示例如下：<br><img src="https://pic1.zhimg.com/v2-29905d76fca3614e30d26deb22a8167c_r.jpg" alt="12">  </p><h2 id="2-分割线"><a href="#2-分割线" class="headerlink" title="2.分割线"></a>2.分割线</h2><p>MarkDown的分割线书写方式十分自然，和平时在电脑上进行文字编辑时输入分割线的方式基本一致。只需要连续的输入3个以上-或者*即可。如下所示：<br><img src="https://pic4.zhimg.com/v2-f800847cd38e6f1120f816f7e27b7c7b_r.jpg" alt="123">  </p><h2 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h2><p>MarkDown的列表语法看上去也十分自然，无需列表以* 空格，+ 空格，或者- 空格开头，而有序列表以数字. 空格开头。并且有序列表并不关注数字的内容，只需要时数字，即可按照顺序进行排序编号。如下所示：<br><img src="https://pic2.zhimg.com/v2-a86c0289241fd6469fa5beef4e8b21a9_r.jpg" alt="213">  </p><h2 id="4-超链接"><a href="#4-超链接" class="headerlink" title="4.超链接"></a>4.超链接</h2><p>MarkDown的超链接的语法格式虽然有两种，但是作为常用语法来说<code>[描述](链接地址)</code>这样的语法更容易被人们接受。如下所示：<br><img src="https://pic3.zhimg.com/v2-8e12d7602cbdd1f4a5a8b1b689125096_r.jpg" alt="333">  </p><h2 id="5-引用"><a href="#5-引用" class="headerlink" title="5.引用"></a>5.引用</h2><p>MarkDown使用&gt;符号来作为引用段落的标示。引用的段落会用明显的标示与正文进行区分。不过在引用段落内，一个回车符并不能让文本内容按照期望换行，仅仅只是加入了一个空格字符而已。如果需要让文本内容换行，那么需要输入两个回车符。如下所示：<br><img src="https://pic4.zhimg.com/v2-4e531e32da1a17002f112cf1e4c3b2af_r.jpg" alt="引用">  </p><h2 id="6-代码"><a href="#6-代码" class="headerlink" title="6.代码"></a>6.代码</h2><p>作为一个开发人员，无法避免的需要在文本中插入代码。在很多其他编辑器中，插入代码并设置代码格式，其实并不是一件容易的事儿。不过在MarkDown这里，不得不为代码插入点个赞。仅仅使用两个制表符，就可以完成代码的插入。</p><p>如果是再行内插入代码，则使用成对出现的反引号`表示代码,</p><p>如下所示：<br><img src="https://pic2.zhimg.com/v2-321c3b1a525180244edc03f11abeb915_r.jpg" alt="代码">  </p><h2 id="7-粗体和斜体"><a href="#7-粗体和斜体" class="headerlink" title="7.粗体和斜体"></a>7.粗体和斜体</h2><p>在MarkDown语法中，使用不同数量的<em>内容</em>号即可设定文字是粗体、斜体、或者两者都是。</p><p>1个<code>*</code>号代表斜体<br>2个<code>*</code>号代表粗体<br>3个<code>*</code>号代表斜体+粗体<br>如下所示：<br><img src="https://pic1.zhimg.com/v2-4214fa683571fd14c49fec8bded3d158_r.jpg" alt="粗体斜体">    </p><h2 id="8-图片"><a href="#8-图片" class="headerlink" title="8.图片"></a>8.图片</h2><p>MarkDown中插入图片的语法是<code>![描述](图片地址 &quot;图片替代文本&quot;)</code>。</p><p>其中描述在不同的MarkDown编辑器里有不同的效果，有的编辑器并不会显示出描述的文本内容。</p><p>图片替代文本就是HTML中<img>标签中的alt属性，这是在图片无法显示时的替代文本，也是用于描述图片内容的属性。</p><p>目前MarkDown语法暂时无法定于图片大小，如果需要定于图片大小，可以使用HTML语言中的<img>标签。</p><p>具体示例如下所示：<br><img src="https://pic2.zhimg.com/80/v2-f617b11cbb8b4ab314e441c7ec95f555_hd.png" alt="图片">  </p><h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9.表格"></a>9.表格</h2><p>MarkDown中的表格制作略显复杂，但是这个复杂仅仅是对于用惯了Office系列软件的人们而言。其实就语法而言，MarkDown的表格制作依然是简单到只要让人看一眼表格制作的示例，就能明白如何制作表格的程度。这里先提几个概念：</p><ol><li>符号|是表格中每一列单元格的分割。</li><li>通常一行没有回车符的文本就代表表格中的一行。</li><li>表格头和表格体使用——-进行分割，其中-的数量应该大于或等于3个。</li><li>在第3点钟的符号前后可以加入:设定单元格的对齐方式。<ul><li>不加:时，表示默认的左对齐。</li><li>在前后都加:时，表示水平居中对其。</li><li>在尾部加:时，表示右对齐。</li></ul></li><li>在单元格内换行，可以使用<code>&lt;br/&gt;</code>进行换行操作。</li><li>每一行的列数允许少于总列数。<br><img src="https://pic1.zhimg.com/80/v2-4a7b2dac630ee2d0f993161cded84584_hd.png" alt="表格">  <h2 id="10-自动转换"><a href="#10-自动转换" class="headerlink" title="10.自动转换"></a>10.自动转换</h2></li></ol><p>MarkDown已经足够的智能，可以使用&lt;可识别内容&gt;的语法，通过&lt;&gt;来完成自动转换。例如：<br><img src="https://pic3.zhimg.com/80/v2-bef0d9ba269c559fe6b597bb730fdbfe_hd.png" alt="自动">  </p><h2 id="11-其他"><a href="#11-其他" class="headerlink" title="11.其他"></a>11.其他</h2><ul><li>如果不能换行，可以尝试多敲几次回车</li><li>如果还是不能换行，可以试试<code>&lt;br/&gt;</code></li><li>MarkDown已经足够的智能，可以在大多数情况下正确识别&lt;&gt;，&amp;，.，以及单双引号所需要的格式。</li><li>如果不能正确识别&lt;&gt;，&amp;，.，以及单双引号所需要的格式，那么可是使用反斜杠作为转移符使用  </li></ul><p>这是<a href="https://zhuanlan.zhihu.com/p/24575242" rel="external nofollow noopener noreferrer" target="_blank">文章引用地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MarkDown常用语法&quot;&gt;&lt;a href=&quot;#MarkDown常用语法&quot; class=&quot;headerlink&quot; title=&quot;MarkDown常用语法&quot;&gt;&lt;/a&gt;MarkDown常用语法&lt;/h1&gt;&lt;h2 id=&quot;1-标题&quot;&gt;&lt;a href=&quot;#1-标题&quot; class=&quot;headerlink&quot; title=&quot;1.标题&quot;&gt;&lt;/a&gt;1.标题&lt;/h2&gt;&lt;p&gt;MarkDown语法和Html语法有一定的相似性，比如对于标题的定义，不论是MarkDown还是Html都分了6级。不同的是MarkDown是使用#号来进行标示。
    
    </summary>
    
      <category term="语法" scheme="https://RuanGuoHui.github.io/categories/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="MarkDown" scheme="https://RuanGuoHui.github.io/categories/%E8%AF%AD%E6%B3%95/MarkDown/"/>
    
    
      <category term="语法" scheme="https://RuanGuoHui.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="MarkDown" scheme="https://RuanGuoHui.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://RuanGuoHui.github.io/2019/07/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://RuanGuoHui.github.io/2019/07/04/我的第一篇博客/</id>
    <published>2019-07-04T11:03:11.000Z</published>
    <updated>2019-07-16T09:17:30.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这是我的第一个技术博客，会记录一些博客内容，同时也会记录我的生活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我的第一篇博客&quot;&gt;&lt;a href=&quot;#我的第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;我的第一篇博客&quot;&gt;&lt;/a&gt;我的第一篇博客&lt;/h2&gt;&lt;p&gt;这是我的第一个技术博客，会记录一些博客内容，同时也会记录我的生活。&lt;/p&gt;

      
    
    </summary>
    
      <category term="HTML" scheme="https://RuanGuoHui.github.io/categories/HTML/"/>
    
      <category term="前端" scheme="https://RuanGuoHui.github.io/categories/HTML/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="https://RuanGuoHui.github.io/tags/HTML/"/>
    
      <category term="前端" scheme="https://RuanGuoHui.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://RuanGuoHui.github.io/2019/07/04/hello-world/"/>
    <id>https://RuanGuoHui.github.io/2019/07/04/hello-world/</id>
    <published>2019-07-04T10:53:00.859Z</published>
    <updated>2019-07-14T11:50:22.512Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" rel="external nofollow noopener noreferrer" target="_blank">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" rel="external nofollow noopener noreferrer" target="_blank">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>. <a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" rel="external nofollow noopener noreferrer" target="_blank">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" rel="external nofollow noopener noreferrer" target="_blank">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" rel="external nofollow noopener noreferrer" target="_blank">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" rel="external nofollow noopener noreferrer" target="_blank">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;.
    
    </summary>
    
    
  </entry>
  
</feed>
